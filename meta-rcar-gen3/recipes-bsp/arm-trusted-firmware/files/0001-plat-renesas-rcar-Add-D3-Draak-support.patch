From ed4e875063ebb022e8a931f1c09848bd0cd0d06f Mon Sep 17 00:00:00 2001
From: Marek Vasut <marek.vasut+renesas@gmail.com>
Date: Thu, 14 Jun 2018 06:26:45 +0200
Subject: [PATCH] plat: renesas: rcar: Add D3 Draak support

Add support for the D3 Draak platform

Signed-off-by: Marek Vasut <marek.vasut+renesas@gmail.com>
---
Build using the following command:
$ make CROSS_COMPILE=aarch64-linux-gnu- PLAT=rcar RCAR_BL33_EXECUTION_EL=1 LSI=D3 RCAR_SA0_SIZE=0 RCAR_AVS_SETTING_ENABLE=0 bl2 bl31 dummytool

Collect the following artifacts:
$ cp -v {build/rcar/release/bl{2,31},tools/dummy_create/*}.{bin,srec} /srv/tftp/r8a77995-draak/
---
 Makefile                                      |    1 +
 docs/diagrams/generate_reset_images.sh        |    0
 plat/renesas/rcar/bl2_cpg_init.c              |   94 +-
 plat/renesas/rcar/bl2_rcar_setup.c            |   38 +-
 plat/renesas/rcar/bl2_secure_setting.c        |    2 +-
 plat/renesas/rcar/bl31_rcar_setup.c           |    5 +-
 plat/renesas/rcar/ddr/D3/boot_init_dram_d3.h  |   38 +
 .../rcar/ddr/D3/boot_init_dram_regdef_d3.h    |  232 +
 plat/renesas/rcar/ddr/D3/ddr_init_d3.c        |  690 +++
 plat/renesas/rcar/ddr/boot_init_dram.c        |   90 +
 plat/renesas/rcar/ddr/boot_init_dram.h        |   11 +-
 plat/renesas/rcar/ddr/ddr.mk                  |   15 +-
 plat/renesas/rcar/ddr/ddr_b/boot_init_dram.c  | 4072 +----------------
 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c    |    2 +-
 plat/renesas/rcar/drivers/rom/rom_api.c       |    5 +-
 plat/renesas/rcar/drivers/scif/scif.S         |    9 +
 plat/renesas/rcar/drivers/timer/bl2_swdt.c    |    4 +
 plat/renesas/rcar/include/platform_def.h      |    2 +-
 plat/renesas/rcar/pfc/D3/pfc_init_d3.c        |  969 ++++
 plat/renesas/rcar/pfc/D3/pfc_init_d3.h        |   37 +
 plat/renesas/rcar/pfc/pfc.mk                  |    3 +
 plat/renesas/rcar/pfc/pfc_init.c              |   10 +
 plat/renesas/rcar/platform.mk                 |   26 +-
 plat/renesas/rcar/qos/D3/qos_init_d3.c        |  606 +++
 plat/renesas/rcar/qos/D3/qos_init_d3.h        |   37 +
 plat/renesas/rcar/qos/qos.mk                  |    3 +
 plat/renesas/rcar/qos/qos_init.c              |   13 +-
 plat/renesas/rcar/rcar_def.h                  |    2 +
 plat/renesas/rcar/rcar_pm.c                   |    4 +
 tools/dummy_create/makefile                   |    8 +-
 tools/dummy_create/sa0.c                      |    6 +-
 31 files changed, 2986 insertions(+), 4048 deletions(-)
 mode change 100755 => 100644 docs/diagrams/generate_reset_images.sh
 create mode 100644 plat/renesas/rcar/ddr/D3/boot_init_dram_d3.h
 create mode 100644 plat/renesas/rcar/ddr/D3/boot_init_dram_regdef_d3.h
 create mode 100644 plat/renesas/rcar/ddr/D3/ddr_init_d3.c
 create mode 100644 plat/renesas/rcar/ddr/boot_init_dram.c
 create mode 100644 plat/renesas/rcar/pfc/D3/pfc_init_d3.c
 create mode 100644 plat/renesas/rcar/pfc/D3/pfc_init_d3.h
 create mode 100644 plat/renesas/rcar/qos/D3/qos_init_d3.c
 create mode 100644 plat/renesas/rcar/qos/D3/qos_init_d3.h

diff --git a/Makefile b/Makefile
index 27005449..3f2cc077 100644
--- a/Makefile
+++ b/Makefile
@@ -37,6 +37,7 @@ include ${MAKE_HELPERS_DIRECTORY}defaults.mk
 ENABLE_ASSERTIONS		:= ${DEBUG}
 ENABLE_PMF			:= ${ENABLE_RUNTIME_INSTRUMENTATION}
 PLAT				:= ${DEFAULT_PLAT}
+SPD				:= none
 
 ################################################################################
 # Checkpatch script options
diff --git a/docs/diagrams/generate_reset_images.sh b/docs/diagrams/generate_reset_images.sh
old mode 100755
new mode 100644
diff --git a/plat/renesas/rcar/bl2_cpg_init.c b/plat/renesas/rcar/bl2_cpg_init.c
index 249174dd..49b05b1f 100644
--- a/plat/renesas/rcar/bl2_cpg_init.c
+++ b/plat/renesas/rcar/bl2_cpg_init.c
@@ -44,7 +44,10 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Module Stop Control Register 1 */
 	cpg_write(SCMSTPCR1,	0xFFFFFFFFU);
 
-#if (RCAR_LSI == RCAR_E3)
+#if (RCAR_LSI == RCAR_D3)
+	/* Secure Module Stop Control Register 2 */
+	cpg_write(SCMSTPCR2,	0xFFFFFFFFU);
+#elif (RCAR_LSI == RCAR_E3)
 	/* Secure Module Stop Control Register 2 */
 	cpg_write(SCMSTPCR2,	0xEFFFFFFFU);
 #else /* RCAR_LSI == RCAR_E3 */
@@ -55,9 +58,9 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Module Stop Control Register 3 */
 	cpg_write(SCMSTPCR3,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 4 */
-	cpg_write(SCMSTPCR4,	0x7FFFFFFFU);
+	cpg_write(SCMSTPCR4,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 5 */
-	cpg_write(SCMSTPCR5,	0xBFFFFFFFU);
+	cpg_write(SCMSTPCR5,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 6 */
 	cpg_write(SCMSTPCR6,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 7 */
@@ -65,7 +68,7 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Module Stop Control Register 8 */
 	cpg_write(SCMSTPCR8,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 9 */
-	cpg_write(SCMSTPCR9,	0xFFFDFFFFU);
+	cpg_write(SCMSTPCR9,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 10 */
 	cpg_write(SCMSTPCR10,	0xFFFFFFFFU);
 	/* Secure Module Stop Control Register 11 */
@@ -75,7 +78,10 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Software Reset Access Enable Control Register 1 */
 	cpg_write(SCSRSTECR1,	0x00000000U);
 
-#if (RCAR_LSI == RCAR_E3)
+#if (RCAR_LSI == RCAR_D3)
+	/* Secure Software Reset Access Enable Control Register 2 */
+	cpg_write(SCSRSTECR2,	0x00000000U);
+#elif (RCAR_LSI == RCAR_E3)
 	/* Secure Software Reset Access Enable Control Register 2 */
 	cpg_write(SCSRSTECR2,	0x10000000U);
 #else /* RCAR_LSI == RCAR_E3 */
@@ -86,9 +92,9 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Software Reset Access Enable Control Register 3 */
 	cpg_write(SCSRSTECR3,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 4 */
-	cpg_write(SCSRSTECR4,	0x80000003U);
+	cpg_write(SCSRSTECR4,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 5 */
-	cpg_write(SCSRSTECR5,	0x40000000U);
+	cpg_write(SCSRSTECR5,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 6 */
 	cpg_write(SCSRSTECR6,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 7 */
@@ -96,7 +102,7 @@ static void bl2_secure_cpg_init(void)
 	/* Secure Software Reset Access Enable Control Register 8 */
 	cpg_write(SCSRSTECR8,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 9 */
-	cpg_write(SCSRSTECR9,	0x00020000U);
+	cpg_write(SCSRSTECR9,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 10 */
 	cpg_write(SCSRSTECR10,	0x00000000U);
 	/* Secure Software Reset Access Enable Control Register 11 */
@@ -303,6 +309,68 @@ static void bl2_system_cpg_init_m3n(void)
 }
 #endif /* (RCAR_LSI == RCAR_AUTO) || (RCAR_LSI == RCAR_M3N) */
 
+#if (RCAR_LSI == RCAR_AUTO) || (RCAR_LSI == RCAR_D3)
+static void bl2_realtime_cpg_init_d3(void)
+{
+	/* CPG (REALTIME) registers */
+
+	/* Realtime Module Stop Control Register 0 */
+	cpg_write(RMSTPCR0,	0x00010000U);
+	/* Realtime Module Stop Control Register 1 */
+	cpg_write(RMSTPCR1,	0xFFFFFFFFU);
+	/* Realtime Module Stop Control Register 2 */
+	cpg_write(RMSTPCR2,	0x00060FDCU);
+	/* Realtime Module Stop Control Register 3 */
+	cpg_write(RMSTPCR3,	0xFFFFFFFFU);
+	/* Realtime Module Stop Control Register 4 */
+	cpg_write(RMSTPCR4,	0x80000184U);
+	/* Realtime Module Stop Control Register 5 */
+	cpg_write(RMSTPCR5,	0x83FFFFFFU);
+	/* Realtime Module Stop Control Register 6 */
+	cpg_write(RMSTPCR6,	0xFFFFFFFFU);
+	/* Realtime Module Stop Control Register 7 */
+	cpg_write(RMSTPCR7,	0xFFFFFFFFU);
+	/* Realtime Module Stop Control Register 8 */
+	cpg_write(RMSTPCR8,	0x00F1FFF7U);
+	/* Realtime Module Stop Control Register 9 */
+	cpg_write(RMSTPCR9,	0xF3F5E016U);
+	/* Realtime Module Stop Control Register 10 */
+	cpg_write(RMSTPCR10,	0xFFFEFFE0U);
+	/* Realtime Module Stop Control Register 11 */
+	cpg_write(RMSTPCR11,	0x000000B7U);
+}
+
+static void bl2_system_cpg_init_d3(void)
+{
+	/* CPG (SYSTEM) registers */
+
+	/* System Module Stop Control Register 0 */
+	cpg_write(SMSTPCR0,	0x00010000U);
+	/* System Module Stop Control Register 1 */
+	cpg_write(SMSTPCR1,	0xFFFFFFFFU);
+	/* System Module Stop Control Register 2 */
+	cpg_write(SMSTPCR2,	0x00060FDCU);
+	/* System Module Stop Control Register 3 */
+	cpg_write(SMSTPCR3,	0xFFFFFFFFU);
+	/* System Module Stop Control Register 4 */
+	cpg_write(SMSTPCR4,	0x00000084U);
+	/* System Module Stop Control Register 5 */
+	cpg_write(SMSTPCR5,	0x83FFFFFFU);
+	/* System Module Stop Control Register 6 */
+	cpg_write(SMSTPCR6,	0xFFFFFFFFU);
+	/* System Module Stop Control Register 7 */
+	cpg_write(SMSTPCR7,	0xFFFFFFFFU);
+	/* System Module Stop Control Register 8 */
+	cpg_write(SMSTPCR8,	0x00F1FFF7U);
+	/* System Module Stop Control Register 9 */
+	cpg_write(SMSTPCR9,	0xF3F5E016U);
+	/* System Module Stop Control Register 10 */
+	cpg_write(SMSTPCR10,	0xFFFEFFE0U);
+	/* System Module Stop Control Register 11 */
+	cpg_write(SMSTPCR11,	0x000000B7U);
+}
+#endif /* (RCAR_LSI == RCAR_AUTO) || (RCAR_LSI == RCAR_D3) */
+
 #if (RCAR_LSI == RCAR_E3)
 static void bl2_realtime_cpg_init_e3(void)
 {
@@ -393,6 +461,9 @@ void bl2_cpg_init(void)
 		case RCAR_PRODUCT_M3N:
 			bl2_realtime_cpg_init_m3n();
 			break;
+		case RCAR_PRODUCT_D3:
+			bl2_realtime_cpg_init_d3();
+			break;
 		default:
 			panic();
 			break;
@@ -403,6 +474,8 @@ void bl2_cpg_init(void)
 		bl2_realtime_cpg_init_m3();
 #elif RCAR_LSI == RCAR_M3N
 		bl2_realtime_cpg_init_m3n();
+#elif RCAR_LSI == RCAR_D3
+		bl2_realtime_cpg_init_d3();
 #elif RCAR_LSI == RCAR_E3
 		bl2_realtime_cpg_init_e3();
 #else /* RCAR_LSI == RCAR_XX */
@@ -427,6 +500,9 @@ void bl2_system_cpg_init(void)
 	case RCAR_PRODUCT_M3N:
 		bl2_system_cpg_init_m3n();
 		break;
+	case RCAR_PRODUCT_D3:
+		bl2_system_cpg_init_d3();
+		break;
 	default:
 		panic();
 		break;
@@ -437,6 +513,8 @@ void bl2_system_cpg_init(void)
 	bl2_system_cpg_init_m3();
 #elif RCAR_LSI == RCAR_M3N
 	bl2_system_cpg_init_m3n();
+#elif RCAR_LSI == RCAR_D3
+	bl2_system_cpg_init_d3();
 #elif RCAR_LSI == RCAR_E3
 	bl2_system_cpg_init_e3();
 #else /* RCAR_LSI == RCAR_XX */
diff --git a/plat/renesas/rcar/bl2_rcar_setup.c b/plat/renesas/rcar/bl2_rcar_setup.c
index f1b9b7a3..bbba85d5 100644
--- a/plat/renesas/rcar/bl2_rcar_setup.c
+++ b/plat/renesas/rcar/bl2_rcar_setup.c
@@ -127,6 +127,9 @@
 #elif RCAR_LSI == RCAR_E3
 #define TARGET_PRODUCT		RCAR_PRODUCT_E3
 #define TARGET_NAME		"R-Car E3"
+#elif RCAR_LSI == RCAR_D3
+#define TARGET_PRODUCT		RCAR_PRODUCT_D3
+#define TARGET_NAME		"R-Car D3"
 #endif
 
 /* for SuspendToRAM */
@@ -399,12 +402,15 @@ void bl2_early_platform_setup(meminfo_t *mem_layout)
 	const char *product_m3      = "M3";
 	const char *product_m3n     = "M3N";
 	const char *product_e3      = "E3";
+	const char *product_d3      = "D3";
 	const char *lcs_cm          = "CM";
 	const char *lcs_dm          = "DM";
 	const char *lcs_sd          = "SD";
 	const char *lcs_secure      = "SE";
 	const char *lcs_fa          = "FA";
-#if RCAR_LSI == RCAR_E3
+#if RCAR_LSI == RCAR_D3
+	const char *boot_hyper150   = "HyperFlash(150MHz)";
+#elif RCAR_LSI == RCAR_E3
 	const char *boot_hyper160   = "HyperFlash(150MHz)";
 #else /* RCAR_LSI == RCAR_E3 */
 	const char *boot_hyper160   = "HyperFlash(160MHz)";
@@ -457,7 +463,7 @@ void bl2_early_platform_setup(meminfo_t *mem_layout)
 		str = unknown;
 		break;
 	}
-	(void)sprintf(msg, "BL2: R-Car Gen3 Initial Program Loader(%s) Rev.%s\n"
+	(void)sprintf(msg, "BL2: R-Car D3 Initial Program Loader(%s) Rev.%s\n"
 						, str, version_of_renesas);
 	NOTICE("%s", msg);
 
@@ -477,6 +483,9 @@ void bl2_early_platform_setup(meminfo_t *mem_layout)
 	case RCAR_PRODUCT_E3:
 		str = product_e3;
 		break;
+	case RCAR_PRODUCT_D3:
+		str = product_d3;
+		break;
 	default:
 		str = unknown;
 		break;
@@ -551,7 +560,11 @@ void bl2_early_platform_setup(meminfo_t *mem_layout)
 
 	switch (modemr_boot_dev) {
 	case MODEMR_BOOT_DEV_HYPERFLASH160:
+#if RCAR_LSI == RCAR_D3
+		str = boot_hyper150;
+#else
 		str = boot_hyper160;
+#endif
 		break;
 	case MODEMR_BOOT_DEV_HYPERFLASH80:
 		str = boot_hyper80;
@@ -572,6 +585,13 @@ void bl2_early_platform_setup(meminfo_t *mem_layout)
 		str = unknown;
 		break;
 	}
+#if RCAR_LSI == RCAR_D3
+	if((str == boot_emmc25x1) || (str == boot_emmc50x8)){
+		ERROR("BL2: Failed to Initialize. eMMC is not supported.\n");
+		/* Infinite loop */
+		panic();
+	}
+#endif
 	(void)sprintf(msg, "BL2: Boot device is %s\n", str);
 	NOTICE("%s", msg);
 
@@ -826,10 +846,15 @@ void bl2_plat_flush_bl31_params(void)
 	}
 
 	val = mmio_read_32(RCAR_PRR);
+#if DEBUG
+	val = RCAR_PRODUCT_D3;
+#endif
 	if ((RCAR_PRODUCT_M3 == (val & RCAR_PRODUCT_MASK)) ||
 		((RCAR_PRODUCT_H3 == (val & RCAR_PRODUCT_MASK)) &&
-			(RCAR_CUT_VER20 > (val & RCAR_CUT_MASK)))) {
+			(RCAR_CUT_VER20 > (val & RCAR_CUT_MASK))) ||
+	    (RCAR_PRODUCT_D3 == (val & RCAR_PRODUCT_MASK))) {
 		/* No need to disable MFIS write protection */
+		INFO("BL2: bl2_plat_flush_bl31_params val=0x%x\n", val);
 		;
 	} else {
 		/* Disable MFIS write protection */
@@ -894,6 +919,9 @@ void bl2_plat_flush_bl31_params(void)
 	/* disable the System WDT, FIQ and GIC	*/
 	bl2_swdt_release();
 
+	/* Finalize a console of provide early debug support */
+	console_flush();
+
 	/* Initialize the System Module stop registers */
 	bl2_system_cpg_init();
 
@@ -1014,7 +1042,9 @@ void bl2_plat_get_bl33_meminfo(meminfo_t *bl33_meminfo)
 
 void bl2_init_generic_timer(void)
 {
-#if RCAR_LSI == RCAR_E3
+#if RCAR_LSI == RCAR_D3
+	uint32_t reg_cntfid = EXTAL_DRAAK;
+#elif RCAR_LSI == RCAR_E3
 	uint32_t reg_cntfid = EXTAL_EBISU;
 #else /* RCAR_LSI == RCAR_E3 */
 	uint32_t reg;
diff --git a/plat/renesas/rcar/bl2_secure_setting.c b/plat/renesas/rcar/bl2_secure_setting.c
index 991af825..b35300fd 100644
--- a/plat/renesas/rcar/bl2_secure_setting.c
+++ b/plat/renesas/rcar/bl2_secure_setting.c
@@ -64,7 +64,7 @@ static const struct {
 	/*        1: Reserved[R-Car E3] */
 	/* Bit10: SCEG Secure Core slave ports. */
 	/*        0: registers can be accessed from secure resource only. */
-#if RCAR_LSI == RCAR_E3
+#if (RCAR_LSI == RCAR_D3 || RCAR_LSI == RCAR_E3)
 	{SEC_SEL6,		0xFFFFFBFFU},
 #else /* RCAR_LSI == RCAR_E3 */
 	{SEC_SEL6,		0xFFFFCBFFU},
diff --git a/plat/renesas/rcar/bl31_rcar_setup.c b/plat/renesas/rcar/bl31_rcar_setup.c
index 50c22a59..27d29939 100644
--- a/plat/renesas/rcar/bl31_rcar_setup.c
+++ b/plat/renesas/rcar/bl31_rcar_setup.c
@@ -102,7 +102,9 @@ entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
 void bl31_early_platform_setup(bl31_params_t *from_bl2,
 		void *plat_params_from_bl2)
 {
+#if RCAR_LSI != RCAR_D3
 	uint32_t cluster_type;
+#endif
 
 	/* Initialize the log area to provide early debug support */
 	console_init(1U, 0U, 0U);
@@ -118,6 +120,7 @@ void bl31_early_platform_setup(bl31_params_t *from_bl2,
 
 	bl2_to_bl31_params = from_bl2;
 
+#if RCAR_LSI != RCAR_D3
 	cluster_type = rcar_bl31_get_cluster();
 	if (RCAR_CLUSTER_A53A57 == cluster_type) {
 		/*
@@ -131,7 +134,7 @@ void bl31_early_platform_setup(bl31_params_t *from_bl2,
 		 */
 		rcar_cci_enable();
 	}
-
+#endif
 }
 
 /*******************************************************************************
diff --git a/plat/renesas/rcar/ddr/D3/boot_init_dram_d3.h b/plat/renesas/rcar/ddr/D3/boot_init_dram_d3.h
new file mode 100644
index 00000000..24980346
--- /dev/null
+++ b/plat/renesas/rcar/ddr/D3/boot_init_dram_d3.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BOOT_INIT_DRAM_D3__
+#define	BOOT_INIT_DRAM_D3__
+
+extern uint32_t init_ddr_d31866(void);
+extern uint32_t init_ddr_d31600(void);
+
+#endif /* BOOT_INIT_DRAM_D3__ */
diff --git a/plat/renesas/rcar/ddr/D3/boot_init_dram_regdef_d3.h b/plat/renesas/rcar/ddr/D3/boot_init_dram_regdef_d3.h
new file mode 100644
index 00000000..505c5a95
--- /dev/null
+++ b/plat/renesas/rcar/ddr/D3/boot_init_dram_regdef_d3.h
@@ -0,0 +1,232 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Revision history
+ *
+ * rev.0.01    2017/05/22    New
+ */
+
+#ifndef BOOT_INIT_DRAM_REGDEF_D3_H_
+#define BOOT_INIT_DRAM_REGDEF_D3_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define				BIT0						0x00000001U
+#define				BIT30						0x40000000U
+
+/* DBSC registers */
+
+#define				DBSC_D3_DBSYSCONF1         0xE6790004U
+#define				DBSC_D3_DBPHYCONF0         0xE6790010U
+#define				DBSC_D3_DBKIND             0xE6790020U
+#define				DBSC_D3_DBMEMCONF00        0xE6790030U
+#define				DBSC_D3_DBMEMCONF01        0xE6790034U
+#define				DBSC_D3_DBMEMCONF02        0xE6790038U
+#define				DBSC_D3_DBMEMCONF03        0xE679003CU
+#define				DBSC_D3_DBMEMCONF10        0xE6790040U
+#define				DBSC_D3_DBMEMCONF11        0xE6790044U
+#define				DBSC_D3_DBMEMCONF12        0xE6790048U
+#define				DBSC_D3_DBMEMCONF13        0xE679004CU
+#define				DBSC_D3_DBMEMCONF20        0xE6790050U
+#define				DBSC_D3_DBMEMCONF21        0xE6790054U
+#define				DBSC_D3_DBMEMCONF22        0xE6790058U
+#define				DBSC_D3_DBMEMCONF23        0xE679005CU
+#define				DBSC_D3_DBMEMCONF30        0xE6790060U
+#define				DBSC_D3_DBMEMCONF31        0xE6790064U
+#define				DBSC_D3_DBMEMCONF32        0xE6790068U
+#define				DBSC_D3_DBMEMCONF33        0xE679006CU
+#define				DBSC_D3_DBSYSCNT0          0xE6790100U
+#define				DBSC_D3_DBSVCR1            0xE6790104U
+#define				DBSC_D3_DBSTATE0           0xE6790108U
+#define				DBSC_D3_DBSTATE1           0xE679010CU
+#define				DBSC_D3_DBINTEN            0xE6790180U
+#define				DBSC_D3_DBINTSTAT0         0xE6790184U
+#define				DBSC_D3_DBACEN             0xE6790200U
+#define				DBSC_D3_DBRFEN             0xE6790204U
+#define				DBSC_D3_DBCMD              0xE6790208U
+#define				DBSC_D3_DBWAIT             0xE6790210U
+#define				DBSC_D3_DBSYSCTRL0         0xE6790280U
+#define				DBSC_D3_DBTR0              0xE6790300U
+#define				DBSC_D3_DBTR1              0xE6790304U
+#define				DBSC_D3_DBTR2              0xE6790308U
+#define				DBSC_D3_DBTR3              0xE679030CU
+#define				DBSC_D3_DBTR4              0xE6790310U
+#define				DBSC_D3_DBTR5              0xE6790314U
+#define				DBSC_D3_DBTR6              0xE6790318U
+#define				DBSC_D3_DBTR7              0xE679031CU
+#define				DBSC_D3_DBTR8              0xE6790320U
+#define				DBSC_D3_DBTR9              0xE6790324U
+#define				DBSC_D3_DBTR10             0xE6790328U
+#define				DBSC_D3_DBTR11             0xE679032CU
+#define				DBSC_D3_DBTR12             0xE6790330U
+#define				DBSC_D3_DBTR13             0xE6790334U
+#define				DBSC_D3_DBTR14             0xE6790338U
+#define				DBSC_D3_DBTR15             0xE679033CU
+#define				DBSC_D3_DBTR16             0xE6790340U
+#define				DBSC_D3_DBTR17             0xE6790344U
+#define				DBSC_D3_DBTR18             0xE6790348U
+#define				DBSC_D3_DBTR19             0xE679034CU
+#define				DBSC_D3_DBTR20             0xE6790350U
+#define				DBSC_D3_DBTR21             0xE6790354U
+#define				DBSC_D3_DBTR22             0xE6790358U
+#define				DBSC_D3_DBTR24             0xE6790360U
+#define				DBSC_D3_DBTR25             0xE6790364U
+#define				DBSC_D3_DBBL               0xE6790400U
+#define				DBSC_D3_DBRFCNF1           0xE6790414U
+#define				DBSC_D3_DBRFCNF2           0xE6790418U
+#define				DBSC_D3_DBCALCNF           0xE6790424U
+#define				DBSC_D3_DBRNK2             0xE6790438U
+#define				DBSC_D3_DBRNK3             0xE679043CU
+#define				DBSC_D3_DBRNK4             0xE6790440U
+#define				DBSC_D3_DBRNK5             0xE6790444U
+#define				DBSC_D3_DBPDNCNF           0xE6790450U
+#define				DBSC_D3_DBODT0             0xE6790460U
+#define				DBSC_D3_DBODT1             0xE6790464U
+#define				DBSC_D3_DBODT2             0xE6790468U
+#define				DBSC_D3_DBODT3             0xE679046CU
+#define				DBSC_D3_DBADJ0             0xE6790500U
+#define				DBSC_D3_DBDBICNT           0xE6790518U
+#define				DBSC_D3_DBDFICUPDCNF       0xE679052CU
+#define				DBSC_D3_DBDFICNT0          0xE6790604U
+#define				DBSC_D3_DBPDLK0            0xE6790620U
+#define				DBSC_D3_DBPDRGA0           0xE6790624U
+#define				DBSC_D3_DBPDRGD0           0xE6790628U
+#define				DBSC_D3_DBPDSTAT00         0xE6790630U
+#define				DBSC_D3_DBDFISTAT1         0xE6790640U
+#define				DBSC_D3_DBDFICNT1          0xE6790644U
+#define				DBSC_D3_DBPDLK1            0xE6790660U
+#define				DBSC_D3_DBPDRGA1           0xE6790664U
+#define				DBSC_D3_DBPDRGD1           0xE6790668U
+#define				DBSC_D3_DBDFICNT2          0xE6790684U
+#define				DBSC_D3_DBPDLK2            0xE67906A0U
+#define				DBSC_D3_DBPDRGA2           0xE67906A4U
+#define				DBSC_D3_DBPDRGD2           0xE67906A8U
+#define				DBSC_D3_DBPDSTAT20         0xE67906B0U
+#define				DBSC_D3_DBDFISTAT3         0xE67906C0U
+#define				DBSC_D3_DBDFICNT3          0xE67906C4U
+#define				DBSC_D3_DBPDLK3            0xE67906E0U
+#define				DBSC_D3_DBPDRGA3           0xE67906E4U
+#define				DBSC_D3_DBPDRGD3           0xE67906E8U
+#define				DBSC_D3_DBBUS0CNF1         0xE6790804U
+#define				DBSC_D3_DBCAM0CNF1         0xE6790904U
+#define				DBSC_D3_DBCAM0CNF2         0xE6790908U
+#define				DBSC_D3_DBCAM0STAT0        0xE6790980U
+#define				DBSC_D3_DBCAM1STAT0        0xE6790990U
+#define				DBSC_D3_DBBCAMDIS          0xE67909FCU
+#define				DBSC_D3_DBSCHCNT0          0xE6791000U
+#define				DBSC_D3_DBSCHSZ0           0xE6791010U
+#define				DBSC_D3_DBSCHRW0           0xE6791020U
+#define				DBSC_D3_DBSCHRW1           0xE6791024U
+#define				DBSC_D3_DBSCHQOS00         0xE6791030U
+#define				DBSC_D3_DBSCHQOS01         0xE6791034U
+#define				DBSC_D3_DBSCHQOS02         0xE6791038U
+#define				DBSC_D3_DBSCHQOS03         0xE679103CU
+#define				DBSC_D3_DBSCHQOS10         0xE6791040U
+#define				DBSC_D3_DBSCHQOS11         0xE6791044U
+#define				DBSC_D3_DBSCHQOS12         0xE6791048U
+#define				DBSC_D3_DBSCHQOS13         0xE679104CU
+#define				DBSC_D3_DBSCHQOS20         0xE6791050U
+#define				DBSC_D3_DBSCHQOS21         0xE6791054U
+#define				DBSC_D3_DBSCHQOS22         0xE6791058U
+#define				DBSC_D3_DBSCHQOS23         0xE679105CU
+#define				DBSC_D3_DBSCHQOS30         0xE6791060U
+#define				DBSC_D3_DBSCHQOS31         0xE6791064U
+#define				DBSC_D3_DBSCHQOS32         0xE6791068U
+#define				DBSC_D3_DBSCHQOS33         0xE679106CU
+#define				DBSC_D3_DBSCHQOS40         0xE6791070U
+#define				DBSC_D3_DBSCHQOS41         0xE6791074U
+#define				DBSC_D3_DBSCHQOS42         0xE6791078U
+#define				DBSC_D3_DBSCHQOS43         0xE679107CU
+#define				DBSC_D3_DBSCHQOS50         0xE6791080U
+#define				DBSC_D3_DBSCHQOS51         0xE6791084U
+#define				DBSC_D3_DBSCHQOS52         0xE6791088U
+#define				DBSC_D3_DBSCHQOS53         0xE679108CU
+#define				DBSC_D3_DBSCHQOS60         0xE6791090U
+#define				DBSC_D3_DBSCHQOS61         0xE6791094U
+#define				DBSC_D3_DBSCHQOS62         0xE6791098U
+#define				DBSC_D3_DBSCHQOS63         0xE679109CU
+#define				DBSC_D3_DBSCHQOS70         0xE67910A0U
+#define				DBSC_D3_DBSCHQOS71         0xE67910A4U
+#define				DBSC_D3_DBSCHQOS72         0xE67910A8U
+#define				DBSC_D3_DBSCHQOS73         0xE67910ACU
+#define				DBSC_D3_DBSCHQOS80         0xE67910B0U
+#define				DBSC_D3_DBSCHQOS81         0xE67910B4U
+#define				DBSC_D3_DBSCHQOS82         0xE67910B8U
+#define				DBSC_D3_DBSCHQOS83         0xE67910BCU
+#define				DBSC_D3_DBSCHQOS90         0xE67910C0U
+#define				DBSC_D3_DBSCHQOS91         0xE67910C4U
+#define				DBSC_D3_DBSCHQOS92         0xE67910C8U
+#define				DBSC_D3_DBSCHQOS93         0xE67910CCU
+#define				DBSC_D3_DBSCHQOS100        0xE67910D0U
+#define				DBSC_D3_DBSCHQOS101        0xE67910D4U
+#define				DBSC_D3_DBSCHQOS102        0xE67910D8U
+#define				DBSC_D3_DBSCHQOS103        0xE67910DCU
+#define				DBSC_D3_DBSCHQOS110        0xE67910E0U
+#define				DBSC_D3_DBSCHQOS111        0xE67910E4U
+#define				DBSC_D3_DBSCHQOS112        0xE67910E8U
+#define				DBSC_D3_DBSCHQOS113        0xE67910ECU
+#define				DBSC_D3_DBSCHQOS120        0xE67910F0U
+#define				DBSC_D3_DBSCHQOS121        0xE67910F4U
+#define				DBSC_D3_DBSCHQOS122        0xE67910F8U
+#define				DBSC_D3_DBSCHQOS123        0xE67910FCU
+#define				DBSC_D3_DBSCHQOS130        0xE6791100U
+#define				DBSC_D3_DBSCHQOS131        0xE6791104U
+#define				DBSC_D3_DBSCHQOS132        0xE6791108U
+#define				DBSC_D3_DBSCHQOS133        0xE679110CU
+#define				DBSC_D3_DBSCHQOS140        0xE6791110U
+#define				DBSC_D3_DBSCHQOS141        0xE6791114U
+#define				DBSC_D3_DBSCHQOS142        0xE6791118U
+#define				DBSC_D3_DBSCHQOS143        0xE679111CU
+#define				DBSC_D3_DBSCHQOS150        0xE6791120U
+#define				DBSC_D3_DBSCHQOS151        0xE6791124U
+#define				DBSC_D3_DBSCHQOS152        0xE6791128U
+#define				DBSC_D3_DBSCHQOS153        0xE679112CU
+#define				DBSC_D3_SCFCTST0           0xE6791700U
+#define				DBSC_D3_SCFCTST1           0xE6791708U
+#define				DBSC_D3_SCFCTST2           0xE679170CU
+#define				DBSC_D3_DBMRRDR0           0xE6791800U
+#define				DBSC_D3_DBMRRDR1           0xE6791804U
+#define				DBSC_D3_DBMRRDR2           0xE6791808U
+#define				DBSC_D3_DBMRRDR3           0xE679180CU
+#define				DBSC_D3_DBMRRDR4           0xE6791810U
+#define				DBSC_D3_DBMRRDR5           0xE6791814U
+#define				DBSC_D3_DBMRRDR6           0xE6791818U
+#define				DBSC_D3_DBMRRDR7           0xE679181CU
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* BOOT_INIT_DRAM_REGDEF_D3_H_*/
\ No newline at end of file
diff --git a/plat/renesas/rcar/ddr/D3/ddr_init_d3.c b/plat/renesas/rcar/ddr/D3/ddr_init_d3.c
new file mode 100644
index 00000000..0beae51c
--- /dev/null
+++ b/plat/renesas/rcar/ddr/D3/ddr_init_d3.c
@@ -0,0 +1,690 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Revision history
+ *
+ * rev.0.01    2017/05/26    New
+ */
+
+
+#include <stdint.h>
+// #include "mmio_v3m.h"
+#include "boot_init_dram_regdef_d3.h"
+
+
+#define RCAR_DDR_VERSION    "rev.0.01"
+
+static void    WriteReg_32(uint32_t a, uint32_t v)
+{
+	(*(volatile uint32_t*)(uintptr_t)a) = v;
+}
+
+static uint32_t ReadReg_32(uint32_t a)
+{
+	uint32_t w = (*(volatile uint32_t*)(uintptr_t)a);
+	return w;
+}
+
+uint32_t init_ddr_d31866(void)
+{
+
+	uint32_t RegVal_R2, RegVal_R3, RegVal_R5, RegVal_R6, RegVal_R7, RegVal_R12;
+
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00001234);
+   WriteReg_32(DBSC_D3_DBKIND,0x00000007);
+   WriteReg_32(DBSC_D3_DBMEMCONF00,0x0f030a01);
+   WriteReg_32(DBSC_D3_DBPHYCONF0,0x00000001);
+   WriteReg_32(DBSC_D3_DBTR0,0x0000000D);
+   WriteReg_32(DBSC_D3_DBTR1,0x00000009);
+   WriteReg_32(DBSC_D3_DBTR2,0x00000000);
+   WriteReg_32(DBSC_D3_DBTR3,0x0000000D);
+   WriteReg_32(DBSC_D3_DBTR4,0x000D000D);
+   WriteReg_32(DBSC_D3_DBTR5,0x0000002D);
+   WriteReg_32(DBSC_D3_DBTR6,0x00000020);
+   WriteReg_32(DBSC_D3_DBTR7,0x00060006);
+   WriteReg_32(DBSC_D3_DBTR8,0x00000021);
+   WriteReg_32(DBSC_D3_DBTR9,0x00000007);
+   WriteReg_32(DBSC_D3_DBTR10,0x0000000E);
+   WriteReg_32(DBSC_D3_DBTR11,0x0000000C);
+   WriteReg_32(DBSC_D3_DBTR12,0x00140014);
+   WriteReg_32(DBSC_D3_DBTR13,0x000000F2);
+   WriteReg_32(DBSC_D3_DBTR14,0x00170006);
+   WriteReg_32(DBSC_D3_DBTR15,0x00060005);
+   WriteReg_32(DBSC_D3_DBTR16,0x09210507);
+   WriteReg_32(DBSC_D3_DBTR17,0x040E0000);
+   WriteReg_32(DBSC_D3_DBTR18,0x00000200);
+   WriteReg_32(DBSC_D3_DBTR19,0x012B004B);
+   WriteReg_32(DBSC_D3_DBTR20,0x020000FB);
+   WriteReg_32(DBSC_D3_DBTR21,0x00040004);
+   WriteReg_32(DBSC_D3_DBBL,0x00000000);
+   WriteReg_32(DBSC_D3_DBODT0,0x00000001);
+   WriteReg_32(DBSC_D3_DBADJ0,0x00000001);
+   WriteReg_32(DBSC_D3_DBSYSCONF1,0x00000002);
+   WriteReg_32(DBSC_D3_DBDFICNT0,0x00000010);
+   WriteReg_32(DBSC_D3_DBBCAMDIS,0x00000001);
+   WriteReg_32(DBSC_D3_DBSCHRW1,0x00000046);
+   WriteReg_32(DBSC_D3_SCFCTST0,0x0D020D04);
+   WriteReg_32(DBSC_D3_SCFCTST1,0x0306040C);
+
+   WriteReg_32(DBSC_D3_DBPDLK0,0x0000A55A);
+   WriteReg_32(DBSC_D3_DBCMD,0x01000001);
+   WriteReg_32(DBSC_D3_DBCMD,0x08000000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x80010000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000008);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000B8000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058A04);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000091);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BB6B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000095);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BBAD);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000099);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BB6B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058A00);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000021);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0024641E);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010073);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0C058A00);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058A00);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000003);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0780C700);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000007);
+   while ( (BIT30 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000004);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0A206F89);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000022);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x1000040B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000023);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x35A00D77);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000024);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x2A8A2C28);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000025);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x30005E00);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000026);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0014CB49);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000027);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00000F14);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000028);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00000046);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000029);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000002C);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x81003047);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000020);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00181884);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000001A);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x33C03C10);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A7);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A8);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A9);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C7);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C8);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C9);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000D0D0D);
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000000E);
+   RegVal_R2 = ((ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8) >> 0x1;
+   RegVal_R3 = (RegVal_R2 << 16) + (RegVal_R2 << 8) + RegVal_R2;
+   RegVal_R6 = (RegVal_R2 << 24) + (RegVal_R2 << 16) + (RegVal_R2 << 8) + RegVal_R2;
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000011);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R3);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000012);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R3);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000016);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000017);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000018);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000019);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010181);
+   WriteReg_32(DBSC_D3_DBCMD,0x08000001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010601);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   for (uint32_t i = 0; i<2; i++)
+   {
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B1 + i*0x20);
+      RegVal_R5 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8;
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B4 + i*0x20);
+      RegVal_R6 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x000000FF);
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B3 + i*0x20);
+      RegVal_R7 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x00000007);
+      if ( RegVal_R6 > 0 )
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R7 + 0x1) & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | RegVal_R6);
+      } else 
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | RegVal_R7);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 + ((RegVal_R5) << 1)) & 0x000000FF));
+      }
+   }
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000005);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0xC1AA00C0);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010801);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000005);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0xC1AA00D8);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0001F001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000AF);
+   RegVal_R2 = ReadReg_32(DBSC_D3_DBPDRGD0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,(((RegVal_R2 + 0x1) & 0x000000FF) | (RegVal_R2 & 0xFFFFFF00)));
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000CF);
+   RegVal_R2 = ReadReg_32(DBSC_D3_DBPDRGD0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,(((RegVal_R2 + 0x1) & 0x000000FF) | (RegVal_R2 & 0xFFFFFF00)));
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C000285);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C000285);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000002C);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x81003087);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010401);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   for (uint32_t i = 0; i < 2; i++)
+   {
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B1 + i*0x20);
+      RegVal_R5 = ((ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8);
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B4 + i*0x20);
+      RegVal_R6 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x000000FF);
+
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B3 + i*0x20);
+      RegVal_R7 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x00000007);
+      RegVal_R12 = (RegVal_R5 >> 0x2);
+      if ( RegVal_R12 < RegVal_R6 )
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R7 + 0x1) & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 - (RegVal_R12)) & 0x000000FF));
+      }
+      else
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | (RegVal_R7 & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 + (RegVal_R5) + ((RegVal_R5) >> 1) + (RegVal_R12)) & 0x000000FF));
+      }
+   }
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00015001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000003);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0380C700);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000007);
+   while ( (BIT30 & ReadReg_32(DBSC_D3_DBPDRGD0)) != 0 );
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000021);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0024643E);
+
+   WriteReg_32(DBSC_D3_DBBUS0CNF1,0x00000010);
+   WriteReg_32(DBSC_D3_DBCALCNF,0x0100401B);
+   WriteReg_32(DBSC_D3_DBRFCNF1,0x00080E23);
+   WriteReg_32(DBSC_D3_DBRFCNF2,0x00010000);
+   WriteReg_32(DBSC_D3_DBDFICUPDCNF,0x40100001);
+   WriteReg_32(DBSC_D3_DBRFEN,0x00000001);
+   WriteReg_32(DBSC_D3_DBACEN,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDLK0,0x00000000);
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00000000);
+
+#ifdef ddr_qos_init_setting // only for non qos_init
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00001234);
+   WriteReg_32(DBSC_D3_DBCAM0CNF1,0x00043218);
+   WriteReg_32(DBSC_D3_DBCAM0CNF2,0x000000F4);
+   WriteReg_32(DBSC_D3_DBSCHCNT0,0x000f0037);
+   WriteReg_32(DBSC_D3_DBSCHSZ0,0x00000001);
+   WriteReg_32(DBSC_D3_DBSCHRW0,0x22421111);
+   WriteReg_32(DBSC_D3_SCFCTST2,0x012F1123);
+   WriteReg_32(DBSC_D3_DBSCHQOS00,0x00000F00);
+   WriteReg_32(DBSC_D3_DBSCHQOS01,0x00000B00);
+   WriteReg_32(DBSC_D3_DBSCHQOS02,0x00000000);
+   WriteReg_32(DBSC_D3_DBSCHQOS03,0x00000000);
+   WriteReg_32(DBSC_D3_DBSCHQOS40,0x00000300);
+   WriteReg_32(DBSC_D3_DBSCHQOS41,0x000002F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS42,0x00000200);
+   WriteReg_32(DBSC_D3_DBSCHQOS43,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS90,0x00000300);
+   WriteReg_32(DBSC_D3_DBSCHQOS91,0x000002F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS92,0x00000200);
+   WriteReg_32(DBSC_D3_DBSCHQOS93,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS130,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS131,0x000000F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS132,0x000000A0);
+   WriteReg_32(DBSC_D3_DBSCHQOS133,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS140,0x000000C0);
+   WriteReg_32(DBSC_D3_DBSCHQOS141,0x000000B0);
+   WriteReg_32(DBSC_D3_DBSCHQOS142,0x00000080);
+   WriteReg_32(DBSC_D3_DBSCHQOS143,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS150,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS151,0x00000030);
+   WriteReg_32(DBSC_D3_DBSCHQOS152,0x00000020);
+   WriteReg_32(DBSC_D3_DBSCHQOS153,0x00000010);
+   WriteReg_32(0xE67F0018,0x00000001);
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00000000);
+#endif
+
+   return 1;
+}
+
+uint32_t init_ddr_d31600(void)
+{
+
+	uint32_t RegVal_R2, RegVal_R3, RegVal_R5, RegVal_R6, RegVal_R7, RegVal_R12;
+
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00001234);
+   WriteReg_32(DBSC_D3_DBKIND,0x00000007);
+   WriteReg_32(DBSC_D3_DBMEMCONF00,0x0f030a01);
+   WriteReg_32(DBSC_D3_DBPHYCONF0,0x00000001);
+   WriteReg_32(DBSC_D3_DBTR0,0x0000000B);
+   WriteReg_32(DBSC_D3_DBTR1,0x00000008);
+   WriteReg_32(DBSC_D3_DBTR2,0x00000000);
+   WriteReg_32(DBSC_D3_DBTR3,0x0000000B);
+   WriteReg_32(DBSC_D3_DBTR4,0x000B000B);
+   WriteReg_32(DBSC_D3_DBTR5,0x00000027);
+   WriteReg_32(DBSC_D3_DBTR6,0x0000001C);
+   WriteReg_32(DBSC_D3_DBTR7,0x00060006);
+   WriteReg_32(DBSC_D3_DBTR8,0x00000020);
+   WriteReg_32(DBSC_D3_DBTR9,0x00000006);
+   WriteReg_32(DBSC_D3_DBTR10,0x0000000C);
+   WriteReg_32(DBSC_D3_DBTR11,0x0000000A);
+   WriteReg_32(DBSC_D3_DBTR12,0x00120012);
+   WriteReg_32(DBSC_D3_DBTR13,0x000000D0);
+   WriteReg_32(DBSC_D3_DBTR14,0x00140005);
+   WriteReg_32(DBSC_D3_DBTR15,0x00050004);
+   WriteReg_32(DBSC_D3_DBTR16,0x071F0305);
+   WriteReg_32(DBSC_D3_DBTR17,0x040C0000);
+   WriteReg_32(DBSC_D3_DBTR18,0x00000200);
+   WriteReg_32(DBSC_D3_DBTR19,0x01000040);
+   WriteReg_32(DBSC_D3_DBTR20,0x020000D8);
+   WriteReg_32(DBSC_D3_DBTR21,0x00040004);
+   WriteReg_32(DBSC_D3_DBBL,0x00000000);
+   WriteReg_32(DBSC_D3_DBODT0,0x00000001);
+   WriteReg_32(DBSC_D3_DBADJ0,0x00000001);
+   WriteReg_32(DBSC_D3_DBSYSCONF1,0x00000002);
+   WriteReg_32(DBSC_D3_DBDFICNT0,0x00000010);
+   WriteReg_32(DBSC_D3_DBBCAMDIS,0x00000001);
+   WriteReg_32(DBSC_D3_DBSCHRW1,0x00000046);
+   WriteReg_32(DBSC_D3_SCFCTST0,0x0D020C04);
+   WriteReg_32(DBSC_D3_SCFCTST1,0x0305040C);
+
+   WriteReg_32(DBSC_D3_DBPDLK0,0x0000A55A);
+   WriteReg_32(DBSC_D3_DBCMD,0x01000001);
+   WriteReg_32(DBSC_D3_DBCMD,0x08000000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x80010000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000008);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000B8000);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058904);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000091);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BB6B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000095);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BBAD);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000099);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0007BB6B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058900);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000021);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0024641E);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010073);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0C058900);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000090);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x04058900);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000003);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0780C700);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000007);
+   while ( (BIT30 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000004);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x08C05FF0);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000022);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x1000040B);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000023);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x2D9C0B66);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000024);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x2A88C400);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000025);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x30005200);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000026);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0014A9C9);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000027);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00000D70);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000028);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00000046);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000029);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00000098);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000002C);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x81003047);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000020);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00181884);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000001A);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x33C03C10);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A7);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A8);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A9);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C7);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C8);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0D0D0D0D);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C9);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x000D0D0D);
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000000E);
+   RegVal_R2 = ((ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8) >> 0x1;
+   RegVal_R3 = (RegVal_R2 << 16) + (RegVal_R2 << 8) + RegVal_R2;
+   RegVal_R6 = (RegVal_R2 << 24) + (RegVal_R2 << 16) + (RegVal_R2 << 8) + RegVal_R2;
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000011);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R3);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000012);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R3);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000016);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000017);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000018);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000019);
+   WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R6);
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010181);
+   WriteReg_32(DBSC_D3_DBCMD,0x08000001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010601);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   for (uint32_t i = 0; i<2; i++)
+   {
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B1 + i*0x20);
+      RegVal_R5 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8;
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B4 + i*0x20);
+      RegVal_R6 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x000000FF);
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B3 + i*0x20);
+      RegVal_R7 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x00000007);
+      if ( RegVal_R6 > 0 )
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R7 + 0x1) & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | RegVal_R6);
+      } else 
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | RegVal_R7);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 + ((RegVal_R5) << 1)) & 0x000000FF));
+      }
+   }
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000005);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0xC1AA00C0);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010801);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000005);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0xC1AA00D8);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0001F001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000AF);
+   RegVal_R2 = ReadReg_32(DBSC_D3_DBPDRGD0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,(((RegVal_R2 + 0x1) & 0x000000FF) | (RegVal_R2 & 0xFFFFFF00)));
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000CF);
+   RegVal_R2 = ReadReg_32(DBSC_D3_DBPDRGD0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,(((RegVal_R2 + 0x1) & 0x000000FF) | (RegVal_R2 & 0xFFFFFF00)));
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C000285);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C000285);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x0000002C);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x81003087);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00010401);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   for (uint32_t i = 0; i < 2; i++)
+   {
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B1 + i*0x20);
+      RegVal_R5 = ((ReadReg_32(DBSC_D3_DBPDRGD0) & 0x0000FF00) >> 0x8);
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B4 + i*0x20);
+      RegVal_R6 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x000000FF);
+
+      WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B3 + i*0x20);
+      RegVal_R7 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0x00000007);
+      RegVal_R12 = (RegVal_R5 >> 0x2);
+      if ( RegVal_R12 < RegVal_R6 )
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R7 + 0x1) & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 - (RegVal_R12)) & 0x000000FF));
+      }
+      else
+      {
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFFF8);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B2 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | (RegVal_R7 & 0x00000007));
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         RegVal_R2 = (ReadReg_32(DBSC_D3_DBPDRGD0) & 0xFFFFFF00);
+         WriteReg_32(DBSC_D3_DBPDRGA0,0x000000B0 + i*0x20);
+         WriteReg_32(DBSC_D3_DBPDRGD0,RegVal_R2 | ((RegVal_R6 + (RegVal_R5) + ((RegVal_R5) >> 1) + (RegVal_R12)) & 0x000000FF));
+      }
+   }
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000A0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x000000C0);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x7C0002C5);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x00015001);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000006);
+   while ( (BIT0 & ReadReg_32(DBSC_D3_DBPDRGD0)) == 0 );
+
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000003);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0380C700);
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000007);
+   while ( (BIT30 & ReadReg_32(DBSC_D3_DBPDRGD0)) != 0 );
+   WriteReg_32(DBSC_D3_DBPDRGA0,0x00000021);
+   WriteReg_32(DBSC_D3_DBPDRGD0,0x0024643E);
+
+   WriteReg_32(DBSC_D3_DBBUS0CNF1,0x00000010);
+   WriteReg_32(DBSC_D3_DBCALCNF,0x0100401B);
+   WriteReg_32(DBSC_D3_DBRFCNF1,0x00080C30);
+   WriteReg_32(DBSC_D3_DBRFCNF2,0x00010000);
+   WriteReg_32(DBSC_D3_DBDFICUPDCNF,0x40100001);
+   WriteReg_32(DBSC_D3_DBRFEN,0x00000001);
+   WriteReg_32(DBSC_D3_DBACEN,0x00000001);
+   WriteReg_32(DBSC_D3_DBPDLK0,0x00000000);
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00000000);
+
+#ifdef ddr_qos_init_setting // only for non qos_init
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00001234);
+   WriteReg_32(DBSC_D3_DBCAM0CNF1,0x00043218);
+   WriteReg_32(DBSC_D3_DBCAM0CNF2,0x000000F4);
+   WriteReg_32(DBSC_D3_DBSCHCNT0,0x000f0037);
+   WriteReg_32(DBSC_D3_DBSCHSZ0,0x00000001);
+   WriteReg_32(DBSC_D3_DBSCHRW0,0x22421111);
+   WriteReg_32(DBSC_D3_SCFCTST2,0x012F1123);
+   WriteReg_32(DBSC_D3_DBSCHQOS00,0x00000F00);
+   WriteReg_32(DBSC_D3_DBSCHQOS01,0x00000B00);
+   WriteReg_32(DBSC_D3_DBSCHQOS02,0x00000000);
+   WriteReg_32(DBSC_D3_DBSCHQOS03,0x00000000);
+   WriteReg_32(DBSC_D3_DBSCHQOS40,0x00000300);
+   WriteReg_32(DBSC_D3_DBSCHQOS41,0x000002F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS42,0x00000200);
+   WriteReg_32(DBSC_D3_DBSCHQOS43,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS90,0x00000300);
+   WriteReg_32(DBSC_D3_DBSCHQOS91,0x000002F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS92,0x00000200);
+   WriteReg_32(DBSC_D3_DBSCHQOS93,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS130,0x00000100);
+   WriteReg_32(DBSC_D3_DBSCHQOS131,0x000000F0);
+   WriteReg_32(DBSC_D3_DBSCHQOS132,0x000000A0);
+   WriteReg_32(DBSC_D3_DBSCHQOS133,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS140,0x000000C0);
+   WriteReg_32(DBSC_D3_DBSCHQOS141,0x000000B0);
+   WriteReg_32(DBSC_D3_DBSCHQOS142,0x00000080);
+   WriteReg_32(DBSC_D3_DBSCHQOS143,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS150,0x00000040);
+   WriteReg_32(DBSC_D3_DBSCHQOS151,0x00000030);
+   WriteReg_32(DBSC_D3_DBSCHQOS152,0x00000020);
+   WriteReg_32(DBSC_D3_DBSCHQOS153,0x00000010);
+   WriteReg_32(0xE67F0018,0x00000001);
+   WriteReg_32(DBSC_D3_DBSYSCNT0,0x00000000);
+#endif
+
+   return 1;
+}
diff --git a/plat/renesas/rcar/ddr/boot_init_dram.c b/plat/renesas/rcar/ddr/boot_init_dram.c
new file mode 100644
index 00000000..335a1c0b
--- /dev/null
+++ b/plat/renesas/rcar/ddr/boot_init_dram.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdint.h>
+#include <debug.h>
+#include <mmio.h>
+#include "boot_init_dram.h"
+#include "D3/boot_init_dram_d3.h"
+
+ /* Product Register */
+#define PRR			(0xFFF00044U)
+#define PRR_PRODUCT_MASK	(0x00007F00U)
+#define PRR_CUT_MASK		(0x000000FFU)
+#define PRR_PRODUCT_H3		(0x00004F00U)           /* R-Car H3 */
+#define PRR_PRODUCT_M3		(0x00005200U)           /* R-Car M3 */
+#define PRR_PRODUCT_D3		(0x00005800U)           /* R-Car D3 */
+#define PRR_PRODUCT_10		(0x00U)
+#define PRR_PRODUCT_11		(0x01U)
+
+#define	RST_MODEMR	(0xE6160060)
+#define	MODEMR_MD19		(0x00080000U)	/* MD19 bit mask */
+
+#define PRR_PRODUCT_ERR(reg)	do{\
+				ERROR("LSI Product ID(PRR=0x%x) DDR "\
+				"initialize not supported.\n",reg);\
+				panic();\
+				}while(0)
+#define PRR_CUT_ERR(reg)	do{\
+				ERROR("LSI Cut ID(PRR=0x%x) DDR "\
+				"initialize not supported.\n",reg);\
+				panic();\
+				}while(0)
+
+int32_t InitDram(void)
+{
+	uint32_t reg;
+	uint32_t ddr_mbps;
+	int32_t  ret = 0;
+
+	reg = mmio_read_32(PRR);
+#if RCAR_LSI == RCAR_D3	/* D3 */
+	if (PRR_PRODUCT_D3 != (reg & PRR_PRODUCT_MASK)) {
+		PRR_PRODUCT_ERR(reg);
+	}
+	reg = mmio_read_32(RST_MODEMR);
+	if(MODEMR_MD19 == (reg & MODEMR_MD19)){
+		ret = init_ddr_d31866();
+		ddr_mbps = 1866;
+	}
+	else{
+		ret = init_ddr_d31600();
+		ddr_mbps = 1600;
+	}
+	if(ret != 1){
+		ret = 1;
+	}
+	NOTICE("BL2: DDR%d\n", ddr_mbps);
+	
+#else
+  #error "Don't have DDR initialize routine."
+#endif
+	return 0;
+}
diff --git a/plat/renesas/rcar/ddr/boot_init_dram.h b/plat/renesas/rcar/ddr/boot_init_dram.h
index 9f08aac5..e0cac592 100644
--- a/plat/renesas/rcar/ddr/boot_init_dram.h
+++ b/plat/renesas/rcar/ddr/boot_init_dram.h
@@ -4,14 +4,9 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#ifndef	__BOOT_INIT_DRAM_
-#define	__BOOT_INIT_DRAM_
+#ifndef __BOOT_INIT_DRAM_H_
+#define __BOOT_INIT_DRAM_H_
 
 extern int32_t InitDram(void);
-#define INITDRAM_OK (0)
-#define INITDRAM_NG (0xffffffff)
-#define INITDRAM_ERR_I (0xffffffff)
-#define INITDRAM_ERR_O (0xfffffffe)
-#define INITDRAM_ERR_T (0xfffffff0)
 
-#endif /* __BOOT_INIT_DRAM_*/
+#endif /* __BOOT_INIT_DRAM_H_ */
diff --git a/plat/renesas/rcar/ddr/ddr.mk b/plat/renesas/rcar/ddr/ddr.mk
index adabc0bf..b83e01ce 100644
--- a/plat/renesas/rcar/ddr/ddr.mk
+++ b/plat/renesas/rcar/ddr/ddr.mk
@@ -4,10 +4,15 @@
 # SPDX-License-Identifier: BSD-3-Clause
 #
 
-ifeq (${RCAR_LSI},${RCAR_E3})
-    include plat/renesas/rcar/ddr/ddr_a/ddr_a.mk
+ifeq (${RCAR_LSI},${RCAR_D3})
+  BL2_SOURCES += plat/renesas/rcar/ddr/D3/ddr_init_d3.c
+  BL2_SOURCES += plat/renesas/rcar/ddr/boot_init_dram.c
 else
-    include plat/renesas/rcar/ddr/ddr_b/ddr_b.mk
-endif
+  ifeq (${RCAR_LSI},${RCAR_E3})
+      include plat/renesas/rcar/ddr/ddr_a/ddr_a.mk
+  else
+      include plat/renesas/rcar/ddr/ddr_b/ddr_b.mk
+  endif
 
-BL2_SOURCES += plat/renesas/rcar/ddr/dram_sub_func.c
+  BL2_SOURCES += plat/renesas/rcar/ddr/dram_sub_func.c
+endif
diff --git a/plat/renesas/rcar/ddr/ddr_b/boot_init_dram.c b/plat/renesas/rcar/ddr/ddr_b/boot_init_dram.c
index 4cee1173..f325cbd8 100644
--- a/plat/renesas/rcar/ddr/ddr_b/boot_init_dram.c
+++ b/plat/renesas/rcar/ddr/ddr_b/boot_init_dram.c
@@ -1,4015 +1,89 @@
 /*
  * Copyright (c) 2015-2018, Renesas Electronics Corporation. All rights reserved.
  *
- * SPDX-License-Identifier: BSD-3-Clause
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  */
-
 #include <stdint.h>
-#include <string.h>
-#include <stdio.h>
-#include <mmio.h>
 #include <debug.h>
-#include "ddr_regdef.h"
-#include "init_dram_tbl_h3.h"
-#include "init_dram_tbl_m3.h"
-#include "init_dram_tbl_h3ver2.h"
-#include "init_dram_tbl_m3n.h"
-#include "boot_init_dram_regdef.h"
+#include <mmio.h>
 #include "boot_init_dram.h"
-#include "dram_sub_func.h"
-#include "micro_wait.h"
-
-#define DDR_BACKUPMODE
-#define FATAL_MSG(x) NOTICE(x)
-
-/*******************************************************************************
- *	variables
- ******************************************************************************/
-#ifdef RCAR_DDR_FIXED_LSI_TYPE
-#ifndef RCAR_AUTO
-  #define RCAR_AUTO	99
-  #define RCAR_H3	0
-  #define RCAR_M3	1
-  #define RCAR_M3N	2
-  #define RCAR_E3	3	// NON
-  #define RCAR_H3N	4
-
-  #define RCAR_CUT_10	0
-  #define RCAR_CUT_11	1
-  #define RCAR_CUT_20	10
-  #define RCAR_CUT_30	20
-#endif
-#ifndef RCAR_LSI
-  #define RCAR_LSI	RCAR_AUTO
-#endif
-#if(RCAR_LSI==RCAR_AUTO)
-	static uint32_t Prr_Product;
-	static uint32_t Prr_Cut;
-#else
-  #if(RCAR_LSI==RCAR_H3)
-	static const uint32_t Prr_Product	= PRR_PRODUCT_H3;
-  #elif(RCAR_LSI==RCAR_M3)
-	static const uint32_t Prr_Product	= PRR_PRODUCT_M3;
-  #elif(RCAR_LSI==RCAR_M3N)
-	static const uint32_t Prr_Product	= PRR_PRODUCT_M3N;
-  #elif(RCAR_LSI==RCAR_H3N)
-	static const uint32_t Prr_Product	= PRR_PRODUCT_H3;
-  #endif//RCAR_LSI
-
-  #ifndef RCAR_LSI_CUT
-	static uint32_t Prr_Cut;
-  #else//RCAR_LSI_CUT
-    #if(RCAR_LSI_CUT==RCAR_CUT_10)
-	static const uint32_t Prr_Cut		= PRR_PRODUCT_10;
-    #elif(RCAR_LSI_CUT==RCAR_CUT_11)
-	static const uint32_t Prr_Cut		= PRR_PRODUCT_11;
-    #elif(RCAR_LSI_CUT==RCAR_CUT_20)
-	static const uint32_t Prr_Cut		= PRR_PRODUCT_20;
-    #elif(RCAR_LSI_CUT==RCAR_CUT_30)
-	static const uint32_t Prr_Cut		= PRR_PRODUCT_30;
-    #endif//RCAR_LSI_CUT
-  #endif//RCAR_LSI_CUT
-#endif//RCAR_AUTO_NON
-#else//RCAR_DDR_FIXED_LSI_TYPE
-	static uint32_t Prr_Product;
-	static uint32_t Prr_Cut;
-#endif//RCAR_DDR_FIXED_LSI_TYPE
-
-char *pRCAR_DDR_VERSION;
-uint32_t _cnf_BOARDTYPE;
-static uint32_t *pDDR_REGDEF_TBL;
-static uint32_t brd_clk;
-static uint32_t brd_clkdiv;
-static uint32_t brd_clkdiva;
-static uint32_t ddr_mbps;
-static uint32_t ddr_mbpsdiv;
-static uint32_t ddr_tccd;
-static struct _boardcnf *Boardcnf;
-uint32_t ddr_phyvalid;
-uint32_t ddr_density[DRAM_CH_CNT][CS_CNT];
-static uint32_t ch_have_this_cs[CS_CNT];
-static uint32_t rdqdm_dly[DRAM_CH_CNT][CS_CNT][SLICE_CNT*2][9];
-static uint32_t rdqdm_le[DRAM_CH_CNT][CS_CNT][SLICE_CNT*2][9];
-static uint32_t rdqdm_te[DRAM_CH_CNT][CS_CNT][SLICE_CNT*2][9];
-static uint32_t rdqdm_nw[DRAM_CH_CNT][CS_CNT][SLICE_CNT*2][9];
-static uint32_t rdqdm_win[DRAM_CH_CNT][CS_CNT][SLICE_CNT];
-static uint32_t rdqdm_st[DRAM_CH_CNT][CS_CNT][SLICE_CNT*2];
-
-static uint32_t wdqdm_le[DRAM_CH_CNT][CS_CNT][SLICE_CNT][9];
-static uint32_t wdqdm_te[DRAM_CH_CNT][CS_CNT][SLICE_CNT][9];
-static uint32_t wdqdm_dly[DRAM_CH_CNT][CS_CNT][SLICE_CNT][9];
-static uint32_t wdqdm_st[DRAM_CH_CNT][CS_CNT][SLICE_CNT];
-static uint32_t wdqdm_win[DRAM_CH_CNT][CS_CNT][SLICE_CNT];
-static uint32_t max_density;
-static uint32_t ddr0800_mul;
-static uint32_t ddr_mul;
-static uint32_t ddr_mbps;
-static uint32_t DDR_PHY_SLICE_REGSET_OFS;
-static uint32_t DDR_PHY_ADR_V_REGSET_OFS;
-static uint32_t DDR_PHY_ADR_I_REGSET_OFS;
-static uint32_t DDR_PHY_ADR_G_REGSET_OFS;
-static uint32_t DDR_PI_REGSET_OFS;
-static uint32_t DDR_PHY_SLICE_REGSET_SIZE;
-static uint32_t DDR_PHY_ADR_V_REGSET_SIZE;
-static uint32_t DDR_PHY_ADR_I_REGSET_SIZE;
-static uint32_t DDR_PHY_ADR_G_REGSET_SIZE;
-static uint32_t DDR_PI_REGSET_SIZE;
-static uint32_t DDR_PHY_SLICE_REGSET_NUM;
-static uint32_t DDR_PHY_ADR_V_REGSET_NUM;
-static uint32_t DDR_PHY_ADR_I_REGSET_NUM;
-static uint32_t DDR_PHY_ADR_G_REGSET_NUM;
-static uint32_t DDR_PI_REGSET_NUM;
-static uint32_t	DDR_PHY_ADR_I_NUM;
-#define DDR_PHY_REGSET_MAX 128
-#define DDR_PI_REGSET_MAX 320
-static uint32_t _cnf_DDR_PHY_SLICE_REGSET[DDR_PHY_REGSET_MAX];
-static uint32_t _cnf_DDR_PHY_ADR_V_REGSET[DDR_PHY_REGSET_MAX];
-static uint32_t _cnf_DDR_PHY_ADR_I_REGSET[DDR_PHY_REGSET_MAX];
-static uint32_t _cnf_DDR_PHY_ADR_G_REGSET[DDR_PHY_REGSET_MAX];
-static uint32_t _cnf_DDR_PI_REGSET[DDR_PI_REGSET_MAX];
-static uint32_t Pll3Mode;
-static uint32_t loop_max;
-#ifdef DDR_BACKUPMODE
-uint32_t ddrBackup;
-//#define DDR_BACKUPMODE_HALF		//for Half channel(ch0,1 only)
-#endif
-
-#ifdef ddr_qos_init_setting // only for non qos_init
-#define OPERATING_FREQ			(400U)		//Mhz
-#define BASE_SUB_SLOT_NUM		(0x6U)
-#define SUB_SLOT_CYCLE			(0x7EU)		//126
-#define QOSWT_WTSET0_CYCLE		((SUB_SLOT_CYCLE * BASE_SUB_SLOT_NUM * 1000U)/OPERATING_FREQ)	//unit:ns
-
-uint32_t get_refperiod(void)
-{
-	return QOSWT_WTSET0_CYCLE;
-}
-#else// ddr_qos_init_setting // only for non qos_init
-extern uint32_t get_refperiod(void);
-#endif//ddr_qos_init_setting // only for non qos_init
-
-#define _reg_PHY_RX_CAL_X_NUM 11
-static const uint32_t _reg_PHY_RX_CAL_X[_reg_PHY_RX_CAL_X_NUM] = {
-	_reg_PHY_RX_CAL_DQ0,
-	_reg_PHY_RX_CAL_DQ1,
-	_reg_PHY_RX_CAL_DQ2,
-	_reg_PHY_RX_CAL_DQ3,
-	_reg_PHY_RX_CAL_DQ4,
-	_reg_PHY_RX_CAL_DQ5,
-	_reg_PHY_RX_CAL_DQ6,
-	_reg_PHY_RX_CAL_DQ7,
-	_reg_PHY_RX_CAL_DM,
-	_reg_PHY_RX_CAL_DQS,
-	_reg_PHY_RX_CAL_FDBK
-};
-
-#define _reg_PHY_CLK_WRX_SLAVE_DELAY_NUM 10
-static const uint32_t _reg_PHY_CLK_WRX_SLAVE_DELAY[_reg_PHY_CLK_WRX_SLAVE_DELAY_NUM] = {
-	_reg_PHY_CLK_WRDQ0_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ1_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ2_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ3_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ4_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ5_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ6_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQ7_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDM_SLAVE_DELAY,
-	_reg_PHY_CLK_WRDQS_SLAVE_DELAY
-};
-
-#define _reg_PHY_RDDQS_X_FALL_SLAVE_DELAY_NUM 9
-static const uint32_t _reg_PHY_RDDQS_X_FALL_SLAVE_DELAY[_reg_PHY_RDDQS_X_FALL_SLAVE_DELAY_NUM] = {
-	_reg_PHY_RDDQS_DQ0_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ1_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ2_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ3_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ4_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ5_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ6_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ7_FALL_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DM_FALL_SLAVE_DELAY
-};
-
-#define _reg_PHY_RDDQS_X_RISE_SLAVE_DELAY_NUM 9
-static const uint32_t _reg_PHY_RDDQS_X_RISE_SLAVE_DELAY[_reg_PHY_RDDQS_X_RISE_SLAVE_DELAY_NUM] = {
-	_reg_PHY_RDDQS_DQ0_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ1_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ2_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ3_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ4_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ5_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ6_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DQ7_RISE_SLAVE_DELAY,
-	_reg_PHY_RDDQS_DM_RISE_SLAVE_DELAY
-};
-
-#define _reg_PHY_PAD_TERM_X_NUM 8
-static const uint32_t _reg_PHY_PAD_TERM_X[_reg_PHY_PAD_TERM_X_NUM] = {
-	_reg_PHY_PAD_FDBK_TERM,
-	_reg_PHY_PAD_DATA_TERM,
-	_reg_PHY_PAD_DQS_TERM,
-	_reg_PHY_PAD_ADDR_TERM,
-	_reg_PHY_PAD_CLK_TERM,
-	_reg_PHY_PAD_CKE_TERM,
-	_reg_PHY_PAD_RST_TERM,
-	_reg_PHY_PAD_CS_TERM
-};
-
-#define _reg_PHY_CLK_CACS_SLAVE_DELAY_X_NUM 10
-static const uint32_t _reg_PHY_CLK_CACS_SLAVE_DELAY_X[_reg_PHY_CLK_CACS_SLAVE_DELAY_X_NUM] = {
-	_reg_PHY_ADR0_CLK_WR_SLAVE_DELAY,
-	_reg_PHY_ADR1_CLK_WR_SLAVE_DELAY,
-	_reg_PHY_ADR2_CLK_WR_SLAVE_DELAY,
-	_reg_PHY_ADR3_CLK_WR_SLAVE_DELAY,
-	_reg_PHY_ADR4_CLK_WR_SLAVE_DELAY,
-	_reg_PHY_ADR5_CLK_WR_SLAVE_DELAY,
-
-	_reg_PHY_GRP_SLAVE_DELAY_0,
-	_reg_PHY_GRP_SLAVE_DELAY_1,
-	_reg_PHY_GRP_SLAVE_DELAY_2,
-	_reg_PHY_GRP_SLAVE_DELAY_3
-};
-
-/*******************************************************************************
- *	Prototypes
- ******************************************************************************/
-static inline int32_t vch_nxt(int32_t pos);
-static void cpg_write_32(uint32_t a, uint32_t v);
-static void pll3_control(uint32_t high);
-static inline void dsb_sev(void);
-static void wait_dbcmd(void);
-static void send_dbcmd(uint32_t cmd);
-static uint32_t reg_ddrphy_read ( uint32_t phyno, uint32_t regadd);
-static void reg_ddrphy_write ( uint32_t phyno, uint32_t regadd, uint32_t regdata);
-static void reg_ddrphy_write_a ( uint32_t regadd, uint32_t regdata);
-static inline uint32_t ddr_regdef ( uint32_t _regdef );
-static inline uint32_t ddr_regdef_adr ( uint32_t _regdef );
-static inline uint32_t ddr_regdef_lsb ( uint32_t _regdef );
-static void ddr_setval_s ( uint32_t ch, uint32_t slice, uint32_t _regdef, uint32_t val);
-static uint32_t ddr_getval_s ( uint32_t ch, uint32_t slice, uint32_t _regdef);
-static void ddr_setval(uint32_t ch, uint32_t regdef, uint32_t val);
-static void ddr_setval_ach_s(uint32_t slice, uint32_t regdef, uint32_t val);
-static void ddr_setval_ach(uint32_t regdef, uint32_t val);
-static void ddr_setval_ach_as(uint32_t regdef, uint32_t val);
-static uint32_t ddr_getval(uint32_t ch, uint32_t regdef);
-static uint32_t ddr_getval_ach(uint32_t regdef, uint32_t *p);
-/* NOT USED
-static uint32_t ddr_getval_ach_s(uint32_t slice, uint32_t regdef, uint32_t *p);
-*/
-static uint32_t ddr_getval_ach_as(uint32_t regdef, uint32_t *p);
-static void _tblcopy(uint32_t *to, const uint32_t *from, uint32_t size);
-static void ddrtbl_setval ( uint32_t *tbl, uint32_t _regdef, uint32_t val);
-static uint32_t ddrtbl_getval ( uint32_t *tbl, uint32_t _regdef);
-static uint32_t ddrphy_regif_chk(void);
-static inline void ddrphy_regif_idle();
-static uint16_t _f_scale(uint32_t ddr_mbps, uint32_t ddr_mbpsdiv, uint32_t ps, uint16_t cyc);
-static void _f_scale_js2(uint32_t ddr_mbps, uint32_t ddr_mbpsdiv, uint16_t *js2);
-static int16_t _f_scale_adj(int16_t ps);
-static void ddrtbl_load(void);
-static void ddr_config_sub(void);
-static void get_ca_swizzle( uint32_t ch, uint32_t ddr_csn, uint32_t *p_swz);
-static void ddr_config_sub_h3v1x(void);
-static void ddr_config(void);
-static void dbsc_regset(void);
-static void dbsc_regset_post(void);
-static uint32_t dfi_init_start(void);
-static void change_lpddr4_en(uint32_t mode);
-static uint32_t set_term_code(void);
-static void ddr_register_set(uint32_t ch);
-static inline uint32_t wait_freqchgreq(uint32_t assert);
-static inline void set_freqchgack(uint32_t assert);
-static inline void set_dfifrequency(uint32_t freq);
-static uint32_t pll3_freq(uint32_t on);
-static void update_dly(void);
-static uint32_t pi_training_go(void);
-static uint32_t init_ddr(void);
-static uint32_t swlvl1(uint32_t ddr_csn, uint32_t reg_cs, uint32_t reg_kick);
-static void wdqdm_clr1(uint32_t ch, uint32_t ddr_csn);
-static uint32_t wdqdm_ana1(uint32_t ch, uint32_t ddr_csn);
-static uint32_t wdqdm_man1(void);
-static uint32_t wdqdm_man(void);
-static void rdqdm_clr1(uint32_t ch, uint32_t ddr_csn);
-static uint32_t rdqdm_ana1(uint32_t ch, uint32_t ddr_csn);
-static uint32_t rdqdm_man1(void);
-static uint32_t rdqdm_man(void);
-
-static int32_t _find_change(uint64_t val, uint32_t dir);
-static uint32_t _rx_offset_cal_updn(uint32_t code);
-static uint32_t rx_offset_cal(void);
-static uint32_t rx_offset_cal_hw(void);
-static void adjust_rddqs_latency(void);
-static void adjust_wpath_latency(void);
-
-struct DdrtData {
-	int32_t  init_temp;	// Initial Temperature (do)
-	uint32_t init_cal[4];	// Initial io-code (4 is for H3)
-	uint32_t tcomp_cal[4];	// Temperature compensated io-code (4 is for H3)
-};
-struct DdrtData tcal;
-
-static void pvtcode_update(void);
-static void pvtcode_update2(void);
-static void ddr_padcal_tcompensate_getinit(uint32_t override);
-
-/*******************************************************************************
- *	load board configuration
- ******************************************************************************/
-#include "boot_init_dram_config.c"
-
-/*******************************************************************************
- *	macro for channel selection loop
- ******************************************************************************/
-static inline int32_t vch_nxt(int32_t pos)
-{
-	int32_t posn;
-
-	for(posn=pos;posn<DRAM_CH_CNT; posn++){
-		if(ddr_phyvalid & (1U<<posn))break;
-	}
-	return posn;
-}
-
-#define foreach_vch(ch) \
-for(ch=vch_nxt(0);ch<DRAM_CH_CNT;ch=vch_nxt(ch+1))
-
-#define foreach_ech(ch) \
-for(ch=0;ch<DRAM_CH_CNT;ch++)
-
-/*******************************************************************************
- *	Printing functions
- ******************************************************************************/
-#define MSG_LF(...)
-
-/*******************************************************************************
- *	clock settings, reset control
- ******************************************************************************/
-static void cpg_write_32(uint32_t a, uint32_t v)
-{
-	mmio_write_32(CPG_CPGWPR, ~v);
-	mmio_write_32(a, v);
-}
-
-static void pll3_control(uint32_t high)
-{
-	uint32_t dataL,dataDIV,dataMUL,tmpDIV;
-
-	/* PLL3 disable */
-	dataL = mmio_read_32(CPG_PLLECR);
-	dataL &= ~CPG_PLLECR_PLL3E_BIT;
-	cpg_write_32(CPG_PLLECR, dataL);
-	dsb_sev();
-	cpg_write_32(CPG_FRQCRD, 0x00030003);		/* PLL3 DIV resetting */
-	dsb_sev();
-
-	/* PLL3 enable */
-	dataL= CPG_ZB3CKCR_ZB3ST_BIT | mmio_read_32(CPG_ZB3CKCR);
-	cpg_write_32(CPG_ZB3CKCR, dataL);		/* zb3 clk stop */
-	dsb_sev();
-
-	/* PLL3 Restart */
-	dataL = mmio_read_32(CPG_PLLECR);
-	dataL |= CPG_PLLECR_PLL3E_BIT;
-	cpg_write_32(CPG_PLLECR, dataL);
-	dsb_sev();
-
-	do {
-		dataL=mmio_read_32(CPG_PLLECR);
-	} while( (dataL&CPG_PLLECR_PLL3ST_BIT)==0 );
-	dsb_sev();
-
-	if(high){
-		/* High frequency*/
-		tmpDIV  = (1000*ddr_mbpsdiv*brd_clkdiv*(brd_clkdiva+1))/(ddr_mul*brd_clk*ddr_mbpsdiv+1);
-		dataMUL = ((ddr_mul * (tmpDIV +1)-1) << 24)|(brd_clkdiva << 7);
-		if(tmpDIV){
-			dataDIV = tmpDIV +1;
-		} else {
-			dataDIV = 0;
-		}
-		Pll3Mode=1;
-		loop_max=2;
-	} else {
-		/* Low frequency*/
-		tmpDIV  = (1000*ddr_mbpsdiv*brd_clkdiv*(brd_clkdiva+1))/(ddr0800_mul*brd_clk*ddr_mbpsdiv+1);
-		dataMUL = ((ddr0800_mul * (tmpDIV +1)-1) << 24)|(brd_clkdiva << 7);
-		if(tmpDIV){
-			dataDIV = tmpDIV +1;
-		} else {
-			dataDIV = 0;
-		}
-		Pll3Mode=0;
-		loop_max=8;
-	}
-
-	dataL= (0xFF80FF80 & mmio_read_32(CPG_FRQCRD));
-	cpg_write_32(CPG_FRQCRD, dataL);		/* PLL3 DIV resetting */
-	dsb_sev();
-
-	dataL= CPG_FRQCRB_KICK_BIT | mmio_read_32(CPG_FRQCRB);
-	cpg_write_32(CPG_FRQCRB, dataL);		/* DIV SET KICK */
-	dsb_sev();
-
-	/* PLL3 FREQ */
-	cpg_write_32(CPG_PLL3CR, dataMUL);		/* Set PLL3 freq */
-	dsb_sev();
-
-	do {
-		dataL=mmio_read_32(CPG_PLLECR);
-	} while( (dataL&CPG_PLLECR_PLL3ST_BIT)==0 );
-	dsb_sev();
-
-	dataL= (dataDIV <<16) | dataDIV | (0xFF80FF80 & mmio_read_32(CPG_FRQCRD));
-	cpg_write_32(CPG_FRQCRD, dataL);		/* PLL3 DIV resetting */
-	dsb_sev();
-
-	dataL= CPG_FRQCRB_KICK_BIT | mmio_read_32(CPG_FRQCRB);
-	cpg_write_32(CPG_FRQCRB, dataL);		/* DIV SET KICK */
-	dsb_sev();
-
-	do {
-		dataL=mmio_read_32(CPG_PLLECR);
-	} while((dataL&CPG_PLLECR_PLL3ST_BIT)==0);
-	dsb_sev();
-
-	dataL= (~CPG_ZB3CKCR_ZB3ST_BIT) & mmio_read_32(CPG_ZB3CKCR);
-	cpg_write_32(CPG_ZB3CKCR, dataL);		/* zb3 clk start */
-	dsb_sev();
-
-	return;
-}
-
-/*******************************************************************************
- *	barrier
- ******************************************************************************/
-static inline void dsb_sev(void)
-{
-	__asm__ __volatile__ ("dsb sy");
-}
-
-/*******************************************************************************
- *	DDR memory register access
- ******************************************************************************/
-static void wait_dbcmd(void)
-{
-	uint32_t dataL;
-	/* dummy read */
-	dataL = mmio_read_32(DBSC_DBCMD);
-	dsb_sev();
-	while(1)
-	{
-		/* wait DBCMD 1=busy, 0=ready */
-		dataL = mmio_read_32(DBSC_DBWAIT);
-		dsb_sev();
-		if((dataL & 0x00000001) == 0x00)	break;
-	}
-}
-
-static void send_dbcmd(uint32_t cmd)
-{
-	/* dummy read */
-	wait_dbcmd();
-	mmio_write_32(DBSC_DBCMD, cmd);
-	dsb_sev();
-}
-
-/*******************************************************************************
- *	DDRPHY register access (raw)
- ******************************************************************************/
-static uint32_t reg_ddrphy_read ( uint32_t phyno, uint32_t regadd)
-{
-	uint32_t val;
-	uint32_t loop;
-
-	val = 0;
-	if ((PRR_PRODUCT_M3N!=Prr_Product)&&(PRR_PRODUCT_V3H!=Prr_Product)) {
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd);
-		dsb_sev();
-
-		while(mmio_read_32(DBSC_DBPDRGA(phyno)) != regadd){
-			dsb_sev();
-		}
-		dsb_sev();
-
-		for(loop=0;loop<loop_max;loop++){
-			val = mmio_read_32(DBSC_DBPDRGD(phyno));
-			dsb_sev();
-		}
-		(void)val;
-	}else{
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd|0x00004000);
-		dsb_sev();
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=(regadd|0x0000C000)){dsb_sev();};
-		val = mmio_read_32(DBSC_DBPDRGA(phyno));
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd|0x00008000);
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=regadd){dsb_sev();};
-		dsb_sev();
-
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd|0x00008000);
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=regadd){dsb_sev();};
-
-		dsb_sev();
-		val = mmio_read_32(DBSC_DBPDRGD(phyno));
-		dsb_sev();
-		(void)val;
-	}
-	return val;
-}
-
-static void reg_ddrphy_write ( uint32_t phyno, uint32_t regadd, uint32_t regdata)
-{
-	uint32_t val;
-	uint32_t loop;
-
-	if ((PRR_PRODUCT_M3N!=Prr_Product)&&(PRR_PRODUCT_V3H!=Prr_Product)) {
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd);
-		dsb_sev();
-		for(loop=0;loop<loop_max;loop++){
-			val = mmio_read_32(DBSC_DBPDRGA(phyno));
-			dsb_sev();
-		}
-		mmio_write_32(DBSC_DBPDRGD(phyno),regdata);
-		dsb_sev();
-
-		for(loop=0;loop<loop_max;loop++){
-			val = mmio_read_32(DBSC_DBPDRGD(phyno));
-			dsb_sev();
-		}
-	}else{
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd);
-		dsb_sev();
-
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=regadd){dsb_sev();};
-		dsb_sev();
-
-		mmio_write_32(DBSC_DBPDRGD(phyno),regdata);
-		dsb_sev();
-
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=(regadd|0x00008000)){dsb_sev();};
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd|0x00008000);
-
-		while(mmio_read_32(DBSC_DBPDRGA(phyno))!=regadd){dsb_sev();};
-		dsb_sev();
-
-		mmio_write_32(DBSC_DBPDRGA(phyno), regadd);
-	}
-	(void)val;
-}
-
-static void reg_ddrphy_write_a ( uint32_t regadd, uint32_t regdata)
-{
-	uint32_t ch;
-	uint32_t val;
-	uint32_t loop;
-
-	if ((PRR_PRODUCT_M3N!=Prr_Product)&&(PRR_PRODUCT_V3H!=Prr_Product)) {
-		foreach_vch(ch) {
-			mmio_write_32(DBSC_DBPDRGA(ch), regadd);
-			dsb_sev();
-		}
-
-		foreach_vch(ch) {
-			mmio_write_32(DBSC_DBPDRGD(ch),regdata);
-			dsb_sev();
-		}
-
-		for(loop=0;loop<loop_max;loop++){
-			val = mmio_read_32(DBSC_DBPDRGD(0));
-			dsb_sev();
-		}
-		(void)val;
-	}else{
-		foreach_vch(ch) {
-			reg_ddrphy_write ( ch, regadd, regdata);
-			dsb_sev();
-		}
-	}
-}
-
-static inline void ddrphy_regif_idle()
-{
-	uint32_t val;
-
-	val = reg_ddrphy_read(0,ddr_regdef_adr(_reg_PI_INT_STATUS));
-	dsb_sev();
-	(void)val;
-}
-
-/*******************************************************************************
- *	DDRPHY register access (field modify)
- ******************************************************************************/
-static inline uint32_t ddr_regdef ( uint32_t _regdef )
-{
-	return pDDR_REGDEF_TBL[_regdef];
-}
-
-static inline uint32_t ddr_regdef_adr ( uint32_t _regdef )
-{
-	return DDR_REGDEF_ADR(pDDR_REGDEF_TBL[_regdef]);
-}
-
-static inline uint32_t ddr_regdef_lsb ( uint32_t _regdef )
-{
-	return DDR_REGDEF_LSB(pDDR_REGDEF_TBL[_regdef]);
-}
-
-static inline uint32_t ddr_regdef_len ( uint32_t _regdef )
-{
-	return DDR_REGDEF_LEN(pDDR_REGDEF_TBL[_regdef]);
-}
-
-static void ddr_setval_s ( uint32_t ch, uint32_t slice, uint32_t _regdef, uint32_t val)
-{
-	uint32_t adr;
-	uint32_t lsb;
-	uint32_t len;
-	uint32_t msk;
-	uint32_t tmp;
-	uint32_t regdef;
-
-	regdef = ddr_regdef(_regdef);
-	adr = DDR_REGDEF_ADR(regdef)+0x80*slice;
-	len = DDR_REGDEF_LEN(regdef);
-	lsb = DDR_REGDEF_LSB(regdef);
-	if(len==0x20)
-		msk = 0xffffffff;
-	else
-		msk = ((1U<<len)-1)<<lsb;
-
-	tmp = reg_ddrphy_read(ch, adr);
-	tmp = (tmp & (~msk)) | ((val<<lsb) & msk);
-	reg_ddrphy_write(ch, adr, tmp);
-}
-
-static uint32_t ddr_getval_s ( uint32_t ch, uint32_t slice, uint32_t _regdef)
-{
-	uint32_t adr;
-	uint32_t lsb;
-	uint32_t len;
-	uint32_t msk;
-	uint32_t tmp;
-	uint32_t regdef;
-
-	regdef = ddr_regdef(_regdef);
-	adr = DDR_REGDEF_ADR(regdef)+0x80*slice;
-	len = DDR_REGDEF_LEN(regdef);
-	lsb = DDR_REGDEF_LSB(regdef);
-	if(len==0x20)
-		msk = 0xffffffff;
-	else
-		msk = ((1U<<len)-1);
-
-	tmp = reg_ddrphy_read(ch, adr);
-	tmp = (tmp >> lsb) & msk;
-
-	return tmp;
-}
-
-static void ddr_setval(uint32_t ch, uint32_t regdef, uint32_t val)
-{
-	ddr_setval_s(ch, 0, regdef, val);
-}
-
-static void ddr_setval_ach_s(uint32_t slice, uint32_t regdef, uint32_t val)
-{
-	uint32_t ch;
-
-	foreach_vch(ch)
-		ddr_setval_s(ch, slice, regdef, val);
-}
-
-static void ddr_setval_ach(uint32_t regdef, uint32_t val)
-{
-	ddr_setval_ach_s(0,regdef, val);
-}
-
-static void ddr_setval_ach_as(uint32_t regdef, uint32_t val)
-{
-	uint32_t slice;
-
-	for(slice=0;slice<SLICE_CNT;slice++)
-		ddr_setval_ach_s(slice, regdef, val);
-}
-
-static uint32_t ddr_getval(uint32_t ch, uint32_t regdef)
-{
-	return ddr_getval_s(ch, 0, regdef);
-}
-
-static uint32_t ddr_getval_ach(uint32_t regdef, uint32_t *p)
-{
-	uint32_t ch;
-
-	foreach_vch(ch)
-		p[ch] = ddr_getval_s(ch, 0, regdef);
-	return p[0];
-}
-/* NOT_USED
-static uint32_t ddr_getval_ach_s(uint32_t slice, uint32_t regdef, uint32_t *p)
-{
-	uint32_t ch;
-
-	foreach_vch(ch)
-		p[ch] = ddr_getval_s(ch, slice, regdef);
-	return p[0];
-}
-*/
-
-static uint32_t ddr_getval_ach_as(uint32_t regdef, uint32_t *p)
-{
-	uint32_t ch, slice;
-	uint32_t *pp;
+#include "D3/boot_init_dram_d3.h"
+
+ /* Product Register */
+#define PRR			(0xFFF00044U)
+#define PRR_PRODUCT_MASK	(0x00007F00U)
+#define PRR_CUT_MASK		(0x000000FFU)
+#define PRR_PRODUCT_H3		(0x00004F00U)           /* R-Car H3 */
+#define PRR_PRODUCT_M3		(0x00005200U)           /* R-Car M3 */
+#define PRR_PRODUCT_D3		(0x00005800U)           /* R-Car D3 */
+#define PRR_PRODUCT_10		(0x00U)
+#define PRR_PRODUCT_11		(0x01U)
+
+#define	RST_MODEMR	(0xE6160060)
+#define	MODEMR_MD19		(0x00080000U)	/* MD19 bit mask */
+
+#define PRR_PRODUCT_ERR(reg)	do{\
+				ERROR("LSI Product ID(PRR=0x%x) DDR "\
+				"initialize not supported.\n",reg);\
+				panic();\
+				}while(0)
+#define PRR_CUT_ERR(reg)	do{\
+				ERROR("LSI Cut ID(PRR=0x%x) DDR "\
+				"initialize not supported.\n",reg);\
+				panic();\
+				}while(0)
 
-	pp = p;
-	foreach_vch(ch)
-		for(slice=0; slice<SLICE_CNT; slice++)
-			*pp++ = ddr_getval_s(ch, slice, regdef);
-	return p[0];
-}
-
-/*******************************************************************************
- *	handling functions for setteing ddrphy value table
- ******************************************************************************/
-static void _tblcopy(uint32_t *to, const uint32_t *from, uint32_t size)
-{
-	uint32_t i;
-
-	for (i=0;i<size;i++) {
-		to[i] = from[i];
-	}
-}
-
-static void ddrtbl_setval ( uint32_t *tbl, uint32_t _regdef, uint32_t val)
+int32_t InitDram(void)
 {
-	uint32_t adr;
-	uint32_t lsb;
-	uint32_t len;
-	uint32_t msk;
-	uint32_t tmp;
-	uint32_t adrmsk;
-	uint32_t regdef;
+	uint32_t reg;
+	uint32_t ddr_mbps;
+	int32_t  ret = 0;
 
-	regdef = ddr_regdef(_regdef);
-	adr = DDR_REGDEF_ADR(regdef);
-	len = DDR_REGDEF_LEN(regdef);
-	lsb = DDR_REGDEF_LSB(regdef);
-	if(len==0x20)
-		msk = 0xffffffff;
-	else
-		msk = ((1U<<len)-1)<<lsb;
-
-	if(adr<0x400){
-		adrmsk = 0xff;
-	} else {
-		adrmsk = 0x7f;
+	reg = mmio_read_32(PRR);
+#if RCAR_LSI == RCAR_D3	/* D3 */
+	if (PRR_PRODUCT_D3 != (reg & PRR_PRODUCT_MASK)) {
+		PRR_PRODUCT_ERR(reg);
 	}
-
-	tmp = tbl[adr & adrmsk];
-	tmp = (tmp & (~msk)) | ((val<<lsb) & msk);
-	tbl[adr & adrmsk] = tmp;
-}
-
-static uint32_t ddrtbl_getval ( uint32_t *tbl, uint32_t _regdef)
-{
-	uint32_t adr;
-	uint32_t lsb;
-	uint32_t len;
-	uint32_t msk;
-	uint32_t tmp;
-	uint32_t adrmsk;
-	uint32_t regdef;
-
-	regdef = ddr_regdef(_regdef);
-	adr = DDR_REGDEF_ADR(regdef);
-	len = DDR_REGDEF_LEN(regdef);
-	lsb = DDR_REGDEF_LSB(regdef);
-	if(len==0x20)
-		msk = 0xffffffff;
-	else
-		msk = ((1U<<len)-1);
-
-	if(adr<0x400){
-		adrmsk = 0xff;
-	} else {
-		adrmsk = 0x7f;
+	reg = mmio_read_32(RST_MODEMR);
+	if(MODEMR_MD19 == (reg & MODEMR_MD19)){
+		ret = init_ddr_d31866();
+		ddr_mbps = 1866;
 	}
-
-	tmp = tbl[adr & adrmsk];
-	tmp = (tmp >> lsb) & msk;
-
-	return tmp;
-}
-
-/*******************************************************************************
- *	DDRPHY register access handling
- ******************************************************************************/
-static uint32_t ddrphy_regif_chk(void)
-{
-	uint32_t tmp_ach[DRAM_CH_CNT];
-	uint32_t ch;
-	uint32_t err;
-	uint32_t PI_VERSION_CODE;
-
-	if(((Prr_Product==PRR_PRODUCT_H3) && (Prr_Cut<=PRR_PRODUCT_11))
-	  ||(Prr_Product==PRR_PRODUCT_M3)) {
-		PI_VERSION_CODE=0x2041;		/* H3 Ver.1.x/M3-W */
-	} else {
-		PI_VERSION_CODE=0x2040;		/* H3 Ver.2.0 or later/M3-N/V3H */
+	else{
+		ret = init_ddr_d31600();
+		ddr_mbps = 1600;
 	}
-
-	ddr_getval_ach(_reg_PI_VERSION, (uint32_t *)tmp_ach);
-	err = 0;
-	foreach_vch(ch) {
-		if(PI_VERSION_CODE!=tmp_ach[ch])
-			err = 1;
+	if(ret != 1){
+		ret = 1;
 	}
-	return err;
-}
-
-/*******************************************************************************
- *	functions and parameters for timing setting
- ******************************************************************************/
-struct _jedec_spec1 {
-	uint16_t fx3;
-	uint8_t RLwoDBI;
-	uint8_t RLwDBI;
-	uint8_t WL;
-	uint8_t nWR;
-	uint8_t nRTP;
-	uint8_t MR1;
-	uint8_t MR2;
-};
-#define JS1_USABLEC_SPEC_LO 2
-#define JS1_USABLEC_SPEC_HI 5
-#define JS1_FREQ_TBL_NUM 8
-#define JS1_MR1(f) (0x04 | ((f)<<4))
-#define JS1_MR2(f) (0x00 | ((f)<<3) | (f))
-const struct _jedec_spec1 js1[JS1_FREQ_TBL_NUM] = {
-/*A	{  800,  6,  6,  4,  6 , 8, JS1_MR1(0), JS1_MR2(0) },   533.333Mbps*/
-/*A	{ 1600, 10, 12,  6, 10 , 8, JS1_MR1(1), JS1_MR2(1) },  1066.666Mbps*/
-/*A	{ 2400, 14, 16,  8, 16 , 8, JS1_MR1(2), JS1_MR2(2) },  1600.000Mbps*/
-/*B*/	{  800,  6,  6,  4,  6 , 8, JS1_MR1(0), JS1_MR2(0)|0x40 }, /*  533.333Mbps*/
-/*B*/	{ 1600, 10, 12,  8, 10 , 8, JS1_MR1(1), JS1_MR2(1)|0x40 }, /* 1066.666Mbps*/
-/*B*/	{ 2400, 14, 16, 12, 16 , 8, JS1_MR1(2), JS1_MR2(2)|0x40 }, /* 1600.000Mbps*/
-/*A*/	{ 3200, 20, 22, 10, 20 , 8, JS1_MR1(3), JS1_MR2(3) }, /* 2133.333Mbps*/
-/*A*/	{ 4000, 24, 28, 12, 24 ,10, JS1_MR1(4), JS1_MR2(4) }, /* 2666.666Mbps*/
-/*A*/	{ 4800, 28, 32, 14, 30 ,12, JS1_MR1(5), JS1_MR2(5) }, /* 3200.000Mbps*/
-/*A*/	{ 5600, 32, 36, 16, 34 ,14, JS1_MR1(6), JS1_MR2(6) }, /* 3733.333Mbps*/
-/*A*/	{ 6400, 36, 40, 18, 40 ,16, JS1_MR1(7), JS1_MR2(7) }  /* 4266.666Mbps*/
-};
-
-struct _jedec_spec2 {
-	uint16_t ps;
-	uint16_t cyc;
-};
-
-#define JS2_tSR 0
-#define JS2_tXP 1
-#define JS2_tRTP 2
-#define JS2_tRCD 3
-#define JS2_tRPpb 4
-#define JS2_tRPab 5
-#define JS2_tRAS 6
-#define JS2_tWR 7
-#define JS2_tWTR 8
-#define JS2_tRRD 9
-#define JS2_tPPD 10
-#define JS2_tFAW 11
-#define JS2_tDQSCK 12
-#define JS2_tCKEHCMD 13
-#define JS2_tCKELCMD 14
-#define JS2_tCKELPD 15
-#define JS2_tMRR 16
-#define JS2_tMRW 17
-#define JS2_tMRD 18
-#define JS2_tZQCALns 19
-#define JS2_tZQLAT 20
-#define JS2_tIEdly 21
-#define JS2_TBLCNT 22
-
-#define JS2_tRCpb (JS2_TBLCNT)
-#define JS2_tRCab (JS2_TBLCNT+1)
-#define JS2_tRFCpb (JS2_TBLCNT+2)
-#define JS2_tRFCab (JS2_TBLCNT+3)
-#define JS2_CNT (JS2_TBLCNT+4)
-
-#ifndef JS2_DERATE
-#define JS2_DERATE 0
+	NOTICE("BL2: DDR%d\n", ddr_mbps);
+	
+#else
+  #error "Don't have DDR initialize routine."
 #endif
-const struct _jedec_spec2 jedec_spec2[2][JS2_TBLCNT] = {
-	{
-/*tSR   */	{ 15000 , 3 },
-/*tXP   */	{  7500 , 3 },
-/*tRTP  */	{  7500 , 8 },
-/*tRCD  */	{ 18000 , 4 },
-/*tRPpb */	{ 18000 , 3 },
-/*tRPab */	{ 21000 , 3 },
-/*tRAS  */	{ 42000 , 3 },
-/*tWR   */	{ 18000 , 4 },
-/*tWTR  */	{ 10000 , 8 },
-/*tRRD  */	{ 10000 , 4 },
-/*tPPD  */	{     0 , 0 },
-/*tFAW  */	{ 40000 , 0 },
-/*tDQSCK*/	{  3500 , 0 },
-/*tCKEHCMD*/	{  7500 , 3 },
-/*tCKELCMD*/	{  7500 , 3 },
-/*tCKELPD*/	{  7500 , 3 },
-/*tMRR*/	{     0 , 8 },
-/*tMRW*/	{ 10000 ,10 },
-/*tMRD*/	{ 14000 ,10 },
-/*tZQCALns*/	{1000*10, 0 },
-/*tZQLAT*/	{ 30000 ,10 },
-/*tIEdly*/	{ 12500 , 0 }
-	},{
-/*tSR   */	{ 15000 , 3 },
-/*tXP   */	{  7500 , 3 },
-/*tRTP  */	{  7500 , 8 },
-/*tRCD  */	{ 19875 , 4 },
-/*tRPpb */	{ 19875 , 3 },
-/*tRPab */	{ 22875 , 3 },
-/*tRAS  */	{ 43875 , 3 },
-/*tWR   */	{ 18000 , 4 },
-/*tWTR  */	{ 10000 , 8 },
-/*tRRD  */	{ 11875 , 4 },
-/*tPPD  */	{     0 , 0 },
-/*tFAW  */	{ 40000 , 0 },
-/*tDQSCK*/	{  3600 , 0 },
-/*tCKEHCMD*/	{  7500 , 3 },
-/*tCKELCMD*/	{  7500 , 3 },
-/*tCKELPD*/	{  7500 , 3 },
-/*tMRR*/	{     0 , 8 },
-/*tMRW*/	{ 10000 ,10 },
-/*tMRD*/	{ 14000 ,10 },
-/*tZQCALns*/	{1000*10, 0 },
-/*tZQLAT*/	{ 30000 ,10 },
-/*tIEdly*/	{ 12500 , 0 }
-	}
-};
-
-/* pb, ab */
-const uint16_t jedec_spec2_tRFC_pb_ab[2][7] = {
-/*	4Gb, 6Gb, 8Gb,12Gb, 16Gb, 24Gb(non), 32Gb(non)	*/
-	{
-	 60,  90,  90, 140, 140, 280, 280
-	},
-	{
-	130, 180, 180, 280, 280, 560, 560
-	}
-};
-
-static uint32_t js1_ind;
-static uint16_t js2[JS2_CNT];
-static uint8_t RL;
-static uint8_t WL;
-
-static uint16_t _f_scale(uint32_t ddr_mbps, uint32_t ddr_mbpsdiv, uint32_t ps, uint16_t cyc)
-{
-	uint32_t tmp;
-	uint32_t div;
-
-	tmp = (((uint32_t)(ps)+9) / 10) * ddr_mbps;
-	div = tmp / (200000 * ddr_mbpsdiv);
-	if(tmp != (div * 200000 * ddr_mbpsdiv))
-		div = div + 1;
-
-	if(div>cyc)
-		return (uint16_t)div;
-	return cyc;
-}
-
-static void _f_scale_js2(uint32_t ddr_mbps, uint32_t ddr_mbpsdiv, uint16_t *js2)
-{
-	int i;
-
-	for(i=0;i<JS2_TBLCNT;i++) {
-		js2[i] = _f_scale(ddr_mbps, ddr_mbpsdiv,
-			1UL*jedec_spec2[JS2_DERATE][i].ps,
-			jedec_spec2[JS2_DERATE][i].cyc);
-	}
-
-	js2[JS2_tRCpb] = js2[JS2_tRAS] + js2[JS2_tRPpb];
-	js2[JS2_tRCab] = js2[JS2_tRAS] + js2[JS2_tRPab];
-}
-
-/* scaler for DELAY value */
-static int16_t _f_scale_adj(int16_t ps)
-{
-	int32_t tmp;
-	/*
-	tmp = (int32_t)512 * ps * ddr_mbps /2 / ddr_mbpsdiv / 1000 / 1000;
-		= ps * ddr_mbps /2 / ddr_mbpsdiv *512 / 8 / 8 / 125 / 125
-		= ps * ddr_mbps / ddr_mbpsdiv *4 / 125 / 125
-	*/
-	tmp = (int32_t)4 * (int32_t)ps * (int32_t)ddr_mbps / (int32_t)ddr_mbpsdiv;
-	tmp = (int32_t)tmp / (int32_t)15625;
-
-	return (int16_t)tmp;
-}
-
-const uint32_t _reg_PI_MR1_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR1_DATA_F0_0,
-		_reg_PI_MR1_DATA_F0_1,
-		_reg_PI_MR1_DATA_F0_2,
-		_reg_PI_MR1_DATA_F0_3
-	},
-	{
-		_reg_PI_MR1_DATA_F1_0,
-		_reg_PI_MR1_DATA_F1_1,
-		_reg_PI_MR1_DATA_F1_2,
-		_reg_PI_MR1_DATA_F1_3
-	}
-};
-
-const uint32_t _reg_PI_MR2_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR2_DATA_F0_0,
-		_reg_PI_MR2_DATA_F0_1,
-		_reg_PI_MR2_DATA_F0_2,
-		_reg_PI_MR2_DATA_F0_3
-	},
-	{
-		_reg_PI_MR2_DATA_F1_0,
-		_reg_PI_MR2_DATA_F1_1,
-		_reg_PI_MR2_DATA_F1_2,
-		_reg_PI_MR2_DATA_F1_3
-	}
-};
-
-const uint32_t _reg_PI_MR3_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR3_DATA_F0_0,
-		_reg_PI_MR3_DATA_F0_1,
-		_reg_PI_MR3_DATA_F0_2,
-		_reg_PI_MR3_DATA_F0_3
-	},
-	{
-		_reg_PI_MR3_DATA_F1_0,
-		_reg_PI_MR3_DATA_F1_1,
-		_reg_PI_MR3_DATA_F1_2,
-		_reg_PI_MR3_DATA_F1_3
-	}
-};
-
-const uint32_t _reg_PI_MR11_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR11_DATA_F0_0,
-		_reg_PI_MR11_DATA_F0_1,
-		_reg_PI_MR11_DATA_F0_2,
-		_reg_PI_MR11_DATA_F0_3
-	},
-	{
-		_reg_PI_MR11_DATA_F1_0,
-		_reg_PI_MR11_DATA_F1_1,
-		_reg_PI_MR11_DATA_F1_2,
-		_reg_PI_MR11_DATA_F1_3
-	}
-};
-
-const uint32_t _reg_PI_MR12_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR12_DATA_F0_0,
-		_reg_PI_MR12_DATA_F0_1,
-		_reg_PI_MR12_DATA_F0_2,
-		_reg_PI_MR12_DATA_F0_3
-	},
-	{
-		_reg_PI_MR12_DATA_F1_0,
-		_reg_PI_MR12_DATA_F1_1,
-		_reg_PI_MR12_DATA_F1_2,
-		_reg_PI_MR12_DATA_F1_3
-	}
-};
-
-const uint32_t _reg_PI_MR14_DATA_Fx_CSx[2][CSAB_CNT] = {
-	{
-		_reg_PI_MR14_DATA_F0_0,
-		_reg_PI_MR14_DATA_F0_1,
-		_reg_PI_MR14_DATA_F0_2,
-		_reg_PI_MR14_DATA_F0_3
-	},
-	{
-		_reg_PI_MR14_DATA_F1_0,
-		_reg_PI_MR14_DATA_F1_1,
-		_reg_PI_MR14_DATA_F1_2,
-		_reg_PI_MR14_DATA_F1_3
-	}
-};
-
-/*******************************************************************************
- * regif pll w/a   ( REGIF H3 Ver.2.0 or later/M3-N/V3H WA )
- *******************************************************************************/
-static void regif_pll_wa(void)
-{
-	uint32_t ch;
-
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_PLL_WAIT), (0x0064U<<ddr_regdef_lsb(_reg_PHY_PLL_WAIT)));
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_PLL_CTRL),
-			 ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PLL_CTRL));
-
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_LP4_BOOT_PLL_CTRL),
-			 ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_LP4_BOOT_PLL_CTRL));
-
-	} else {
-		// PLL setting for PHY : M3-W/M3-N/V3H/H3 Ver.2.0 or later
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_PLL_WAIT), (0x5064U<<ddr_regdef_lsb(_reg_PHY_PLL_WAIT)));
-
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_PLL_CTRL),
-			(ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PLL_CTRL_TOP)<<16)|
-			 ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PLL_CTRL));
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_PLL_CTRL_CA),
-			ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PLL_CTRL_CA));
-
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_LP4_BOOT_PLL_CTRL),
-			(ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_LP4_BOOT_PLL_CTRL_CA)<<16)|
-			 ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_LP4_BOOT_PLL_CTRL));
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_LP4_BOOT_TOP_PLL_CTRL),
-			ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_LP4_BOOT_TOP_PLL_CTRL));
-	}
-
-	/* protect register interface */
-	ddrphy_regif_idle();
-	pll3_control(0);
-
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		// non
-	} else {
-		reg_ddrphy_write_a(ddr_regdef_adr(_reg_PHY_DLL_RST_EN), (0x01U<<ddr_regdef_lsb(_reg_PHY_DLL_RST_EN)));
-		ddrphy_regif_idle();
-	}
-
-	/***********************************************************************
-	init start
-	***********************************************************************/
-	/* dbdficnt0:
-	 * dfi_dram_clk_disable=1
-	 * dfi_frequency = 0
-	 * freq_ratio = 01 (2:1)
-	 * init_start =0
-	 */
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBDFICNT(ch), 0x00000F10);
-	dsb_sev();
-
-	/* dbdficnt0:
-	 * dfi_dram_clk_disable=1
-	 * dfi_frequency = 0
-	 * freq_ratio = 01 (2:1)
-	 * init_start =1
-	 */
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBDFICNT(ch), 0x00000F11);
-	dsb_sev();
-
-	foreach_ech(ch)
-		if(((Boardcnf->phyvalid) & (1U<<ch)))
-			while ((mmio_read_32(DBSC_PLL_LOCK(ch))&0x1f)!=0x1f);
-	dsb_sev();
+	return 0;
 }
-
-/*******************************************************************************
- *	load table data into DDR registers
- ******************************************************************************/
-static void ddrtbl_load(void)
-{
-	int i;
-	uint32_t slice;
-	uint32_t csab;
-	uint32_t adr;
-	uint32_t dataL;
-	uint32_t tmp[3];
-	uint16_t dataS;
-
-	/***********************************************************************
-	TIMING REGISTERS
-	***********************************************************************/
-	/* search jedec_spec1 index */
-	for(i=JS1_USABLEC_SPEC_LO;i<JS1_FREQ_TBL_NUM-1;i++) {
-		if(js1[i].fx3 * 2 * ddr_mbpsdiv >= ddr_mbps*3)
-			break;
-	}
-	if(JS1_USABLEC_SPEC_HI<i)
-		js1_ind = JS1_USABLEC_SPEC_HI;
-	else
-		js1_ind = i;
-
-	if(Boardcnf->dbi_en)
-		RL = js1[js1_ind].RLwDBI;
-	else
-		RL = js1[js1_ind].RLwoDBI;
-
-	WL = js1[js1_ind].WL;
-
-	/* calculate jedec_spec2 */
-	_f_scale_js2(ddr_mbps, ddr_mbpsdiv, js2);
-
-	/***********************************************************************
-	PREPARE TBL
-	***********************************************************************/
-	if (Prr_Product==PRR_PRODUCT_H3) {
-		if (Prr_Cut<=PRR_PRODUCT_11) {
-		// H3 Ver.1.x
-			_tblcopy(_cnf_DDR_PHY_SLICE_REGSET,
-				DDR_PHY_SLICE_REGSET_H3, DDR_PHY_SLICE_REGSET_NUM_H3);
-			_tblcopy(_cnf_DDR_PHY_ADR_V_REGSET,
-				DDR_PHY_ADR_V_REGSET_H3, DDR_PHY_ADR_V_REGSET_NUM_H3);
-			_tblcopy(_cnf_DDR_PHY_ADR_I_REGSET,
-				DDR_PHY_ADR_I_REGSET_H3, DDR_PHY_ADR_I_REGSET_NUM_H3);
-			_tblcopy(_cnf_DDR_PHY_ADR_G_REGSET,
-				DDR_PHY_ADR_G_REGSET_H3, DDR_PHY_ADR_G_REGSET_NUM_H3);
-			_tblcopy(_cnf_DDR_PI_REGSET,
-				DDR_PI_REGSET_H3, DDR_PI_REGSET_NUM_H3);
-
-			DDR_PHY_SLICE_REGSET_OFS = DDR_PHY_SLICE_REGSET_OFS_H3;
-			DDR_PHY_ADR_V_REGSET_OFS = DDR_PHY_ADR_V_REGSET_OFS_H3;
-			DDR_PHY_ADR_I_REGSET_OFS = DDR_PHY_ADR_I_REGSET_OFS_H3;
-			DDR_PHY_ADR_G_REGSET_OFS = DDR_PHY_ADR_G_REGSET_OFS_H3;
-			DDR_PI_REGSET_OFS = DDR_PI_REGSET_OFS_H3;
-			DDR_PHY_SLICE_REGSET_SIZE = DDR_PHY_SLICE_REGSET_SIZE_H3;
-			DDR_PHY_ADR_V_REGSET_SIZE = DDR_PHY_ADR_V_REGSET_SIZE_H3;
-			DDR_PHY_ADR_I_REGSET_SIZE = DDR_PHY_ADR_I_REGSET_SIZE_H3;
-			DDR_PHY_ADR_G_REGSET_SIZE = DDR_PHY_ADR_G_REGSET_SIZE_H3;
-			DDR_PI_REGSET_SIZE = DDR_PI_REGSET_SIZE_H3;
-			DDR_PHY_SLICE_REGSET_NUM = DDR_PHY_SLICE_REGSET_NUM_H3;
-			DDR_PHY_ADR_V_REGSET_NUM = DDR_PHY_ADR_V_REGSET_NUM_H3;
-			DDR_PHY_ADR_I_REGSET_NUM = DDR_PHY_ADR_I_REGSET_NUM_H3;
-			DDR_PHY_ADR_G_REGSET_NUM = DDR_PHY_ADR_G_REGSET_NUM_H3;
-			DDR_PI_REGSET_NUM = DDR_PI_REGSET_NUM_H3;
-
-			DDR_PHY_ADR_I_NUM=1;
-		} else {
-		// H3 Ver.2.0 or later
-			_tblcopy(_cnf_DDR_PHY_SLICE_REGSET,
-				DDR_PHY_SLICE_REGSET_H3VER2, DDR_PHY_SLICE_REGSET_NUM_H3VER2);
-			_tblcopy(_cnf_DDR_PHY_ADR_V_REGSET,
-				DDR_PHY_ADR_V_REGSET_H3VER2, DDR_PHY_ADR_V_REGSET_NUM_H3VER2);
-			_tblcopy(_cnf_DDR_PHY_ADR_G_REGSET,
-				DDR_PHY_ADR_G_REGSET_H3VER2, DDR_PHY_ADR_G_REGSET_NUM_H3VER2);
-			_tblcopy(_cnf_DDR_PI_REGSET,
-				DDR_PI_REGSET_H3VER2, DDR_PI_REGSET_NUM_H3VER2);
-
-			DDR_PHY_SLICE_REGSET_OFS = DDR_PHY_SLICE_REGSET_OFS_H3VER2;
-			DDR_PHY_ADR_V_REGSET_OFS = DDR_PHY_ADR_V_REGSET_OFS_H3VER2;
-			DDR_PHY_ADR_G_REGSET_OFS = DDR_PHY_ADR_G_REGSET_OFS_H3VER2;
-			DDR_PI_REGSET_OFS = DDR_PI_REGSET_OFS_H3VER2;
-			DDR_PHY_SLICE_REGSET_SIZE = DDR_PHY_SLICE_REGSET_SIZE_H3VER2;
-			DDR_PHY_ADR_V_REGSET_SIZE = DDR_PHY_ADR_V_REGSET_SIZE_H3VER2;
-			DDR_PHY_ADR_G_REGSET_SIZE = DDR_PHY_ADR_G_REGSET_SIZE_H3VER2;
-			DDR_PI_REGSET_SIZE = DDR_PI_REGSET_SIZE_H3VER2;
-			DDR_PHY_SLICE_REGSET_NUM = DDR_PHY_SLICE_REGSET_NUM_H3VER2;
-			DDR_PHY_ADR_V_REGSET_NUM = DDR_PHY_ADR_V_REGSET_NUM_H3VER2;
-			DDR_PHY_ADR_G_REGSET_NUM = DDR_PHY_ADR_G_REGSET_NUM_H3VER2;
-			DDR_PI_REGSET_NUM = DDR_PI_REGSET_NUM_H3VER2;
-
-			DDR_PHY_ADR_I_NUM=0;
-		}
-	} else if (Prr_Product==PRR_PRODUCT_M3) {
-	// M3-W
-		_tblcopy(_cnf_DDR_PHY_SLICE_REGSET,
-			DDR_PHY_SLICE_REGSET_M3, DDR_PHY_SLICE_REGSET_NUM_M3);
-		_tblcopy(_cnf_DDR_PHY_ADR_V_REGSET,
-			DDR_PHY_ADR_V_REGSET_M3, DDR_PHY_ADR_V_REGSET_NUM_M3);
-		_tblcopy(_cnf_DDR_PHY_ADR_I_REGSET,
-			DDR_PHY_ADR_I_REGSET_M3, DDR_PHY_ADR_I_REGSET_NUM_M3);
-		_tblcopy(_cnf_DDR_PHY_ADR_G_REGSET,
-			DDR_PHY_ADR_G_REGSET_M3, DDR_PHY_ADR_G_REGSET_NUM_M3);
-		_tblcopy(_cnf_DDR_PI_REGSET,
-			DDR_PI_REGSET_M3, DDR_PI_REGSET_NUM_M3);
-
-		DDR_PHY_SLICE_REGSET_OFS = DDR_PHY_SLICE_REGSET_OFS_M3;
-		DDR_PHY_ADR_V_REGSET_OFS = DDR_PHY_ADR_V_REGSET_OFS_M3;
-		DDR_PHY_ADR_I_REGSET_OFS = DDR_PHY_ADR_I_REGSET_OFS_M3;
-		DDR_PHY_ADR_G_REGSET_OFS = DDR_PHY_ADR_G_REGSET_OFS_M3;
-		DDR_PI_REGSET_OFS = DDR_PI_REGSET_OFS_M3;
-		DDR_PHY_SLICE_REGSET_SIZE = DDR_PHY_SLICE_REGSET_SIZE_M3;
-		DDR_PHY_ADR_V_REGSET_SIZE = DDR_PHY_ADR_V_REGSET_SIZE_M3;
-		DDR_PHY_ADR_I_REGSET_SIZE = DDR_PHY_ADR_I_REGSET_SIZE_M3;
-		DDR_PHY_ADR_G_REGSET_SIZE = DDR_PHY_ADR_G_REGSET_SIZE_M3;
-		DDR_PI_REGSET_SIZE = DDR_PI_REGSET_SIZE_M3;
-		DDR_PHY_SLICE_REGSET_NUM = DDR_PHY_SLICE_REGSET_NUM_M3;
-		DDR_PHY_ADR_V_REGSET_NUM = DDR_PHY_ADR_V_REGSET_NUM_M3;
-		DDR_PHY_ADR_I_REGSET_NUM = DDR_PHY_ADR_I_REGSET_NUM_M3;
-		DDR_PHY_ADR_G_REGSET_NUM = DDR_PHY_ADR_G_REGSET_NUM_M3;
-		DDR_PI_REGSET_NUM = DDR_PI_REGSET_NUM_M3;
-
-		DDR_PHY_ADR_I_NUM=2;
-	} else {
-	// M3-N/V3H
-		_tblcopy(_cnf_DDR_PHY_SLICE_REGSET,
-			DDR_PHY_SLICE_REGSET_M3N, DDR_PHY_SLICE_REGSET_NUM_M3N);
-		_tblcopy(_cnf_DDR_PHY_ADR_V_REGSET,
-			DDR_PHY_ADR_V_REGSET_M3N, DDR_PHY_ADR_V_REGSET_NUM_M3N);
-		_tblcopy(_cnf_DDR_PHY_ADR_I_REGSET,
-			DDR_PHY_ADR_I_REGSET_M3N, DDR_PHY_ADR_I_REGSET_NUM_M3N);
-		_tblcopy(_cnf_DDR_PHY_ADR_G_REGSET,
-			DDR_PHY_ADR_G_REGSET_M3N, DDR_PHY_ADR_G_REGSET_NUM_M3N);
-		_tblcopy(_cnf_DDR_PI_REGSET,
-			DDR_PI_REGSET_M3N, DDR_PI_REGSET_NUM_M3N);
-
-		DDR_PHY_SLICE_REGSET_OFS = DDR_PHY_SLICE_REGSET_OFS_M3N;
-		DDR_PHY_ADR_V_REGSET_OFS = DDR_PHY_ADR_V_REGSET_OFS_M3N;
-		DDR_PHY_ADR_I_REGSET_OFS = DDR_PHY_ADR_I_REGSET_OFS_M3N;
-		DDR_PHY_ADR_G_REGSET_OFS = DDR_PHY_ADR_G_REGSET_OFS_M3N;
-		DDR_PI_REGSET_OFS = DDR_PI_REGSET_OFS_M3N;
-		DDR_PHY_SLICE_REGSET_SIZE = DDR_PHY_SLICE_REGSET_SIZE_M3N;
-		DDR_PHY_ADR_V_REGSET_SIZE = DDR_PHY_ADR_V_REGSET_SIZE_M3N;
-		DDR_PHY_ADR_I_REGSET_SIZE = DDR_PHY_ADR_I_REGSET_SIZE_M3N;
-		DDR_PHY_ADR_G_REGSET_SIZE = DDR_PHY_ADR_G_REGSET_SIZE_M3N;
-		DDR_PI_REGSET_SIZE = DDR_PI_REGSET_SIZE_M3N;
-		DDR_PHY_SLICE_REGSET_NUM = DDR_PHY_SLICE_REGSET_NUM_M3N;
-		DDR_PHY_ADR_V_REGSET_NUM = DDR_PHY_ADR_V_REGSET_NUM_M3N;
-		DDR_PHY_ADR_I_REGSET_NUM = DDR_PHY_ADR_I_REGSET_NUM_M3N;
-		DDR_PHY_ADR_G_REGSET_NUM = DDR_PHY_ADR_G_REGSET_NUM_M3N;
-		DDR_PI_REGSET_NUM = DDR_PI_REGSET_NUM_M3N;
-
-		DDR_PHY_ADR_I_NUM=2;
-	}
-
-	/***********************************************************************
-	PLL CODE CHANGE
-	***********************************************************************/
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut==PRR_PRODUCT_11)){
-		ddrtbl_setval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PLL_CTRL, 0x1142);
-		ddrtbl_setval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_LP4_BOOT_PLL_CTRL, 0x1142);
-	}
-
-	/***********************************************************************
-	on fly gate adjust
-	***********************************************************************/
-	if ((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut==PRR_PRODUCT_10)) {
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_ON_FLY_GATE_ADJUST_EN, 0x00);
-	}
-
-	/***********************************************************************
-	Adjust PI paramters
-	***********************************************************************/
-#ifdef _def_LPDDR4_ODT
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F0_0, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F0_1, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F0_2, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F0_3, _def_LPDDR4_ODT);
-
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F1_0, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F1_1, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F1_2, _def_LPDDR4_ODT);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_F1_3, _def_LPDDR4_ODT);
-#endif//_def_LPDDR4_ODT
-
-#ifdef _def_LPDDR4_VREFCA
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F0_0, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F0_1, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F0_2, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F0_3, _def_LPDDR4_VREFCA);
-
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F1_0, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F1_1, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F1_2, _def_LPDDR4_VREFCA);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_F1_3, _def_LPDDR4_VREFCA);
-#endif//_def_LPDDR4_VREFCA
-	if((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		js2[JS2_tIEdly] = _f_scale(ddr_mbps, ddr_mbpsdiv, 7000,0) +7;
-		if(js2[JS2_tIEdly]>(RL)) js2[JS2_tIEdly]=RL;
-	} else if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut> PRR_PRODUCT_11)){
-		js2[JS2_tIEdly] = _f_scale(ddr_mbps, ddr_mbpsdiv, 9000,0) +4;
-	} else if((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut<=PRR_PRODUCT_11)){
-		js2[JS2_tIEdly] = _f_scale(ddr_mbps, ddr_mbpsdiv, 10000,0);
-	}
-
-	if(((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-	  ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		if((js2[JS2_tIEdly])>=0x1e)
-			dataS = 0x1e;
-		else	dataS = js2[JS2_tIEdly] ;
-	} else {
-		if((js2[JS2_tIEdly])>=0x0e)
-			dataS = 0x0e;
-		else	dataS = js2[JS2_tIEdly];
-	}
-
-	ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_RDDATA_EN_DLY, dataS);
-	ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_RDDATA_EN_TSEL_DLY, (dataS-2));
-	if ((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_RDDATA_EN_OE_DLY, dataS);
-	}
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_RDLAT_ADJ_F1, RL-dataS);
-
-	if(ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_WRITE_PATH_LAT_ADD)){
-		dataL = WL - 1;
-	} else {
-		dataL = WL;
-	}
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_WRLAT_ADJ_F1, dataL-2);
-	ddrtbl_setval(_cnf_DDR_PI_REGSET, _reg_PI_WRLAT_F1, dataL);
-
-	if(Boardcnf->dbi_en) {
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_DBI_MODE, 0x01);
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_WDQLVL_DATADM_MASK, 0x000);
-	} else {
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_DBI_MODE, 0x00);
-		ddrtbl_setval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_WDQLVL_DATADM_MASK, 0x100);
-	}
-
-	tmp[0] = js1[js1_ind].MR1;
-	tmp[1] = js1[js1_ind].MR2;
-	dataL = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR3_DATA_F1_0);
-	if(Boardcnf->dbi_en)
-		tmp[2] = dataL | 0xc0;
-	else
-		tmp[2] = dataL & (~0xc0);
-
-	for(i=0;i<2;i++){
-		for(csab=0;csab<CSAB_CNT;csab++){
-			ddrtbl_setval(_cnf_DDR_PI_REGSET,
-				_reg_PI_MR1_DATA_Fx_CSx[i][csab], tmp[0]);
-			ddrtbl_setval(_cnf_DDR_PI_REGSET,
-				_reg_PI_MR2_DATA_Fx_CSx[i][csab], tmp[1]);
-			ddrtbl_setval(_cnf_DDR_PI_REGSET,
-				_reg_PI_MR3_DATA_Fx_CSx[i][csab], tmp[2]);
-		}
-	}
-
-	/***********************************************************************
-	 DDRPHY INT START
-	***********************************************************************/
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		// non
-	} else {
-		regif_pll_wa();
-	}
-
-	/***********************************************************************
-	FREQ_SEL_MULTICAST & PER_CS_TRAINING_MULTICAST SET (for safety)
-	***********************************************************************/
-	ddr_setval_ach(_reg_PHY_FREQ_SEL_MULTICAST_EN, 0x01);
-	ddr_setval_ach_as(_reg_PHY_PER_CS_TRAINING_MULTICAST_EN, 0x01);
-
-	/***********************************************************************
-	SET DATA SLICE TABLE
-	***********************************************************************/
-	for( slice=0; slice<SLICE_CNT; slice++){
-		adr = DDR_PHY_SLICE_REGSET_OFS + DDR_PHY_SLICE_REGSET_SIZE * slice;
-		for( i=0; i<DDR_PHY_SLICE_REGSET_NUM; i++ ) {
-			reg_ddrphy_write_a(adr+i, _cnf_DDR_PHY_SLICE_REGSET[i]);
-		}
-	}
-
-	/***********************************************************************
-	SET ADR SLICE TABLE
-	***********************************************************************/
-	adr = DDR_PHY_ADR_V_REGSET_OFS;
-	for( i=0; i<DDR_PHY_ADR_V_REGSET_NUM; i++ ) {
-		reg_ddrphy_write_a(adr+i, _cnf_DDR_PHY_ADR_V_REGSET[i]);
-	}
-
-	if (DDR_PHY_ADR_I_NUM > 0) {
-		for( slice=0; slice<DDR_PHY_ADR_I_NUM; slice++){
-			adr = DDR_PHY_ADR_I_REGSET_OFS + DDR_PHY_ADR_I_REGSET_SIZE * slice;
-			for( i=0; i<DDR_PHY_ADR_I_REGSET_NUM; i++ ) {
-				reg_ddrphy_write_a(adr+i, _cnf_DDR_PHY_ADR_I_REGSET[i]);
-			}
-		}
-	}
-
-	/***********************************************************************
-	SET ADRCTRL SLICE TABLE
-	***********************************************************************/
-	adr = DDR_PHY_ADR_G_REGSET_OFS;
-	for( i=0; i<DDR_PHY_ADR_G_REGSET_NUM; i++ ) {
-		reg_ddrphy_write_a(adr+i, _cnf_DDR_PHY_ADR_G_REGSET[i]);
-	}
-
-	/***********************************************************************
-	SET PI REGISTERS
-	***********************************************************************/
-	adr = DDR_PI_REGSET_OFS;
-	for( i=0; i<DDR_PI_REGSET_NUM; i++ )
-	{
-		reg_ddrphy_write_a(adr+i, _cnf_DDR_PI_REGSET[i]);
-	}
-}
-
-/*******************************************************************************
- *	CONFIGURE DDR REGISTERS
- ******************************************************************************/
-static void ddr_config_sub(void)
-{
-	int32_t i;
-	uint32_t ch, slice;
-	uint32_t dataL;
-	uint32_t tmp;
-	uint8_t high_byte[SLICE_CNT];
-	foreach_vch(ch){
-	/***********************************************************************
-	BOARD SETTINGS (DQ,DM,VREF_DRIVING)
-	***********************************************************************/
-		for(slice=0;slice<SLICE_CNT;slice++){
-			high_byte[slice] = (Boardcnf->ch[ch].dqs_swap >> (4*slice))%2;
-			ddr_setval_s(ch, slice, _reg_PHY_DQ_DM_SWIZZLE0, Boardcnf->ch[ch].dq_swap[slice]);
-			ddr_setval_s(ch, slice, _reg_PHY_DQ_DM_SWIZZLE1, Boardcnf->ch[ch].dm_swap[slice]);
-			if( high_byte[slice] ) {
-				/* HIGHER 16 BYTE */
-				ddr_setval_s(ch, slice, _reg_PHY_CALVL_VREF_DRIVING_SLICE, 0x00);
-			} else {
-				/* LOWER 16 BYTE */
-				ddr_setval_s(ch, slice, _reg_PHY_CALVL_VREF_DRIVING_SLICE, 0x01);
-			}
-		}
-
-	/***********************************************************************
-		BOARD SETTINGS (CA,ADDR_SEL)
-	***********************************************************************/
-		const uint32_t _par_CALVL_DEVICE_MAP=1;
-		dataL = Boardcnf->ch[ch].ca_swap | 0x00888888;
-
-		/* --- ADR_CALVL_SWIZZLE --- */
-		if (Prr_Product==PRR_PRODUCT_M3) {
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE0_0, dataL);
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE1_0, 0x00000000);
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE0_1, dataL);
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE1_1, 0x00000000);
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_DEVICE_MAP, _par_CALVL_DEVICE_MAP);
-		} else {
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE0, dataL);
-			ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE1, 0x00000000);
-			ddr_setval(ch, _reg_PHY_CALVL_DEVICE_MAP, _par_CALVL_DEVICE_MAP);
-		}
-
-		/* --- ADR_ADDR_SEL --- */
-		if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut> PRR_PRODUCT_11)) {
-			dataL= 0x00FFFFFF & Boardcnf->ch[ch].ca_swap;
-		} else {
-			dataL=0;
-			tmp = Boardcnf->ch[ch].ca_swap;
-			for(i=0;i<6;i++){
-				dataL |= ((tmp&0x0f)<<(i*5));
-				tmp=tmp>>4;
-			}
-		}
-		ddr_setval(ch, _reg_PHY_ADR_ADDR_SEL, dataL);
-
-	/***********************************************************************
-		BOARD SETTINGS (BYTE_ORDER_SEL)
-	***********************************************************************/
-		if(Prr_Product==PRR_PRODUCT_M3) {
-			/* --- DATA_BYTE_SWAP --- */
-			dataL=0;
-			tmp=Boardcnf->ch[ch].dqs_swap;
-			for(i=0;i<4;i++){
-				dataL |= ((tmp&0x03)<<(i*2));
-				tmp = tmp>>4;
-			}
-		} else {
-			/* --- DATA_BYTE_SWAP --- */
-			dataL = Boardcnf->ch[ch].dqs_swap;
-			ddr_setval(ch, _reg_PI_DATA_BYTE_SWAP_EN, 0x01);
-			ddr_setval(ch, _reg_PI_DATA_BYTE_SWAP_SLICE0, (dataL       ) & 0x0f );
-			ddr_setval(ch, _reg_PI_DATA_BYTE_SWAP_SLICE1, (dataL >> 4*1) & 0x0f );
-			ddr_setval(ch, _reg_PI_DATA_BYTE_SWAP_SLICE2, (dataL >> 4*2) & 0x0f );
-			ddr_setval(ch, _reg_PI_DATA_BYTE_SWAP_SLICE3, (dataL >> 4*3) & 0x0f );
-
-			ddr_setval(ch, _reg_PHY_DATA_BYTE_ORDER_SEL_HIGH, 0x00);
-		}
-		ddr_setval(ch, _reg_PHY_DATA_BYTE_ORDER_SEL, dataL);
-	}
-}
-
-static void get_ca_swizzle( uint32_t ch, uint32_t ddr_csn, uint32_t *p_swz)
-{
-	uint32_t slice;
-	uint32_t tmp;
-	uint32_t tgt;
-	if(ddr_csn/2) {
-		tgt=3;
-	} else {
-		tgt=1;
-	}
-
-	for(slice=0;slice<SLICE_CNT;slice++) {
-		tmp = (Boardcnf->ch[ch].dqs_swap >> (4*slice)) & 0x0f;
-		if(tgt==tmp)break;
-	}
-	tmp = Boardcnf->ch[ch].ca_swap;
-	if(slice%2)
-		tmp |= 0x00888888;
-	*p_swz = tmp;
-}
-
-static void ddr_config_sub_h3v1x(void)
-{
-	uint32_t ch, slice;
-	uint32_t dataL;
-	uint32_t tmp;
-	uint8_t high_byte[SLICE_CNT];
-
-	foreach_vch(ch){
-		uint32_t ca_swizzle;
-		uint32_t ca;
-		uint32_t csmap;
-	/***********************************************************************
-		BOARD SETTINGS (DQ,DM,VREF_DRIVING)
-	***********************************************************************/
-		csmap=0;
-		for(slice=0;slice<SLICE_CNT;slice++){
-			tmp = (Boardcnf->ch[ch].dqs_swap >> (4*slice)) & 0x0f;
-			high_byte[slice] = tmp%2;
-			if(tmp==1 && (slice>=2))csmap|=0x05;
-			if(tmp==3 && (slice>=2))csmap|=0x50;
-			ddr_setval_s(ch, slice, _reg_PHY_DQ_SWIZZLING, Boardcnf->ch[ch].dq_swap[slice]);
-			if( high_byte[slice] ) {
-				/* HIGHER 16 BYTE */
-				ddr_setval_s(ch, slice, _reg_PHY_CALVL_VREF_DRIVING_SLICE, 0x00);
-			} else {
-				/* LOWER 16 BYTE */
-				ddr_setval_s(ch, slice, _reg_PHY_CALVL_VREF_DRIVING_SLICE, 0x01);
-			}
-		}
-	/***********************************************************************
-		BOARD SETTINGS (CA,ADDR_SEL)
-	***********************************************************************/
-		ca=Boardcnf->ch[ch].ca_swap;
-		ddr_setval(ch, _reg_PHY_ADR_ADDR_SEL, ca);
-		ddr_setval(ch, _reg_PHY_CALVL_CS_MAP, csmap);
-
-		get_ca_swizzle(ch, 0, &ca_swizzle);
-
-		ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE0_0, ca_swizzle);
-		ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE1_0, 0x00000000);
-		ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE0_1, 0x00000000);
-		ddr_setval(ch, _reg_PHY_ADR_CALVL_SWIZZLE1_1, 0x00000000);
-		ddr_setval(ch, _reg_PHY_ADR_CALVL_DEVICE_MAP, 0x01);
-
-		for(slice=0;slice<SLICE_CNT;slice++){
-			const uint8_t o_mr15=0x55;
-			const uint8_t o_mr20=0x55;
-			const uint16_t o_mr32_mr40 = 0x5a3c;
-			uint32_t o_inv;
-			uint32_t inv;
-			uint32_t bit_soc;
-			uint32_t bit_mem;
-			uint32_t j;
-
-			ddr_setval_s(ch, slice, _reg_PI_RDLVL_PATTERN_NUM, 0x01);
-			ddr_setval_s(ch, slice, _reg_PI_RDLVL_PATTERN_START, 0x08);
-
-			if(high_byte[slice])
-				o_inv = o_mr20;
-			else
-				o_inv = o_mr15;
-
-			tmp = Boardcnf->ch[ch].dq_swap[slice];
-			inv = 0;
-			j = 0;
-			for(bit_soc=0;bit_soc<8;bit_soc++) {
-				bit_mem = (tmp>>(4*bit_soc)) & 0x0f;
-				j|=(1U<<bit_mem);
-				if(o_inv & (1U<<bit_mem))
-					inv |= (1U<<bit_soc);
-			}
-			dataL = o_mr32_mr40;
-			if(!high_byte[slice])dataL |= (inv<<24);
-			if( high_byte[slice])dataL |= (inv<<16);
-			ddr_setval_s(ch, slice, _reg_PHY_LP4_RDLVL_PATT8, dataL);
-		}
-	}
-}
-
-static void ddr_config(void)
-{
-	int32_t i;
-	uint32_t ch, slice;
-	uint32_t dataL;
-	uint32_t tmp;
-
-	/***********************************************************************
-	configure ddrphy registers
-	***********************************************************************/
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		ddr_config_sub_h3v1x();
-	} else {
-		ddr_config_sub();	// H3 Ver.2.0 or later/M3-N/V3H is same as M3-W
-	}
-
-	/***********************************************************************
-	WDQ_USER_PATT
-	***********************************************************************/
-	foreach_vch(ch){
-		union {
-			uint32_t ui32[4];
-			uint8_t ui8[16];
-		} patt;
-		uint16_t patm;
-		for(slice=0;slice<SLICE_CNT;slice++) {
-			patm=0;
-			for(i=0;i<16;i++){
-				tmp = Boardcnf->ch[ch].wdqlvl_patt[i];
-				patt.ui8[i] = tmp & 0xff;
-				if(tmp&0x100)
-					patm |= (1U<<i);
-			}
-			ddr_setval_s(ch, slice, _reg_PHY_USER_PATT0, patt.ui32[0]);
-			ddr_setval_s(ch, slice, _reg_PHY_USER_PATT1, patt.ui32[1]);
-			ddr_setval_s(ch, slice, _reg_PHY_USER_PATT2, patt.ui32[2]);
-			ddr_setval_s(ch, slice, _reg_PHY_USER_PATT3, patt.ui32[3]);
-			ddr_setval_s(ch, slice, _reg_PHY_USER_PATT4, patm);
-		}
-	}
-
-	/***********************************************************************
-	CACS DLY
-	***********************************************************************/
-	dataL = Boardcnf->cacs_dly + _f_scale_adj(Boardcnf->cacs_dly_adj);
-	set_dfifrequency(0x1f);
-	foreach_vch(ch){
-		int16_t adj;
-		for(i=0;i<_reg_PHY_CLK_CACS_SLAVE_DELAY_X_NUM;i++){
-			adj = _f_scale_adj(Boardcnf->ch[ch].cacs_adj[i]);
-			ddr_setval(ch, _reg_PHY_CLK_CACS_SLAVE_DELAY_X[i],
-				dataL + adj
-			);
-		}
-	}
-	set_dfifrequency(0x00);
-
-	/***********************************************************************
-	WDQDM DLY
-	***********************************************************************/
-	dataL = Boardcnf->dqdm_dly_w;
-	foreach_vch(ch){
-		int8_t _adj;
-		int16_t adj;
-		uint32_t dq;
-		for(slice=0;slice<SLICE_CNT;slice++){
-			for(i=0;i<=8;i++){
-				dq = slice*8+i;
-				if(i==8)
-					_adj = Boardcnf->ch[ch].dm_adj_w[slice];
-				else
-					_adj = Boardcnf->ch[ch].dq_adj_w[dq];
-				adj = _f_scale_adj(_adj);
-				ddr_setval_s(ch, slice,
-					_reg_PHY_CLK_WRX_SLAVE_DELAY[i],
-					dataL + adj
-				);
-			}
-		}
-	}
-
-	/***********************************************************************
-	RDQDM DLY
-	***********************************************************************/
-	dataL = Boardcnf->dqdm_dly_r;
-	foreach_vch(ch){
-		int8_t _adj;
-		int16_t adj;
-		uint32_t dq;
-		for(slice=0;slice<SLICE_CNT;slice++){
-			for(i=0;i<=8;i++){
-				dq = slice*8+i;
-				if(i==8)
-					_adj = Boardcnf->ch[ch].dm_adj_r[slice];
-				else
-					_adj = Boardcnf->ch[ch].dq_adj_r[dq];
-				adj = _f_scale_adj(_adj);
-				ddr_setval_s(ch, slice,
-					_reg_PHY_RDDQS_X_FALL_SLAVE_DELAY[i],
-					dataL + adj
-				);
-				ddr_setval_s(ch, slice,
-					_reg_PHY_RDDQS_X_RISE_SLAVE_DELAY[i],
-					dataL + adj
-				);
-			}
-		}
-	}
-}
-
-/*******************************************************************************
- *	DBSC register setting functions
- ******************************************************************************/
-static void dbsc_regset_pre(void)
-{
-	uint32_t ch, csab;
-	uint32_t dataL;
-
-	/***********************************************************************
-	PRIMARY SETTINGS
-	***********************************************************************/
-	/* LPDDR4, BL=16, DFI interface */
-	mmio_write_32(DBSC_DBKIND, 0x0000000a);
-	mmio_write_32(DBSC_DBBL, 0x00000002);
-	mmio_write_32(DBSC_DBPHYCONF0, 0x00000001);
-
-	/* FREQRATIO=2 */
-	mmio_write_32(DBSC_DBSYSCONF1, 0x00000002);
-
-	/* Chanel map (H3 Ver.1.x) */
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-		mmio_write_32(DBSC_DBSCHCNT1, 0x00001010);
-
-	/* DRAM SIZE REGISTER:
-	 * set all ranks as density=0(4Gb) for PHY initialization
-	 */
-	foreach_vch(ch)
-		for(csab=0;csab<4;csab++)
-			mmio_write_32(DBSC_DBMEMCONF(ch,csab), DBMEMCONF_REGD(0));
-
-	if(Prr_Product==PRR_PRODUCT_M3) {
-		dataL = 0xe4e4e4e4;
-		foreach_ech(ch) {
-			if((ddr_phyvalid & (1U<<ch)))
-				dataL = (dataL &(~(0x000000FF << (ch*8))))
-					|((	  (Boardcnf->ch[ch].dqs_swap & 0x0003)
-						|((Boardcnf->ch[ch].dqs_swap & 0x0030) >> 2)
-						|((Boardcnf->ch[ch].dqs_swap & 0x0300) >> 4)
-						|((Boardcnf->ch[ch].dqs_swap & 0x3000) >> 6)	)<< (ch*8));
-		}
-		mmio_write_32(DBSC_DBBSWAP, dataL);
-	}
-}
-
-static void dbsc_regset(void)
-{
-	int32_t i;
-	uint32_t ch;
-	uint32_t dataL;
-	uint32_t tmp[4];
-
-	/* RFC */
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut==PRR_PRODUCT_20)&&(max_density==0)){
-		js2[JS2_tRFCpb] = _f_scale(ddr_mbps, ddr_mbpsdiv,
-			1UL*jedec_spec2_tRFC_pb_ab[0][1] * 1000, 0);
-		js2[JS2_tRFCab] = _f_scale(ddr_mbps, ddr_mbpsdiv,
-			1UL*jedec_spec2_tRFC_pb_ab[1][1] * 1000, 0);
-	} else {
-		js2[JS2_tRFCpb] = _f_scale(ddr_mbps, ddr_mbpsdiv,
-			1UL*jedec_spec2_tRFC_pb_ab[0][max_density] * 1000, 0);
-		js2[JS2_tRFCab] = _f_scale(ddr_mbps, ddr_mbpsdiv,
-			1UL*jedec_spec2_tRFC_pb_ab[1][max_density] * 1000, 0);
-	}
-
-	/* DBTR0.CL  : RL */
-	mmio_write_32(DBSC_DBTR(0), RL);
-
-	/* DBTR1.CWL : WL */
-	mmio_write_32(DBSC_DBTR(1), WL);
-
-	/* DBTR2.AL  : 0 */
-	mmio_write_32(DBSC_DBTR(2), 0);
-
-	/* DBTR3.TRCD: tRCD */
-	mmio_write_32(DBSC_DBTR(3), js2[JS2_tRCD]);
-
-	/* DBTR4.TRPA,TRP: tRPab,tRPpb */
-	mmio_write_32(DBSC_DBTR(4), (js2[JS2_tRPab]<<16) | js2[JS2_tRPpb]);
-
-	/* DBTR5.TRC : use tRCpb */
-	mmio_write_32(DBSC_DBTR(5), js2[JS2_tRCpb]);
-
-	/* DBTR6.TRAS : tRAS */
-	mmio_write_32(DBSC_DBTR(6), js2[JS2_tRAS]);
-
-	/* DBTR7.TRRD : tRRD */
-	mmio_write_32(DBSC_DBTR(7), (js2[JS2_tRRD]<<16) | js2[JS2_tRRD]);
-
-	/* DBTR8.TFAW : tFAW */
-	mmio_write_32(DBSC_DBTR(8), js2[JS2_tFAW]);
-
-	/* DBTR9.TRDPR : tRTP */
-	mmio_write_32(DBSC_DBTR(9), js2[JS2_tRTP]);
-
-	/* DBTR10.TWR : nWR */
-	mmio_write_32(DBSC_DBTR(10), js1[js1_ind].nWR);
-
-	/* DBTR11.TRDWR : RL + tDQSCK + BL/2 + Rounddown(tRPST) - WL + tWPRE */
-	mmio_write_32(DBSC_DBTR(11),
-		RL + js2[JS2_tDQSCK] + (16/2) + 1 - WL + 2 +2);
-
-	/* DBTR12.TWRRD : WL + 1 + BL/2 + tWTR */
-	dataL = WL + 1 + (16/2) + js2[JS2_tWTR];
-	mmio_write_32(DBSC_DBTR(12), (dataL<<16) | dataL);
-
-	/* DBTR13.TRFCPB,TRFCAB : tRFCpb, tRFCab */
-	mmio_write_32(DBSC_DBTR(13),
-		(js2[JS2_tRFCab]));
-
-	/* DBTR14.TCKEHDLL,tCKEH : tCKEHCMD,tCKEHCMD */
-	mmio_write_32(DBSC_DBTR(14),
-		(js2[JS2_tCKEHCMD] <<16) | (js2[JS2_tCKEHCMD]));
-
-	/* DBTR15.TCKESR,TCKEL : tSR,tCKELPD */
-	mmio_write_32(DBSC_DBTR(15),
-		(js2[JS2_tSR] <<16) | (js2[JS2_tCKELPD]));
-
-	/* DBTR16 */
-	/* WDQL : tphy_wrlat + tphy_wrdata */
-	tmp[0] = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_WRLAT_F1);
-	/* DQENLTNCY : tphy_wrlat = WL-2 */
-	tmp[1] = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_WRLAT_ADJ_F1);
-	/* DQL : tphy_rdlat + trdata_en */
-	/* it is not important for dbsc */
-	tmp[2] = RL + 16;
-	/* DQIENLTNCY : trdata_en */
-	tmp[3] = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_RDLAT_ADJ_F1) - 1;
-	mmio_write_32(DBSC_DBTR(16),
-		(tmp[3]<<24) | (tmp[2]<<16) | (tmp[1]<<8) | tmp[0]);
-
-	/* DBTR24*/
-	/* WRCSLAT = WRLAT -5*/
-	tmp[0] -= 5;
-	/* WRCSGAP = 5 */
-	tmp[1] = 5;
-	/* RDCSLAT = RDLAT_ADJ +2*/
-	tmp[2] = tmp[3] +2;
-	/* RDCSGAP = 6 */
-	if(Prr_Product==PRR_PRODUCT_M3) {
-		tmp[3] = 4;
-	} else {
-		tmp[3] = 6;
-	}
-	mmio_write_32(DBSC_DBTR(24),
-		(tmp[3]<<24) | (tmp[2]<<16) | (tmp[1]<<8) | tmp[0]);
-
-	/* DBTR17.TMODRD,TMOD,TRDMR: tMRR,tMRD,(0)*/
-	mmio_write_32(DBSC_DBTR(17), (js2[JS2_tMRR]<<24)|(js2[JS2_tMRD]<<16));
-
-	/* DBTR18.RODTL, RODTA, WODTL, WODTA : do not use in LPDDR4 */
-	mmio_write_32(DBSC_DBTR(18), 0);
-
-	/* DBTR19.TZQCL, TZQCS : do not use in LPDDR4 */
-	mmio_write_32(DBSC_DBTR(19), 0);
-
-	/* DBTR20.TXSDLL, TXS : tRFCab+tCKEHCMD */
-	dataL = js2[JS2_tRFCab] + js2[JS2_tCKEHCMD];
-	mmio_write_32(DBSC_DBTR(20), (dataL<<16) | dataL);
-
-	/* DBTR21.TCCD */
-	/* DBTR23.TCCD */
-	/* H3 Ver.1.0 cannot use TBTR23 feature */
-	if(ddr_tccd==8 &&
-		!((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_10))
-	) {
-		dataL=8;
-		mmio_write_32(DBSC_DBTR(21), (dataL<<16) | dataL);
-		mmio_write_32(DBSC_DBTR(23), 0x00000002);
-	} else if(ddr_tccd<=11) {
-		dataL=11;
-		mmio_write_32(DBSC_DBTR(21), (dataL<<16) | dataL);
-		mmio_write_32(DBSC_DBTR(23), 0x00000000);
-	} else {
-		dataL=ddr_tccd;
-		mmio_write_32(DBSC_DBTR(21), (dataL<<16) | dataL);
-		mmio_write_32(DBSC_DBTR(23), 0x00000000);
-	}
-
-	/* DBTR22.ZQLAT : */
-	dataL = js2[JS2_tZQCALns]*100;	// 1000 * 1000 ps
-	dataL = (dataL<<16) | (js2[JS2_tZQLAT]+24 +20);
-	mmio_write_32(DBSC_DBTR(22), dataL);
-
-	/* DBTR25 : do not use in LPDDR4 */
-	mmio_write_32(DBSC_DBTR(25), 0);
-
-	/* DBRNK : */
-	/*
-	 * DBSC_DBRNK2 rkrr
-	 * DBSC_DBRNK3 rkrw
-	 * DBSC_DBRNK4 rkwr
-	 * DBSC_DBRNK5 rkww
-	 */
- #define _par_DBRNK_VAL		(0x7007)
-
-	for(i=0;i<4;i++){
-		uint32_t dataL2;
-		dataL=(_par_DBRNK_VAL>>(i*4)) & 0x0f;
-		if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut>PRR_PRODUCT_11)&&(i==0)){
-			dataL +=1;
-		}
-		dataL2=0;
-		foreach_vch(ch){
-			dataL2= dataL2 | (dataL<<(4*ch)) ;
-		}
-		mmio_write_32(DBSC_DBRNK(2+i), dataL2);
-	}
-	mmio_write_32(DBSC_DBADJ0, 0x00000000);
-
-	/***********************************************************************
-	timing registers for Scheduler
-	***********************************************************************/
-	/* SCFCTST0 */
-	/* SCFCTST0 ACT-ACT*/
-	tmp[3] = 1UL * js2[JS2_tRCpb] * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST0 RDA-ACT*/
-	tmp[2] = 1UL * ((16/2) + js2[JS2_tRTP] -8 + js2[JS2_tRPpb]) * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST0 WRA-ACT*/
-	tmp[1] = 1UL * (WL + 1 + (16/2) + js1[js1_ind].nWR) * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST0 PRE-ACT*/
-	tmp[0] = 1UL * js2[JS2_tRPpb];
-	mmio_write_32(DBSC_SCFCTST0, (tmp[3]<<24) | (tmp[2]<<16) | (tmp[1]<<8) | tmp[0]);
-
-	/* SCFCTST1 */
-	/* SCFCTST1 RD-WR*/
-	tmp[3] = 1UL * (mmio_read_32(DBSC_DBTR(11)) & 0xff) * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST1 WR-RD*/
-	tmp[2] = 1UL * (mmio_read_32(DBSC_DBTR(12)) & 0xff) * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST1 ACT-RD/WR*/
-	tmp[1] = 1UL * js2[JS2_tRCD] * 800 * ddr_mbpsdiv /ddr_mbps;
-	/* SCFCTST1 ASYNCOFS*/
-	tmp[0] = 12;
-	mmio_write_32(DBSC_SCFCTST1, (tmp[3]<<24) | (tmp[2]<<16) | (tmp[1]<<8) | tmp[0]);
-
-	/* DBSCHRW1 */
-	/* DBSCHRW1 SCTRFCAB*/
-	tmp[0] = 1UL * js2[JS2_tRFCab] * 800 * ddr_mbpsdiv /ddr_mbps;
-	dataL =( ((mmio_read_32(DBSC_DBTR(16)) & 0x00FF0000) >>16 )
-		+ (mmio_read_32(DBSC_DBTR(22)) & 0x0000FFFF)
-		+ (0x28 * 2) ) * 400 * 2 * ddr_mbpsdiv /ddr_mbps + 7;
-	if(tmp[0] < dataL) tmp[0] = dataL;
-	mmio_write_32(DBSC_DBSCHRW1, tmp[0]);
-
-	/***********************************************************************
-	QOS and CAM
-	***********************************************************************/
-#ifdef ddr_qos_init_setting // only for non qos_init
-	/*wbkwait(0004), wbkmdhi(4,2),wbkmdlo(1,8) */
-	mmio_write_32(DBSC_DBCAM0CNF1,	0x00043218);
-	/*0(fillunit),8(dirtymax),4(dirtymin)*/
-	mmio_write_32(DBSC_DBCAM0CNF2,	0x000000F4);
-	/*stop_tolerance*/
-	mmio_write_32(DBSC_DBSCHRW0,    0x22421111);
-	/*rd-wr/wr-rd toggle priority*/
-	mmio_write_32(DBSC_SCFCTST2,    0x012F1123);
-	mmio_write_32(DBSC_DBSCHSZ0,	0x00000001);
-	mmio_write_32(DBSC_DBSCHCNT0,	0x000F0037);
-
-	/* QoS Settings */
-	mmio_write_32(DBSC_DBSCHQOS00,	0x00000F00U);
-	mmio_write_32(DBSC_DBSCHQOS01,	0x00000B00U);
-	mmio_write_32(DBSC_DBSCHQOS02,	0x00000000U);
-	mmio_write_32(DBSC_DBSCHQOS03,	0x00000000U);
-	mmio_write_32(DBSC_DBSCHQOS40,	0x00000300U);
-	mmio_write_32(DBSC_DBSCHQOS41,	0x000002F0U);
-	mmio_write_32(DBSC_DBSCHQOS42,	0x00000200U);
-	mmio_write_32(DBSC_DBSCHQOS43,	0x00000100U);
-	mmio_write_32(DBSC_DBSCHQOS90,	0x00000100U);
-	mmio_write_32(DBSC_DBSCHQOS91,	0x000000F0U);
-	mmio_write_32(DBSC_DBSCHQOS92,	0x000000A0U);
-	mmio_write_32(DBSC_DBSCHQOS93,	0x00000040U);
-	mmio_write_32(DBSC_DBSCHQOS120,	0x00000040U);
-	mmio_write_32(DBSC_DBSCHQOS121,	0x00000030U);
-	mmio_write_32(DBSC_DBSCHQOS122,	0x00000020U);
-	mmio_write_32(DBSC_DBSCHQOS123,	0x00000010U);
-	mmio_write_32(DBSC_DBSCHQOS130, 0x00000100U);
-	mmio_write_32(DBSC_DBSCHQOS131, 0x000000F0U);
-	mmio_write_32(DBSC_DBSCHQOS132, 0x000000A0U);
-	mmio_write_32(DBSC_DBSCHQOS133, 0x00000040U);
-	mmio_write_32(DBSC_DBSCHQOS140, 0x000000C0U);
-	mmio_write_32(DBSC_DBSCHQOS141, 0x000000B0U);
-	mmio_write_32(DBSC_DBSCHQOS142, 0x00000080U);
-	mmio_write_32(DBSC_DBSCHQOS143, 0x00000040U);
-	mmio_write_32(DBSC_DBSCHQOS150, 0x00000040U);
-	mmio_write_32(DBSC_DBSCHQOS151, 0x00000030U);
-	mmio_write_32(DBSC_DBSCHQOS152, 0x00000020U);
-	mmio_write_32(DBSC_DBSCHQOS153, 0x00000010U);
-
-	mmio_write_32(QOSCTRL_RAEN,	0x00000001U);
-#endif//ddr_qos_init_setting
-	/* H3 Ver.1.1 need to set monitor function */
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut==PRR_PRODUCT_11)) {
-		mmio_write_32(DBSC_DBMONCONF4, 0x00700000);
-	}
-
-	if (Prr_Product==PRR_PRODUCT_H3){
-		if(Prr_Cut==PRR_PRODUCT_10){
-			/* resrdis, simple mode, sc off	*/
-			mmio_write_32(DBSC_DBBCAMDIS, 0x00000007);
-		} else if(Prr_Cut==PRR_PRODUCT_11){
-			/* resrdis, simple mode		*/
-			mmio_write_32(DBSC_DBBCAMDIS, 0x00000005);
-		} else if(Prr_Cut<PRR_PRODUCT_30){
-			/* H3 Ver.2.0			*/
-			/* resrdis			*/
-			mmio_write_32(DBSC_DBBCAMDIS, 0x00000001);
-		} else {/* H3 Ver.3.0(include H3N)	*/
-			/* exprespque			*/
-			mmio_write_32(DBSC_DBBCAMDIS, 0x00000010);
-		}
-	} else {	/* M3-W/M3-N/V3H		*/
-			/* resrdis			*/
-			mmio_write_32(DBSC_DBBCAMDIS, 0x00000001);
-	}
-}
-
-static void dbsc_regset_post(void)
-{
-	uint32_t ch,cs;
-	uint32_t dataL;
-	uint32_t slice,rdlat_max,rdlat_min;
-
-	rdlat_max = 0;
-	rdlat_min = 0xffff;
-	foreach_vch(ch){
-		for(cs=0;cs<CS_CNT;cs++){
-			if((ch_have_this_cs[cs] & (1U<<ch)) != 0) {
-				for(slice=0;slice<SLICE_CNT;slice++){
-					ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX, cs);
-					dataL = ddr_getval_s(ch, slice,	_reg_PHY_RDDQS_LATENCY_ADJUST);
-					if(dataL>rdlat_max) rdlat_max = dataL;
-					if(dataL<rdlat_min) rdlat_min = dataL;
-				}
-			}
-		}
-	}
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut> PRR_PRODUCT_11)){
-		mmio_write_32(DBSC_DBTR(24),
-			((rdlat_max *2 -rdlat_min +4)<<24) + ((rdlat_min +2)<<16) + mmio_read_32(DBSC_DBTR(24)));
-	} else {
-		mmio_write_32(DBSC_DBTR(24),
-			((rdlat_max +2)<<24) + ((rdlat_max +2)<<16) + mmio_read_32(DBSC_DBTR(24)));
-	}
-
-	/* set ddr density information */
-	foreach_ech(ch){
-		for(cs=0;cs<CS_CNT;cs++){
-			if(ddr_density[ch][cs]==0xff) {
-				mmio_write_32(DBSC_DBMEMCONF(ch,cs), 0x00);
-			} else {
-				mmio_write_32(DBSC_DBMEMCONF(ch,cs), DBMEMCONF_REGD(ddr_density[ch][cs]));
-			}
-		}
-		mmio_write_32(DBSC_DBMEMCONF(ch,2), 0x00000000);
-		mmio_write_32(DBSC_DBMEMCONF(ch,3), 0x00000000);
-	}
-
-	mmio_write_32(DBSC_DBBUS0CNF1, 0x00000010);
-
-	/*set DBI */
-	if(Boardcnf->dbi_en)
-		mmio_write_32(DBSC_DBDBICNT, 0x00000003);
-
-	/* H3 Ver.2.0 or later/M3-N/V3H DBI wa */
-	if ((((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut> PRR_PRODUCT_11))
-	   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H))&&(Boardcnf->dbi_en))
-		reg_ddrphy_write_a(0x00001010,	0x01000000);
-
-	/*set REFCYCLE */
-	dataL = (get_refperiod())*ddr_mbps/2000/ddr_mbpsdiv;
-	mmio_write_32(DBSC_DBRFCNF1, 0x00080000 | (dataL&0x0000ffff));
-	mmio_write_32(DBSC_DBRFCNF2, 0x00010000|DBSC_REFINTS);
-#if RCAR_REWT_TRAINING != 0
-	/* Periodic-WriteDQ Training seeting */
-	if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-	 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut==PRR_PRODUCT_10))) {
-		/* non : H3 Ver.1.x/M3-W Ver.1.0 not support */
-	} else {
-		/* H3 Ver.2.0 or later/M3-W Ver.1.1 or later/M3-N/V3H -> Periodic-WriteDQ Training seeting */
-
-		/* Periodic WriteDQ Training seeting */
-		mmio_write_32(DBSC_DBDFIPMSTRCNF, 0x00000000);
-
-		ddr_setval_ach_as(_reg_PHY_WDQLVL_PATT, 0x04);
-		ddr_setval_ach_as(_reg_PHY_WDQLVL_QTR_DLY_STEP, 0x0F);
-		ddr_setval_ach_as(_reg_PHY_WDQLVL_DLY_STEP, 0x50);
-		ddr_setval_ach_as(_reg_PHY_WDQLVL_DQDM_SLV_DLY_START, 0x0300);
-
-		ddr_setval_ach(_reg_PI_WDQLVL_CS_MAP, ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_WDQLVL_CS_MAP));
-		ddr_setval_ach(_reg_PI_LONG_COUNT_MASK, 0x1f);
-		ddr_setval_ach(_reg_PI_WDQLVL_VREF_EN, 0x00);
-		ddr_setval_ach(_reg_PI_WDQLVL_INTERVAL, 0x0100);
-		ddr_setval_ach(_reg_PI_WDQLVL_ROTATE, 0x01);
-		ddr_setval_ach(_reg_PI_TREF_F0, 0x0000);
-		ddr_setval_ach(_reg_PI_TREF_F1, 0x0000);
-		ddr_setval_ach(_reg_PI_TREF_F2, 0x0000);
-
-		if(Prr_Product==PRR_PRODUCT_M3) {
-			ddr_setval_ach(_reg_PI_WDQLVL_EN, 0x02);
-		} else {
-			ddr_setval_ach(_reg_PI_WDQLVL_EN_F1, 0x02);
-		}
-		ddr_setval_ach(_reg_PI_WDQLVL_PERIODIC, 0x01);
-
-		/* DFI_PHYMSTR_ACK , WTmode setting */
-		mmio_write_32(DBSC_DBDFIPMSTRCNF, 0x00000011);	/* DFI_PHYMSTR_ACK: WTmode =b'01 */
-	}
-#endif//RCAR_REWT_TRAINING
-	/* periodic dram zqcal and phy ctrl update enable*/
-	mmio_write_32(DBSC_DBCALCNF, 0x01000010);
-	if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-	 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut<=PRR_PRODUCT_20))){
-		/* non : H3 Ver.1.x/M3-W Ver.1.x not support */
-	} else {
-#if RCAR_DRAM_SPLIT == 2
-		if((Prr_Product==PRR_PRODUCT_H3)&&(Boardcnf->phyvalid==0x05))
-			mmio_write_32(DBSC_DBDFICUPDCNF, 0x2a240001);
-		else
-			mmio_write_32(DBSC_DBDFICUPDCNF, 0x28240001);
-#else//RCAR_DRAM_SPLIT == 2
-		mmio_write_32(DBSC_DBDFICUPDCNF, 0x28240001);
-#endif//RCAR_DRAM_SPLIT == 2
-	}
-
-#ifdef DDR_BACKUPMODE
-	if(ddrBackup==DRAM_BOOT_STATUS_WARM){
-#ifdef DDR_BACKUPMODE_HALF		//for Half channel(ch0,1 only)
-		PutStr(" DEBUG_MESS : DDR_BACKUPMODE_HALF ",1);
-		send_dbcmd(0x08040001);
-		wait_dbcmd();
-		send_dbcmd(0x0A040001);
-		wait_dbcmd();
-		send_dbcmd(0x04040010);
-		wait_dbcmd();
-
-		if (Prr_Product==PRR_PRODUCT_H3) {
-			send_dbcmd(0x08140001);
-			wait_dbcmd();
-			send_dbcmd(0x0A140001);
-			wait_dbcmd();
-			send_dbcmd(0x04140010);
-			wait_dbcmd();
-		}
-#else//DDR_BACKUPMODE_HALF				//for All channels
-		send_dbcmd(0x08840001);
-		wait_dbcmd();
-		send_dbcmd(0x0A840001);
-		wait_dbcmd();
-
-		send_dbcmd(0x04840010);
-		wait_dbcmd();
-#endif//DDR_BACKUPMODE_HALF
-	}
-#endif//DDR_BACKUPMODE
-
-	mmio_write_32(DBSC_DBRFEN, 0x00000001);
-	/* dram access enable */
-	mmio_write_32(DBSC_DBACEN, 0x00000001);
-
-	MSG_LF("dbsc_regset_post(done)");
-
-}
-
-/*******************************************************************************
- *	DFI_INIT_START
- ******************************************************************************/
-static uint32_t dfi_init_start(void)
-{
-	uint32_t ch;
-	uint32_t phytrainingok;
-	uint32_t retry;
-	uint32_t dataL;
-	const uint32_t RETRY_MAX = 0x10000;
-
-	/***********************************************************************
-	set IE=1 when init_start_disable==0
-	***********************************************************************/
-	if(ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_CAL_MODE_0) & 0x01) {
-		ddr_setval_ach_as(_reg_PHY_IE_MODE, 0x00);
-	} else {
-		ddr_setval_ach_as(_reg_PHY_IE_MODE,ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-	}
-
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-
-	/***********************************************************************
-		PLL3 Disable
-	***********************************************************************/
-		/* protect register interface */
-		ddrphy_regif_idle();
-
-		pll3_control(0);
-
-	/***********************************************************************
-		init start
-	***********************************************************************/
-		/* dbdficnt0:
-		 * dfi_dram_clk_disable=1
-		 * dfi_frequency = 0
-		 * freq_ratio = 01 (2:1)
-		 * init_start =0
-		 */
-		foreach_vch(ch)
-			mmio_write_32(DBSC_DBDFICNT(ch), 0x00000F10);
-		dsb_sev();
-
-		/* dbdficnt0:
-		 * dfi_dram_clk_disable=1
-		 * dfi_frequency = 0
-		 * freq_ratio = 01 (2:1)
-		 * init_start =1
-		 */
-		foreach_vch(ch)
-			mmio_write_32(DBSC_DBDFICNT(ch), 0x00000F11);
-		dsb_sev();
-
-	} else {
-		ddr_setval_ach_as(_reg_PHY_DLL_RST_EN, 0x02);
-		dsb_sev();
-		ddrphy_regif_idle();
-	}
-
-	/* dll_rst negate */
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDCNT3(ch), 0x0000CF01);
-	dsb_sev();
-
-	/***********************************************************************
-	wait init_complete
-	***********************************************************************/
-	phytrainingok=0;
-	retry=0;
-	while(retry++<RETRY_MAX) {
-		foreach_vch(ch){
-			dataL = mmio_read_32(DBSC_INITCOMP(ch));
-			if(dataL & 0x00000001)
-				phytrainingok |= (1U<<ch);
-		}
-		dsb_sev();
-		if(phytrainingok == ddr_phyvalid)
-			break;
-		if(retry%256==0)
-			ddr_setval_ach_as(_reg_SC_PHY_RX_CAL_START, 0x01);
-	}
-
-	/***********************************************************************
-	all ch ok?
-	***********************************************************************/
-	if((phytrainingok & ddr_phyvalid) != ddr_phyvalid){
-		return (0xff);
-	}
-	/* dbdficnt0:
-	 * dfi_dram_clk_disable=0
-	 * dfi_frequency = 0
-	 * freq_ratio = 01 (2:1)
-	 * init_start =0
-	 */
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBDFICNT(ch), 0x00000010);
-	dsb_sev();
-
-	return 0;
-}
-
-/*******************************************************************************
- *	drivablity setting : CMOS MODE ON/OFF
- ******************************************************************************/
-static void change_lpddr4_en(uint32_t mode)
-{
-	uint32_t ch;
-	uint32_t i;
-	uint32_t dataL;
-	const uint32_t _reg_PHY_PAD_DRIVE_X[3] = {
-		_reg_PHY_PAD_ADDR_DRIVE,
-		_reg_PHY_PAD_CLK_DRIVE,
-		_reg_PHY_PAD_CS_DRIVE
-	};
-
-	for(i=0; i<3; i++) {
-		foreach_vch(ch){
-			dataL = ddr_getval(ch, _reg_PHY_PAD_DRIVE_X[i]);
-			if(mode) {
-				dataL |= (1U<<14);
-			} else {
-				dataL &= ~(1U<<14);
-			}
-			ddr_setval(ch, _reg_PHY_PAD_DRIVE_X[i], dataL);
-		}
-	}
-}
-
-/*******************************************************************************
- *	drivablity setting
- ******************************************************************************/
-static uint32_t set_term_code(void)
-{
-	int32_t i;
-	uint32_t ch,index;
-	uint32_t dataL;
-	uint32_t chip_id[2];
-	uint32_t term_code;
-	uint32_t override;
-	term_code = ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET,
-		_reg_PHY_PAD_DATA_TERM);
-	override = 0;
-	for(i=0;i<2;i++)
-		chip_id[i] = mmio_read_32(LIFEC_CHIPID(i));
-
-	index=0;
-	while(1) {
-		if(TermcodeBySample[index][0] == 0xffffffff) {
-			break;
-		}
-		if( ( TermcodeBySample[index][0] == chip_id[0])
-		&& ( TermcodeBySample[index][1] == chip_id[1])) {
-			term_code = TermcodeBySample[index][2];
-			override = 1;
-			break;
-		}
-		index++;
-	}
-
-	if(override) {
-		for(index=0;index<_reg_PHY_PAD_TERM_X_NUM;index++) {
-			dataL = ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PAD_TERM_X[index]);
-			dataL = (dataL & ~0x0001ffff) | term_code;
-			ddr_setval_ach(_reg_PHY_PAD_TERM_X[index], dataL);
-		}
-	} else if((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut==PRR_PRODUCT_10)) {
-		// non
-	} else {
-		ddr_setval_ach_as(_reg_PHY_IE_MODE,ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-		ddr_setval_ach(_reg_PHY_PAD_TERM_X[0],
-			(ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PAD_TERM_X[0]) & 0xFFFE0000));
-		ddr_setval_ach(_reg_PHY_CAL_CLEAR_0, 0x01);
-		ddr_setval_ach(_reg_PHY_CAL_START_0, 0x01);
-		foreach_vch(ch){
-			do {
-				dataL = ddr_getval(ch, _reg_PHY_CAL_RESULT2_OBS_0);
-			} while(!(dataL&0x00800000));
-		}
-		if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-			foreach_vch(ch){
-				uint32_t pvtr;
-				uint32_t pvtp;
-				uint32_t pvtn;
-				dataL = ddr_getval(ch, _reg_PHY_PAD_TERM_X[0]);
-				pvtr = (dataL >> 12) & 0x1f;
-				pvtr += 8;
-				if(pvtr>0x1f)
-					pvtr = 0x1f;
-				dataL = ddr_getval(ch, _reg_PHY_CAL_RESULT2_OBS_0);
-				pvtn = (dataL >> 6) & 0x03f;
-				pvtp = (dataL >> 0) & 0x03f;
-
-				for(index=0;index<_reg_PHY_PAD_TERM_X_NUM;index++) {
-					dataL = ddrtbl_getval(_cnf_DDR_PHY_ADR_G_REGSET, _reg_PHY_PAD_TERM_X[index]);
-					dataL = (dataL & ~0x0001ffff)
-						| (pvtr<<12)
-						| (pvtn<< 6)
-						| (pvtp);
-					ddr_setval(ch, _reg_PHY_PAD_TERM_X[index],dataL);
-				}
-			}
-		} else { // M3-W Ver.1.1 or later/H3 Ver.2.0 or later/M3-N/V3H
-			foreach_vch(ch){
-				for(index=0;index<_reg_PHY_PAD_TERM_X_NUM;index++) {
-					dataL = ddr_getval(ch, _reg_PHY_PAD_TERM_X[index]);
-					ddr_setval(ch, _reg_PHY_PAD_TERM_X[index], (dataL & 0xFFFE0FFF) | 0x00015000);
-				}
-			}
-		}
-	}
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		// non
-	} else {
-		ddr_padcal_tcompensate_getinit(override);
-	}
-	return 0;
-}
-
-/*******************************************************************************
- *	DDR mode register setting
- ******************************************************************************/
-static void ddr_register_set(uint32_t ch)
-{
-	int32_t fspwp;
-	uint32_t chind;
-	uint32_t tmp;
-
-	chind = ch<<20;
-	for(fspwp=1;fspwp>=0;fspwp--){
-		/*MR13,fspwp*/
-		send_dbcmd(0x0e040d08|chind|(fspwp<<6));
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR1_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040100|chind|tmp);
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR2_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040200|chind|tmp);
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR3_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040300|chind|tmp);
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR11_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040b00|chind|tmp);
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR12_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040c00|chind|tmp);
-
-		tmp = ddrtbl_getval(_cnf_DDR_PI_REGSET, _reg_PI_MR14_DATA_Fx_CSx[fspwp][0]);
-		send_dbcmd(0x0e040e00|chind|tmp);
-		/* MR22 */
-		send_dbcmd(0x0e041600|chind|0x16);
-	}
-}
-
-/*******************************************************************************
- *	Training handshake functions
- ******************************************************************************/
-static inline uint32_t wait_freqchgreq(uint32_t assert)
-{
-	uint32_t dataL;
-	uint32_t count;
-	uint32_t ch;
-	count = 100000;
-
-	/* H3 Ver.1.x cannot see frqchg_req */
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		return 0;
-	}
-
-	if(assert) {
-		do {
-			dataL = 1;
-			foreach_vch(ch){
-				dataL &= mmio_read_32(DBSC_DBPDSTAT(ch));
-			}
-			count = count -1;
-		} while( ((dataL&0x01)!=0x01) & (count !=0));
-	} else {
-		do {
-			dataL = 0;
-			foreach_vch(ch){
-				dataL |= mmio_read_32(DBSC_DBPDSTAT(ch));
-			}
-			count = count -1;
-		} while( ((dataL&0x01)!=0x00) & (count !=0));
-	}
-
-	return (count==0);
-}
-
-static inline void set_freqchgack(uint32_t assert)
-{
-	uint32_t ch;
-	uint32_t dataL;
-	if(assert)
-		dataL = 0x0CF20000;
-	else
-		dataL = 0x00000000;
-
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDCNT2(ch), dataL);
-}
-
-static inline void set_dfifrequency(uint32_t freq)
-{
-	uint32_t ch;
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		foreach_vch(ch)
-			mmio_clrsetbits_32(DBSC_DBPDCNT1(ch), 0x1fU, freq);
-	} else {
-		foreach_vch(ch){
-			mmio_clrsetbits_32(DBSC_DBDFICNT(ch), 0x1fU<<24, (freq << 24));
-		}
-	}
-	dsb_sev();
-}
-
-static uint32_t pll3_freq(uint32_t on)
-{
-	uint32_t timeout;
-
-	timeout = wait_freqchgreq(1);
-
-	if(timeout) {
-		return (1);
-	}
-
-	pll3_control(on);
-	set_dfifrequency(on);
-
-	set_freqchgack(1);
-	timeout = wait_freqchgreq(0);
-	set_freqchgack(0);
-
-	if(timeout) {
-		FATAL_MSG("Time out[2]");
-		return (1);
-	}
-	return (0);
-}
-
-/*******************************************************************************
- *	update dly
- ******************************************************************************/
-static void update_dly(void)
-{
-	ddr_setval_ach(_reg_SC_PHY_MANUAL_UPDATE, 0x01);
-	ddr_setval_ach(_reg_PHY_ADRCTL_MANUAL_UPDATE, 0x01);
-}
-
-/*******************************************************************************
- *	training by pi
- ******************************************************************************/
-static uint32_t pi_training_go(void)
-{
-	uint32_t flag;
-	uint32_t dataL;
-	uint32_t retry;
-	const uint32_t RETRY_MAX = 4096*16;
-	uint32_t ch;
-
-	uint32_t mst_ch;
-	uint32_t cur_frq;
-	uint32_t complete;
-	uint32_t frqchg_req;
-
-	/* ********************************************************************* */
-
-	/***********************************************************************
-	pi_start
-	***********************************************************************/
-	ddr_setval_ach(_reg_PI_START, 0x01);
-	foreach_vch(ch)
-		ddr_getval( ch, _reg_PI_INT_STATUS);
-
-	/* set dfi_phymstr_ack = 1 */
-	mmio_write_32(DBSC_DBDFIPMSTRCNF, 0x00000001);
-	dsb_sev();
-
-	/***********************************************************************
-	wait pi_int_status[0]
-	***********************************************************************/
-	mst_ch=0;
-	flag=0;
-	complete=0;
-	cur_frq=0;
-	retry=RETRY_MAX;
-	do {
-		frqchg_req = mmio_read_32(DBSC_DBPDSTAT(mst_ch)) & 0x01;
-
-		/* H3 Ver.1.x cannot see frqchg_req */
-		if((Prr_Product==PRR_PRODUCT_H3)
-		&& (Prr_Cut<=PRR_PRODUCT_11)) {
-			if((retry%4096)==1) {
-				frqchg_req = 1;
-			} else {
-				frqchg_req = 0;
-			}
-		}
-
-		if(frqchg_req){
-			if(cur_frq){
-				/* Low frequency*/
-				flag=pll3_freq(0);
-				cur_frq=0;
-			} else {
-				/* High frequency*/
-				flag=pll3_freq(1);
-				cur_frq=1;
-			}
-			if(flag)break;
-		} else {
-			if(cur_frq){
-				foreach_vch(ch){
-					if(complete & (1U<<ch))continue;
-					dataL= ddr_getval( ch, _reg_PI_INT_STATUS);
-					if(dataL & 0x01){
-						complete |= (1U<<ch);
-					}
-				}
-				if(complete==ddr_phyvalid)break;
-			}
-		}
-	} while(--retry);
-	foreach_vch(ch){
-		/* dummy read */
-		dataL = ddr_getval_s(ch, 0,_reg_PHY_CAL_RESULT2_OBS_0);
-		dataL = ddr_getval(ch, _reg_PI_INT_STATUS);
-		ddr_setval(ch, _reg_PI_INT_ACK, dataL);
-	}
-	if(ddrphy_regif_chk()){
-		return(0xfd);
-	}
-	return complete;
-}
-
-/*******************************************************************************
- *	Initialize ddr
- ******************************************************************************/
-static uint32_t init_ddr(void)
-{
-	int32_t	i;
-	uint32_t dataL;
-	uint32_t phytrainingok;
-	uint32_t ch;
-	uint32_t err;
-
-	MSG_LF("init_ddr:0\n");
-
-#ifdef DDR_BACKUPMODE
-	dram_get_boot_status(&ddrBackup);
-#endif
-
-	/***********************************************************************
-	unlock phy
-	***********************************************************************/
-	/* Unlock DDRPHY register(AGAIN) */
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDLK(ch), 0x0000A55A);
-	dsb_sev();
-
-	if ((((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-	   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H))&&(Boardcnf->dbi_en))
-		reg_ddrphy_write_a(0x00001010, 0x01000001);
-	else
-		reg_ddrphy_write_a(0x00001010, 0x00000001);
-	/***********************************************************************
-	dbsc register pre-setting
-	***********************************************************************/
-	dbsc_regset_pre();
-
-	/***********************************************************************
-	load ddrphy registers
-	***********************************************************************/
-
-	ddrtbl_load();
-
-	/***********************************************************************
-	configure ddrphy registers
-	***********************************************************************/
-	ddr_config();
-
-	/***********************************************************************
-	dfi_reset assert
-	***********************************************************************/
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDCNT0(ch), 0x01);
-	dsb_sev();
-
-	/***********************************************************************
-	dbsc register set
-	***********************************************************************/
-	dbsc_regset();
-	MSG_LF("init_ddr:1\n");
-
-	/***********************************************************************
-	dfi_reset negate
-	***********************************************************************/
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDCNT0(ch), 0x00);
-	dsb_sev();
-
-	/***********************************************************************
-	dfi_init_start (start ddrphy)
-	***********************************************************************/
-	err=dfi_init_start();
-	if(err){
-		return INITDRAM_ERR_I;
-	}
-	MSG_LF("init_ddr:2\n");
-
-	/***********************************************************************
-	ddr backupmode end
-	***********************************************************************/
-#ifdef DDR_BACKUPMODE
-	if(ddrBackup) {
-		NOTICE("[WARM_BOOT]");
-	} else {
-		NOTICE("[COLD_BOOT]");
-	}
-	err=dram_update_boot_status(ddrBackup);
-	if(err){
-		NOTICE("[BOOT_STATUS_UPDATE_ERROR]");
-		return INITDRAM_ERR_I;
-	}
-#endif
-	MSG_LF("init_ddr:3\n");
-
-	/***********************************************************************
-	override term code after dfi_init_complete
-	***********************************************************************/
-	err=set_term_code();
-	if(err){
-		return INITDRAM_ERR_I;
-	}
-	MSG_LF("init_ddr:4\n");
-
-	/***********************************************************************
-	rx offset calibration
-	***********************************************************************/
-	if ((Prr_Cut> PRR_PRODUCT_11)||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		err = rx_offset_cal_hw();
-	} else {
-		err = rx_offset_cal();
-	}
-	if(err)return(INITDRAM_ERR_O);
-	MSG_LF("init_ddr:5\n");
-
-	/***********************************************************************
-	set ie_mode=1
-	***********************************************************************/
-	ddr_setval_ach_as(_reg_PHY_IE_MODE,ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-
-	/***********************************************************************
-	check register i/f is alive
-	***********************************************************************/
-	err = ddrphy_regif_chk();
-	if(err) {
-		return(INITDRAM_ERR_O);
-	}
-	MSG_LF("init_ddr:6\n");
-
-	/***********************************************************************
-	phy initialize end
-	***********************************************************************/
-
-	/***********************************************************************
-	setup DDR mode registers
-	***********************************************************************/
-	/* CMOS MODE */
-	change_lpddr4_en(0);
-
-	ch=0x08;
-
-	/* PDE */
-	send_dbcmd(0x08040000|(0x00100000 * ch));
-
-	/* PDX */
-	send_dbcmd(0x08040001|(0x00100000 * ch));
-
-	/* MR22 (ODTCS & RQZ */
-	send_dbcmd(0x0e041600|(0x00100000 * ch)|0x16);
-
-	/* ZQCAL start */
-	send_dbcmd(0x0d04004F|(0x00100000 * ch));
-	micro_wait(100);
-
-	/* ZQLAT */
-	send_dbcmd(0x0d040051|(0x00100000 * ch));
-
-	/***********************************************************************
-	Thermal sensor setting
-	***********************************************************************/
-	/* THCTR Bit6: PONM=0 , Bit0: THSST=1	*/
-	dataL = ((*((volatile uint32_t*)THS1_THCTR)) & 0xFFFFFFBF) | 0x00000001;
-	*((volatile uint32_t*)THS1_THCTR) = dataL;
-
-	/***********************************************************************
-	setup DDR mode registers
-	***********************************************************************/
-	foreach_vch(ch) {
-		ddr_register_set(ch);
-	}
-	/* LPDDR4 MODE */
-	change_lpddr4_en(1);
-
-	MSG_LF("init_ddr:7\n");
-
-	/***********************************************************************
-	mask CS_MAP if RANKx is not found
-	***********************************************************************/
-	foreach_vch(ch){
-		dataL = ddr_getval(ch, _reg_PI_CS_MAP);
-		if(!(ch_have_this_cs[0] & (1U<<ch))) dataL = dataL & 0x0a;
-		if(!(ch_have_this_cs[1] & (1U<<ch))) dataL = dataL & 0x05;
-		ddr_setval(ch, _reg_PI_CS_MAP, dataL);
-	}
-
-	/***********************************************************************
-	exec pi_training
-	***********************************************************************/
-	ddr_setval_ach_as(_reg_PHY_PER_CS_TRAINING_MULTICAST_EN, 0x00);
-	ddr_setval_ach_as(_reg_PHY_PER_CS_TRAINING_EN, 0x01);
-
-	phytrainingok = pi_training_go();
-
-	if(ddr_phyvalid != (phytrainingok & ddr_phyvalid)) {
-		return(INITDRAM_ERR_T|phytrainingok);
-	}
-
-	MSG_LF("init_ddr:8\n");
-
-	/***********************************************************************
-	CACS DLY ADJUST
-	***********************************************************************/
-	dataL = Boardcnf->cacs_dly + _f_scale_adj(Boardcnf->cacs_dly_adj);
-	foreach_vch(ch){
-		int16_t adj;
-		for(i=0;i<_reg_PHY_CLK_CACS_SLAVE_DELAY_X_NUM;i++){
-			adj = _f_scale_adj(Boardcnf->ch[ch].cacs_adj[i]);
-			ddr_setval(ch, _reg_PHY_CLK_CACS_SLAVE_DELAY_X[i],
-				dataL + adj
-			);
-		}
-	}
-	update_dly();
-	MSG_LF("init_ddr:9\n");
-
-	/***********************************************************************
-	H3 fix rd latency to avoid bug in elasitic buffe
-	***********************************************************************/
-	if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		adjust_rddqs_latency();
-	}
-
-	/***********************************************************************
-	Adjust Write path latency
-	***********************************************************************/
-	if(ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_WRITE_PATH_LAT_ADD))
-		adjust_wpath_latency();
-
-	/***********************************************************************
-	RDQLVL Training
-	***********************************************************************/
-	if ((Prr_Product==PRR_PRODUCT_H3)||(Prr_Product==PRR_PRODUCT_M3)) {
-		ddr_setval_ach_as(_reg_PHY_IE_MODE, 0x01);
-	} else {
-		ddr_setval_ach_as(_reg_PHY_IE_MODE,ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-	}
-
-	err=rdqdm_man();
-	if(err) {
-		return(INITDRAM_ERR_T);
-	}
-	update_dly();
-	MSG_LF("init_ddr:10\n");
-
-	/***********************************************************************
-	WDQLVL Training
-	***********************************************************************/
-	err=wdqdm_man();
-	if(err) {
-		return(INITDRAM_ERR_T);
-	}
-	update_dly();
-	MSG_LF("init_ddr:11\n");
-
-	/***********************************************************************
-	training complete, setup dbsc
-	***********************************************************************/
-	if (((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-	   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		ddr_setval_ach_as(_reg_PHY_DFI40_POLARITY, 0x00);
-		ddr_setval_ach(_reg_PI_DFI40_POLARITY, 0x00);
-	}
-
-	dbsc_regset_post();
-	MSG_LF("init_ddr:12\n");
-
-	return phytrainingok;
-}
-
-/*******************************************************************************
- *	SW LEVELING COMMON
- ******************************************************************************/
-static uint32_t swlvl1(uint32_t ddr_csn, uint32_t reg_cs, uint32_t reg_kick)
-{
-	uint32_t ch;
-	uint32_t dataL;
-	uint32_t retry;
-	uint32_t waiting;
-	uint32_t err;
-
-	const uint32_t RETRY_MAX=0x1000;
-
-	err=0;
-	/* set EXIT -> OP_DONE is cleared */
-	ddr_setval_ach(_reg_PI_SWLVL_EXIT, 0x01);
-
-	/* kick */
-	foreach_vch(ch){
-		if(ch_have_this_cs[ddr_csn%2] & (1U<<ch)){
-			ddr_setval(ch, reg_cs, ddr_csn);
-			ddr_setval(ch, reg_kick, 0x01);
-		}
-	}
-	foreach_vch(ch){
-		/*PREPARE ADDR REGISTER (for SWLVL_OP_DONE)*/
-		ddr_getval( ch, _reg_PI_SWLVL_OP_DONE);
-	}
-	waiting=ch_have_this_cs[ddr_csn%2];
-	dsb_sev();
-	retry=RETRY_MAX;
-	do {
-		foreach_vch(ch){
-			if(!(waiting&(1U<<ch)))
-				continue;
-			dataL= ddr_getval( ch, _reg_PI_SWLVL_OP_DONE);
-			if(dataL&0x01)	waiting&=~(1U<<ch);
-		}
-		retry--;
-	} while (waiting && (retry>0));
-	if(retry==0){
-		err=1;
-	}
-
-	dsb_sev();
-	/* set EXIT -> OP_DONE is cleared */
-	ddr_setval_ach(_reg_PI_SWLVL_EXIT, 0x01);
-	dsb_sev();
-
-	return err;
-}
-
-/*******************************************************************************
- *	WDQ TRAINING
- ******************************************************************************/
-static void wdqdm_clr1(uint32_t ch, uint32_t ddr_csn)
-{
-	int32_t i,k;
-	uint32_t cs,slice;
-	uint32_t dataL;
-
-	/***********************************************************************
-	clr of training results buffer
-	***********************************************************************/
-	cs = ddr_csn%2;
-	dataL = Boardcnf->dqdm_dly_w;
-	for(slice=0;slice<SLICE_CNT;slice++){
-		k=(Boardcnf->ch[ch].dqs_swap>>(4*slice))&0x0f;
-		if(((k>=2) && (ddr_csn<2)) || ((k<2) && (ddr_csn>=2)))continue;
-
-		for(i=0;i<=8;i++){
-			if(ch_have_this_cs[CS_CNT-1-cs]&(1U<<ch))
-				wdqdm_dly[ch][cs][slice][i]=wdqdm_dly[ch][CS_CNT-1-cs][slice][i];
-			else
-				wdqdm_dly[ch][cs][slice][i]=dataL;
-			wdqdm_le[ch][cs][slice][i]=0;
-			wdqdm_te[ch][cs][slice][i]=0;
-		}
-		wdqdm_st[ch][cs][slice]=0;
-		wdqdm_win[ch][cs][slice]=0;
-	}
-}
-
-static uint32_t wdqdm_ana1(uint32_t ch, uint32_t ddr_csn)
-{
-	int32_t i,k;
-	uint32_t cs,slice;
-	uint32_t dataL;
-	uint32_t err;
-	const uint32_t _par_WDQLVL_RETRY_THRES=0x7c0;
-
-	int32_t min_win;
-	int32_t win;
-	int8_t _adj;
-	int16_t adj;
-	uint32_t dq;
-
-	/***********************************************************************
-	analysis of training results
-	***********************************************************************/
-	err = 0;
-	for(slice=0;slice<SLICE_CNT;slice+=1){
-		k=(Boardcnf->ch[ch].dqs_swap>>(4*slice)) & 0x0f;
-		if(((k>=2) && (ddr_csn<2)) || ((k<2) && (ddr_csn>=2)))continue;
-
-		cs = ddr_csn%2;
-		ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX, cs);
-		ddr_getval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX);
-		for(i=0;i<9;i++){
-			dq = slice*8+i;
-			if(i==8)
-				_adj = Boardcnf->ch[ch].dm_adj_w[slice];
-			else
-				_adj = Boardcnf->ch[ch].dq_adj_w[dq];
-			adj = _f_scale_adj(_adj);
-
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_CLK_WRX_SLAVE_DELAY[i])+adj;
-			ddr_setval_s(ch, slice, _reg_PHY_CLK_WRX_SLAVE_DELAY[i], dataL);
-			wdqdm_dly[ch][cs][slice][i]  =dataL;
-		}
-		ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_EN, 0x00);
-		dataL = ddr_getval_s(ch, slice, _reg_PHY_WDQLVL_STATUS_OBS);
-		wdqdm_st[ch][cs][slice] = dataL;
-		min_win=INT_LEAST32_MAX;
-		for(i=0;i<=8;i++){
-			ddr_setval_s(ch, slice, _reg_PHY_WDQLVL_DQDM_OBS_SELECT, i);
-
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_WDQLVL_DQDM_TE_DLY_OBS);
-			wdqdm_te[ch][cs][slice][i] = dataL;
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_WDQLVL_DQDM_LE_DLY_OBS);
-			wdqdm_le[ch][cs][slice][i] = dataL;
-			win=(int32_t)wdqdm_te[ch][cs][slice][i]-wdqdm_le[ch][cs][slice][i];
-			if(min_win>win)
-				min_win=win;
-			if( dataL >= _par_WDQLVL_RETRY_THRES) err = 2;
-		}
-		wdqdm_win[ch][cs][slice] = min_win;
-		ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_EN, 0x01);
-	}
-	return err;
-}
-
-static void wdqdm_cp(uint32_t ddr_csn, uint32_t restore) {
-	uint32_t i;
-	uint32_t ch,slice;
-	uint32_t tgt_cs,src_cs;
-	uint32_t tmp_r;
-
-	/***********************************************************************
-	copy of training results
-	***********************************************************************/
-	foreach_vch(ch){
-		for(tgt_cs=0;tgt_cs<CS_CNT;tgt_cs++) {
-			for(slice=0;slice<SLICE_CNT;slice++){
-				ddr_setval_s(ch,slice,_reg_PHY_PER_CS_TRAINING_INDEX, tgt_cs);
-				src_cs = ddr_csn%2;
-				if(!(ch_have_this_cs[1] & (1U<<ch)))
-					src_cs = 0;
-				for(i=0;i<=4;i+=4){
-					if(restore)
-						tmp_r = rdqdm_dly[ch][tgt_cs][slice][i];
-					else
-						tmp_r = rdqdm_dly[ch][src_cs][slice][i];
-
-					ddr_setval_s(ch, slice, _reg_PHY_RDDQS_X_RISE_SLAVE_DELAY[i], tmp_r);
-				}
-			}
-		}
-	}
-}
-
-static uint32_t wdqdm_man1(void)
-{
-	int32_t k;
-	uint32_t ch,cs,slice;
-	uint32_t ddr_csn;
-	uint32_t dataL;
-	uint32_t err;
-	uint32_t err_flg;
-
-	/***********************************************************************
-	manual execution of training
-	***********************************************************************/
-	uint32_t high_dq[DRAM_CH_CNT];
-	uint32_t mr14_csab0_bak[DRAM_CH_CNT];
-
-	foreach_vch(ch){
-		high_dq[ch]=0;
-		for(slice=0;slice<SLICE_CNT;slice++) {
-			k=(Boardcnf->ch[ch].dqs_swap>>(4*slice)) & 0x0f;
-			if(k>=2)
-				high_dq[ch]|=(1U<<slice);
-		}
-	}
-
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-		ddr_setval_ach(_reg_PI_16BIT_DRAM_CONNECT, 0x00);
-
-	err=0;
-	/* CLEAR PREV RESULT */
-	for(cs=0;cs<CS_CNT;cs++) {
-		ddr_setval_ach_as(_reg_PHY_PER_CS_TRAINING_INDEX, cs);
-		if (((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-		   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-			ddr_setval_ach_as(_reg_SC_PHY_WDQLVL_CLR_PREV_RESULTS, 0x01);
-		} else {
-			ddr_setval_ach_as(_reg_PHY_WDQLVL_CLR_PREV_RESULTS, 0x01);
-		}
-	}
-	ddrphy_regif_idle();
-
-	err_flg=0;
-
-	for(ddr_csn=0;ddr_csn<CSAB_CNT;ddr_csn++) {
-		if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-			foreach_vch(ch){
-				dataL = mmio_read_32(DBSC_DBDFICNT(ch));
-				dataL &= ~(0x00ffU<<16);
-
-				if(ddr_csn>=2)
-					k = (high_dq[ch]^0x0f);
-				else
-					k =  high_dq[ch];
-				dataL |= (k<<16);
-				mmio_write_32(DBSC_DBDFICNT(ch), dataL);
-				ddr_setval(ch, _reg_PI_WDQLVL_RESP_MASK, k);
-			}
-		}
-		if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-		 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut==PRR_PRODUCT_10))) {
-			wdqdm_cp(ddr_csn, 0);
-		}
-
-		foreach_vch(ch){
-			dataL = ddr_getval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][ddr_csn]);
-			ddr_setval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][0],dataL);
-		}
-
-		/* KICK WDQLVL */
-		err = swlvl1(ddr_csn, _reg_PI_WDQLVL_CS, _reg_PI_WDQLVL_REQ);
-		if(err)
-			goto err_exit;
-
-		if(ddr_csn==0)
-			foreach_vch(ch){
-				mr14_csab0_bak[ch] = ddr_getval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][0]);
-			}
-		else
-			foreach_vch(ch){
-				ddr_setval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][0],mr14_csab0_bak[ch]);
-			}
-		foreach_vch(ch){
-			if(!(ch_have_this_cs[ddr_csn%2] & (1U<<ch))) {
-				wdqdm_clr1(ch, ddr_csn);
-				continue;
-			}
-			err = wdqdm_ana1(ch, ddr_csn);
-			if(err)
-				err_flg |= (1U<<(ddr_csn*4+ch));
-			ddrphy_regif_idle();
-		}
-	}
-err_exit:
-	ddr_setval_ach(_reg_PI_16BIT_DRAM_CONNECT, 0x01);
-	foreach_vch(ch){
-		dataL = mmio_read_32(DBSC_DBDFICNT(ch));
-		dataL &= ~(0x00ffU<<16);
-		mmio_write_32(DBSC_DBDFICNT(ch), dataL);
-		ddr_setval(ch, _reg_PI_WDQLVL_RESP_MASK, 0x00);
-	}
-	return (err_flg|err);
-}
-
-static uint32_t wdqdm_man(void)
-{
-	uint32_t err,retry_cnt;
-	const uint32_t retry_max=0x10;
-
-	ddr_setval_ach(_reg_PI_TDFI_WDQLVL_RW, (DBSC_DBTR(11)&0xFF) +12);
-	if (((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-	   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		ddr_setval_ach(_reg_PI_TDFI_WDQLVL_WR_F1, (DBSC_DBTR(12)&0xFF) +1);
-	} else {
-		ddr_setval_ach(_reg_PI_TDFI_WDQLVL_WR, (DBSC_DBTR(12)&0xFF) +1);
-	}
-	ddr_setval_ach(_reg_PI_TRFC_F1, (DBSC_DBTR(13)&0x1FF));
-
-	retry_cnt=0;
-	do {
-		if((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut<=PRR_PRODUCT_11)) {
-			err = wdqdm_man1();
-		} else {
-			uint32_t	ch,ddr_csn,mr14_bkup[4][4];
-
-			ddr_setval_ach(_reg_PI_WDQLVL_VREF_EN, 0x01);
-			ddr_setval_ach(_reg_PI_WDQLVL_VREF_NORMAL_STEPSIZE, 0x01);
-			if((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA_F1, 0x0C);
-			} else {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA, 0x0C);
-			}
-			dsb_sev();
-			err = wdqdm_man1();
-			foreach_vch(ch){
-				for(ddr_csn=0;ddr_csn<CSAB_CNT;ddr_csn++){
-					mr14_bkup[ch][ddr_csn] = ddr_getval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][ddr_csn]);
-					dsb_sev();
-				}
-			}
-
-			if((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA_F1, 0x04);
-			} else {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA, 0x04);
-			}
-			pvtcode_update();
-			err = wdqdm_man1();
-			foreach_vch(ch){
-				for(ddr_csn=0;ddr_csn<CSAB_CNT;ddr_csn++){
-					mr14_bkup[ch][ddr_csn] = (mr14_bkup[ch][ddr_csn] + ddr_getval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][ddr_csn]))/2;
-					ddr_setval(ch,_reg_PI_MR14_DATA_Fx_CSx[1][ddr_csn],mr14_bkup[ch][ddr_csn]);
-				}
-			}
-
-			ddr_setval_ach(_reg_PI_WDQLVL_VREF_NORMAL_STEPSIZE, 0x00);
-			if((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA_F1, 0x00);
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_INITIAL_START_POINT_F1, 0x00);
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_INITIAL_STOP_POINT_F1, 0x00);
-			} else {
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_DELTA, 0x00);
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_INITIAL_START_POINT, 0x00);
-				ddr_setval_ach(_reg_PI_WDQLVL_VREF_INITIAL_STOP_POINT, 0x00);
-			}
-			ddr_setval_ach(_reg_PI_WDQLVL_VREF_INITIAL_STEPSIZE, 0x00);
-
-			pvtcode_update2();
-			err = wdqdm_man1();
-			ddr_setval_ach(_reg_PI_WDQLVL_VREF_EN, 0x00);
-		}
-	} while(err && (++retry_cnt<retry_max));
-
-	if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-	 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut<=PRR_PRODUCT_10))) {
-		wdqdm_cp(0,1);
-	}
-
-	return (retry_cnt>=retry_max);
-}
-
-/*******************************************************************************
- *	RDQ TRAINING
- ******************************************************************************/
-static void rdqdm_clr1(uint32_t ch, uint32_t ddr_csn)
-{
-	int32_t i,k;
-	uint32_t cs,slice;
-	uint32_t dataL;
-
-	/***********************************************************************
-	clr of training results buffer
-	***********************************************************************/
-	cs = ddr_csn%2;
-	dataL = Boardcnf->dqdm_dly_r;
-	for(slice=0;slice<SLICE_CNT;slice++){
-		k=(Boardcnf->ch[ch].dqs_swap>>(4*slice))&0x0f;
-		if(((k>=2) && (ddr_csn<2)) || ((k<2) && (ddr_csn>=2)))continue;
-
-		for(i=0;i<=8;i++){
-			if(ch_have_this_cs[CS_CNT-1-cs]&(1U<<ch)) {
-				rdqdm_dly[ch][cs][slice][i]=
-				rdqdm_dly[ch][CS_CNT-1-cs][slice][i];
-				rdqdm_dly[ch][cs][slice+SLICE_CNT][i]=
-				rdqdm_dly[ch][CS_CNT-1-cs][slice+SLICE_CNT][i];
-			}
-			else {
-				rdqdm_dly[ch][cs][slice][i]=dataL;
-				rdqdm_dly[ch][cs][slice+SLICE_CNT][i]=dataL;
-			}
-			rdqdm_le[ch][cs][slice][i]=0;
-			rdqdm_le[ch][cs][slice+SLICE_CNT][i]=0;
-			rdqdm_te[ch][cs][slice][i]=0;
-			rdqdm_te[ch][cs][slice+SLICE_CNT][i]=0;
-			rdqdm_nw[ch][cs][slice][i]=0;
-			rdqdm_nw[ch][cs][slice+SLICE_CNT][i]=0;
-		}
-		rdqdm_st[ch][cs][slice]=0;
-		rdqdm_win[ch][cs][slice]=0;
-	}
-}
-
-static uint32_t rdqdm_ana1(uint32_t ch, uint32_t ddr_csn)
-{
-	int32_t i,k;
-	uint32_t cs,slice;
-	uint32_t dataL;
-	uint32_t err;
-	int8_t _adj;
-	int16_t adj;
-	uint32_t dq;
-
-	/***********************************************************************
-	analysis of training results
-	***********************************************************************/
-	err=0;
-	for(slice=0;slice<SLICE_CNT;slice++){
-		int32_t min_win;
-		int32_t win;
-		uint32_t rdq_status_obs_select;
-		k=(Boardcnf->ch[ch].dqs_swap>>(4*slice))&0x0f;
-		if(((k>=2) && (ddr_csn<2)) || ((k<2) && (ddr_csn>=2)))continue;
-
-		cs = ddr_csn%2;
-		ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX, cs);
-		ddrphy_regif_idle();
-
-		ddr_getval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX);
-		ddrphy_regif_idle();
-
-		for(i=0;i<=8;i++){
-			dq = slice*8+i;
-			if(i==8)
-				_adj = Boardcnf->ch[ch].dm_adj_r[slice];
-			else
-				_adj = Boardcnf->ch[ch].dq_adj_r[dq];
-
-			adj = _f_scale_adj(_adj);
-
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_RDDQS_X_RISE_SLAVE_DELAY[i])+adj;
-			ddr_setval_s(ch, slice, _reg_PHY_RDDQS_X_RISE_SLAVE_DELAY[i], dataL);
-			rdqdm_dly[ch][cs][slice][i]=dataL;
-
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_RDDQS_X_FALL_SLAVE_DELAY[i])+adj;
-			ddr_setval_s(ch, slice, _reg_PHY_RDDQS_X_FALL_SLAVE_DELAY[i], dataL);
-			rdqdm_dly[ch][cs][slice+SLICE_CNT][i]=dataL;
-		}
-		min_win=INT_LEAST32_MAX;
-		for(i=0;i<=8;i++){
-			dataL = ddr_getval_s(ch, slice, _reg_PHY_RDLVL_STATUS_OBS);
-			rdqdm_st[ch][cs][slice]=dataL;
-			rdqdm_st[ch][cs][slice+SLICE_CNT]=dataL;
-			/* k : rise/fall */
-			for(k=0;k<2;k++){
-				if(i==8){
-					rdq_status_obs_select = 16+8*k;
-				} else {
-					rdq_status_obs_select = i+k*8;
-				}
-				ddr_setval_s(ch, slice, _reg_PHY_RDLVL_RDDQS_DQ_OBS_SELECT, rdq_status_obs_select);
-
-				dataL = ddr_getval_s(ch, slice, _reg_PHY_RDLVL_RDDQS_DQ_LE_DLY_OBS);
-				rdqdm_le[ch][cs][slice+SLICE_CNT*k][i]=dataL;
-
-				dataL = ddr_getval_s(ch, slice, _reg_PHY_RDLVL_RDDQS_DQ_TE_DLY_OBS);
-				rdqdm_te[ch][cs][slice+SLICE_CNT*k][i]=dataL;
-
-				dataL = ddr_getval_s(ch, slice, _reg_PHY_RDLVL_RDDQS_DQ_NUM_WINDOWS_OBS);
-				rdqdm_nw[ch][cs][slice+SLICE_CNT*k][i]=dataL;
-
-				win=(int32_t)rdqdm_te[ch][cs][slice+SLICE_CNT*k][i]-rdqdm_le[ch][cs][slice+SLICE_CNT*k][i];
-				if(i!=8){
-					if(min_win>win)
-						min_win=win;
-				}
-			}
-		}
-		rdqdm_win[ch][cs][slice]=min_win;
-		if(min_win<=0) {
-			err = 2;
-		}
-	}
-	return(err);
-}
-
-static uint32_t rdqdm_man1(void)
-{
-	uint32_t ch;
-	uint32_t ddr_csn;
-	uint32_t err;
-
-	/***********************************************************************
-	manual execution of training
-	***********************************************************************/
-	err = 0;
-
-	for(ddr_csn=0;ddr_csn<CSAB_CNT;ddr_csn++) {
-		/* KICK RDQLVL */
-		err = swlvl1(ddr_csn, _reg_PI_RDLVL_CS, _reg_PI_RDLVL_REQ);
-		if(err)goto err_exit;
-
-		foreach_vch(ch){
-			if(!(ch_have_this_cs[ddr_csn%2] & (1U<<ch))) {
-				rdqdm_clr1(ch, ddr_csn);
-				ddrphy_regif_idle();
-				continue;
-			}
-			err = rdqdm_ana1(ch, ddr_csn);
-			ddrphy_regif_idle();
-			if(err)
-				goto err_exit;
-		}
-	}
-err_exit:
-	return(err);
-}
-
-static uint32_t rdqdm_man(void)
-{
-	uint32_t err,retry_cnt;
-	const uint32_t retry_max=0x01;
-
-	ddr_setval_ach_as(_reg_PHY_DQ_TSEL_ENABLE,
-		0x00000004 | ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQ_TSEL_ENABLE));
-	ddr_setval_ach_as(_reg_PHY_DQS_TSEL_ENABLE,
-		0x00000004 | ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQS_TSEL_ENABLE));
-	ddr_setval_ach_as(_reg_PHY_DQ_TSEL_SELECT,
-		0xFF0FFFFF & ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQ_TSEL_SELECT));
-	ddr_setval_ach_as(_reg_PHY_DQS_TSEL_SELECT,
-		0xFF0FFFFF & ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQS_TSEL_SELECT));
-
-	retry_cnt=0;
-	do {
-		err = rdqdm_man1();
-		ddrphy_regif_idle();
-	} while(err && (++retry_cnt<retry_max));
-	ddr_setval_ach_as(_reg_PHY_DQ_TSEL_ENABLE,
-		ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQ_TSEL_ENABLE));
-	ddr_setval_ach_as(_reg_PHY_DQS_TSEL_ENABLE,
-		ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQS_TSEL_ENABLE));
-	ddr_setval_ach_as(_reg_PHY_DQ_TSEL_SELECT,
-		ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQ_TSEL_SELECT));
-	ddr_setval_ach_as(_reg_PHY_DQS_TSEL_SELECT,
-		ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET,_reg_PHY_DQS_TSEL_SELECT));
-
-	return (retry_cnt>=retry_max);
-}
-
-/*******************************************************************************
- *	rx offset calibration
- ******************************************************************************/
-static int32_t _find_change(uint64_t val, uint32_t dir)
-{
-	int32_t i;
-	uint32_t startval;
-	uint32_t curval;
-	const uint32_t VAL_END=0x3f;
-
-	if(dir==0) {
-		startval=(val&0x01);
-		for(i=1;i<=VAL_END;i++) {
-			curval=(val>>i) & 0x01;
-			if(curval!=startval)
-				return(i);
-		}
-		return(VAL_END);
-	} else {
-		startval=(val>>dir)&0x01;
-		for(i=dir-1;i>=0;i--) {
-			curval=(val>>i) & 0x01;
-			if(curval!=startval)
-				return(i);
-		}
-		return(0);
-	}
-}
-
-static uint32_t _rx_offset_cal_updn(uint32_t code)
-{
-	const uint32_t CODE_MAX=0x40;
-	uint32_t tmp;
-
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-		if(code==0)
-			tmp = (1U<<6) | (CODE_MAX-1);
-		else if(code<=0x20)
-			tmp = ((CODE_MAX-1-(0x20-code)*2)<<6) | (CODE_MAX-1);
-		else
-			tmp = ((CODE_MAX-1)<<6) | (CODE_MAX-1-(code-0x20)*2);
-	} else {
-		if(code==0)
-			tmp = (1U<<6) | (CODE_MAX-1);
-		else
-			tmp = (code<<6) | (CODE_MAX-code);
-	}
-	return tmp;
-}
-
-//#define RX_OFFSET_FAST
-static uint32_t rx_offset_cal(void)
-{
-	uint32_t index;
-	uint32_t code;
-	const uint32_t CODE_MAX=0x40;
-	const uint32_t CODE_STEP=2;
-	uint32_t ch, slice;
-	uint32_t tmp;
-	uint32_t tmp_ach_as[DRAM_CH_CNT][SLICE_CNT];
-	uint64_t val[DRAM_CH_CNT][SLICE_CNT][_reg_PHY_RX_CAL_X_NUM];
-#ifdef RX_OFFSET_FAST
-	uint32_t adr_st;
-	adr_st=ddr_regdef_adr(_reg_PHY_RX_CAL_X[0]);
-#endif
-	ddr_setval_ach_as(_reg_PHY_IE_MODE, 0x01);
-	ddr_setval_ach_as(_reg_PHY_RX_CAL_OVERRIDE, 0x01);
-	foreach_vch(ch){
-		for(slice=0; slice<SLICE_CNT; slice++) {
-			for(index=0;index<_reg_PHY_RX_CAL_X_NUM;index++) {
-				val[ch][slice][index] = 0;
-			}
-		}
-	}
-
-	for(code=0;code<CODE_MAX/CODE_STEP;code++) {
-		tmp = _rx_offset_cal_updn(code*CODE_STEP);
-#ifdef RX_OFFSET_FAST
-		tmp=tmp|(tmp<<16);
-		for(index=0;index<(_reg_PHY_RX_CAL_X_NUM+1)/2;index++) {
-			for(slice=0;slice<4;slice++)
-				reg_ddrphy_write_a(adr_st+0x80*slice+index,tmp);
-		}
-#else
-		for(index=0;index<_reg_PHY_RX_CAL_X_NUM;index++) {
-			ddr_setval_ach_as(_reg_PHY_RX_CAL_X[index], tmp);
-		}
-#endif
-		dsb_sev();
-		ddr_getval_ach_as(_reg_PHY_RX_CAL_OBS, (uint32_t *)tmp_ach_as);
-
-		foreach_vch(ch){
-			for(slice=0; slice<SLICE_CNT; slice++) {
-				tmp=tmp_ach_as[ch][slice];
-				for(index=0;index<_reg_PHY_RX_CAL_X_NUM;index++) {
-					if(tmp & (1U<<index)) {
-						val[ch][slice][index] |= (1ULL<<code);
-					} else {
-						val[ch][slice][index] &= ~(1ULL<<code);
-					}
-				}
-			}
-		}
-	}
-	foreach_vch(ch){
-		for(slice=0; slice<SLICE_CNT; slice++) {
-			for(index=0;index<_reg_PHY_RX_CAL_X_NUM;index++) {
-				uint64_t tmpval;
-				int32_t lsb,msb;
-				tmpval = val[ch][slice][index];
-				lsb = _find_change(tmpval, 0);
-				msb = _find_change(tmpval, (CODE_MAX/CODE_STEP)-1);
-				tmp = (lsb+msb)>>1;
-
-				tmp = _rx_offset_cal_updn(tmp*CODE_STEP);
-				ddr_setval_s(ch, slice, _reg_PHY_RX_CAL_X[index], tmp);
-			}
-		}
-	}
-	ddr_setval_ach_as(_reg_PHY_RX_CAL_OVERRIDE, 0x00);
-	ddr_setval_ach_as(_reg_PHY_IE_MODE, ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-
-	return 0;
-}
-
-static uint32_t rx_offset_cal_hw(void) {
-	uint32_t ch, slice;
-	uint32_t retry;
-	uint32_t complete;
-	uint32_t tmp;
-	uint32_t tmp_ach_as[DRAM_CH_CNT][SLICE_CNT];
-
-	ddr_setval_ach_as(_reg_PHY_IE_MODE, 0x01);
-	ddr_setval_ach_as(_reg_PHY_RX_CAL_X[9], 0x00);
-	ddr_setval_ach_as(_reg_PHY_RX_CAL_OVERRIDE, 0x00);
-	ddr_setval_ach_as(_reg_PHY_RX_CAL_SAMPLE_WAIT, 0x0f);
-
-	retry = 0;
-	while(retry<4096) {
-		if((retry & 0xff) == 0) {
-			ddr_setval_ach_as(_reg_SC_PHY_RX_CAL_START, 0x01);
-		}
-		foreach_vch(ch)
-			for(slice=0; slice<SLICE_CNT; slice++)
-				tmp_ach_as[ch][slice] = ddr_getval_s(ch, slice,_reg_PHY_RX_CAL_X[9]);
-
-		complete = 1;
-		foreach_vch(ch){
-			for(slice=0;slice<SLICE_CNT;slice++) {
-				tmp = tmp_ach_as[ch][slice];
-				tmp = (tmp&0x3f) + ((tmp>>6)&0x3f);
-				if (((Prr_Product==PRR_PRODUCT_H3 )&&(Prr_Cut> PRR_PRODUCT_11))
-				   ||(Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-					if(tmp!=0x3E)complete=0;
-				} else {
-					if(tmp!=0x40)complete=0;
-				}
-			}
-		}
-		if(complete)break;
-
-		retry++;
-	}
-	ddr_setval_ach_as(_reg_PHY_IE_MODE,ddrtbl_getval(_cnf_DDR_PHY_SLICE_REGSET, _reg_PHY_IE_MODE));
-
-	return (complete==0);
-}
-
-/*******************************************************************************
- *	adjust rddqs latency
- ******************************************************************************/
-static void adjust_rddqs_latency(void)
-{
-	uint32_t ch,slice;
-	uint32_t dly;
-	uint32_t maxlatx2;
-	uint32_t tmp;
-	uint32_t rdlat_adjx2[SLICE_CNT];
-	foreach_vch(ch){
-		maxlatx2 = 0;
-		for(slice=0;slice<SLICE_CNT;slice++) {
-			ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX, 0x00);
-
-			dly = ddr_getval_s(ch, slice, _reg_PHY_RDDQS_GATE_SLAVE_DELAY);
-			tmp = ddr_getval_s(ch, slice, _reg_PHY_RDDQS_LATENCY_ADJUST);
-			/* note gate_slave_delay[9] is always 0 */
-			tmp = (tmp<<1) + (dly>>8);
-			rdlat_adjx2[slice] = tmp;
-			if(maxlatx2<tmp)
-				maxlatx2=tmp;
-		}
-		maxlatx2 = ((maxlatx2+1)>>1)<<1;
-		for(slice=0;slice<SLICE_CNT;slice++) {
-			tmp = maxlatx2 - rdlat_adjx2[slice];
-			tmp = (tmp>>1);
-			if(tmp){
-				ddr_setval_s(ch, slice, _reg_PHY_RPTR_UPDATE,
-				ddr_getval_s(ch, slice, _reg_PHY_RPTR_UPDATE)+1);
-			}
-		}
-	}
-}
-
-/*******************************************************************************
- *	adjust wpath latency
- ******************************************************************************/
-static void adjust_wpath_latency(void)
-{
-	uint32_t ch,cs,slice;
-	uint32_t dly;
-	uint32_t wpath_add;
-	const uint32_t _par_EARLY_THRESHOLD_VAL=0x180;
-
-	foreach_vch(ch){
-		for(slice=0;slice<SLICE_CNT;slice+=1) {
-			for(cs=0;cs<CS_CNT;cs++){
-				ddr_setval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX, cs);
-				ddr_getval_s(ch, slice, _reg_PHY_PER_CS_TRAINING_INDEX);
-				dly = ddr_getval_s(ch, slice, _reg_PHY_CLK_WRDQS_SLAVE_DELAY);
-				if(dly<=_par_EARLY_THRESHOLD_VAL)continue;
-
-				wpath_add = ddr_getval_s(ch, slice, _reg_PHY_WRITE_PATH_LAT_ADD);
-				ddr_setval_s(ch, slice,  _reg_PHY_WRITE_PATH_LAT_ADD, wpath_add-1);
-			}
-		}
-	}
-}
-
-/*******************************************************************************
- *	DDR Initialize entry
- ******************************************************************************/
-int32_t InitDram(void)
-{
-	uint32_t ch,cs;
-	uint32_t dataL;
-	uint32_t bus_mbps, bus_mbpsdiv;
-	uint32_t tmp_tccd;
-	uint32_t failcount;
-
-	/***********************************************************************
-	Thermal sensor setting
-	***********************************************************************/
-	dataL = *((volatile uint32_t*)CPG_MSTPSR5);
-	if(dataL & BIT22){	// case THS/TSC Standby
-		dataL &= ~(BIT22);
-		*((volatile uint32_t*)CPG_CPGWPR)   = ~dataL;
-		*((volatile uint32_t*)CPG_SMSTPCR5) =  dataL;
-		while( (BIT22) & *((volatile uint32_t*)CPG_MSTPSR5) );  // wait bit=0
-	}
-
-	/* THCTR Bit6: PONM=0 , Bit0: THSST=0	*/
-	dataL = (*((volatile uint32_t*)THS1_THCTR)) & 0xFFFFFFBE;
-	*((volatile uint32_t*)THS1_THCTR) = dataL;
-
-	/***********************************************************************
-	Judge product and cut
-	***********************************************************************/
-#ifdef RCAR_DDR_FIXED_LSI_TYPE
-#if(RCAR_LSI==RCAR_AUTO)
-	Prr_Product = mmio_read_32(PRR) & PRR_PRODUCT_MASK;
-	Prr_Cut = mmio_read_32(PRR) & PRR_CUT_MASK;
-#else//RCAR_LSI
-#ifndef RCAR_LSI_CUT
-	Prr_Cut = mmio_read_32(PRR) & PRR_CUT_MASK;
-#endif//RCAR_LSI_CUT
-#endif//RCAR_LSI
-#else//RCAR_DDR_FIXED_LSI_TYPE
-	Prr_Product = mmio_read_32(PRR) & PRR_PRODUCT_MASK;
-	Prr_Cut = mmio_read_32(PRR) & PRR_CUT_MASK;
-#endif//RCAR_DDR_FIXED_LSI_TYPE
-
-	if (Prr_Product==PRR_PRODUCT_H3) {
-		if(Prr_Cut<=PRR_PRODUCT_11){
-			pDDR_REGDEF_TBL = (uint32_t *)&DDR_REGDEF_TBL[0][0];
-		} else {
-			pDDR_REGDEF_TBL = (uint32_t *)&DDR_REGDEF_TBL[2][0];
-		}
-	} else if (Prr_Product==PRR_PRODUCT_M3) {
-		pDDR_REGDEF_TBL = (uint32_t *)&DDR_REGDEF_TBL[1][0];
-	} else if ((Prr_Product==PRR_PRODUCT_M3N)||(Prr_Product==PRR_PRODUCT_V3H)) {
-		pDDR_REGDEF_TBL = (uint32_t *)&DDR_REGDEF_TBL[3][0];
-	} else {
-		FATAL_MSG("DDR:Unknown Product");
-		return 0xff;
-	}
-
-	if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-	 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut<=PRR_PRODUCT_20))){
-		/* non : H3 Ver.1.x/M3-W Ver.1.x not support */
-	} else {
-		mmio_write_32(DBSC_DBSYSCNT0, 0x00001234);
-	}
-
-	/***********************************************************************
-	Judge board type
-	***********************************************************************/
-	_cnf_BOARDTYPE = boardcnf_get_brd_type();
-	if(_cnf_BOARDTYPE>=BOARDNUM){
-		FATAL_MSG("DDR:Unknown Board");
-		return 0xff;
-	}
-	Boardcnf = (struct _boardcnf *)&boardcnfs[_cnf_BOARDTYPE];
-
-//RCAR_DRAM_SPLIT_2CH		(2U)
-#if RCAR_DRAM_SPLIT == 2
-	/***********************************************************************
-	H3(Test for future H3-N): Swap ch2 and ch1 for 2ch-split
-	***********************************************************************/
-	if ((Prr_Product==PRR_PRODUCT_H3)&&(Boardcnf->phyvalid==0x05)) {
-		mmio_write_32(DBSC_DBMEMSWAPCONF0, 0x00000006);
-		ddr_phyvalid = 0x03;
-	} else {
-		ddr_phyvalid = Boardcnf->phyvalid;
-	}
-#else//RCAR_DRAM_SPLIT_2CH
-	ddr_phyvalid = Boardcnf->phyvalid;
-#endif//RCAR_DRAM_SPLIT_2CH
-
-	max_density=0;
-
-	for(cs=0;cs<CS_CNT;cs++){
-		ch_have_this_cs[cs]=0;
-	}
-
-	foreach_ech(ch)
-		for(cs=0;cs<CS_CNT;cs++)
-			ddr_density[ch][cs]=0xff;
-
-	foreach_vch(ch){
-		for(cs=0;cs<CS_CNT;cs++){
-			dataL = Boardcnf->ch[ch].ddr_density[cs];
-			ddr_density[ch][cs]=dataL;
-
-			if(dataL==0xff)continue;
-			if(dataL>max_density)
-				max_density=dataL;
-			if((cs==1) && (Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-				continue;
-			ch_have_this_cs[cs] |= (1U<<ch);
-		}
-	}
-
-	/***********************************************************************
-	Judge board clock frequency (in MHz)
-	***********************************************************************/
-	boardcnf_get_brd_clk(_cnf_BOARDTYPE, &brd_clk, &brd_clkdiv);
-	if((brd_clk/brd_clkdiv) > 25){
-		brd_clkdiva = 1;
-	} else {
-		brd_clkdiva = 0;
-	}
-
-	/***********************************************************************
-	Judge ddr operating frequency clock(in Mbps)
-	***********************************************************************/
-	boardcnf_get_ddr_mbps(_cnf_BOARDTYPE, &ddr_mbps, &ddr_mbpsdiv);
-
-	ddr0800_mul = CLK_DIV(800,2,brd_clk,brd_clkdiv*(brd_clkdiva+1));
-
-	ddr_mul = CLK_DIV(ddr_mbps,ddr_mbpsdiv*2,brd_clk,brd_clkdiv*(brd_clkdiva+1));
-
-	/***********************************************************************
-	Adjust tccd
-	***********************************************************************/
-	dataL = (0x00006000 & mmio_read_32(RST_MODEMR)) >> 13;
-	switch(dataL) {
-		case 0:	bus_mbps = brd_clk * 0x60 * 2; bus_mbpsdiv = brd_clkdiv * 1;	break;
-		case 1:	bus_mbps = brd_clk * 0x50 * 2; bus_mbpsdiv = brd_clkdiv * 1;	break;
-		case 2:	bus_mbps = brd_clk * 0x40 * 2; bus_mbpsdiv = brd_clkdiv * 1;	break;
-		case 3:	bus_mbps = brd_clk * 0x60 * 2; bus_mbpsdiv = brd_clkdiv * 2;	break;
-		default:bus_mbps = brd_clk * 0x60 * 2; bus_mbpsdiv = brd_clkdiv * 2;	break;
-	}
-	tmp_tccd = CLK_DIV(ddr_mbps*8, ddr_mbpsdiv, bus_mbps, bus_mbpsdiv);
-	if(8*ddr_mbps*bus_mbpsdiv != tmp_tccd * bus_mbps * ddr_mbpsdiv)
-		tmp_tccd = tmp_tccd + 1;
-
-	if(tmp_tccd<8)
-		ddr_tccd = 8;
-	else
-		ddr_tccd = tmp_tccd;
-
-	NOTICE("BL2: DDR%d(%s)", ddr_mbps/ddr_mbpsdiv, RCAR_DDR_VERSION);
-
-	MSG_LF("Start\n");
-
-	/***********************************************************************
-	PLL Setting
-	***********************************************************************/
-	pll3_control(1);
-
-	/***********************************************************************
-	initialize DDR
-	***********************************************************************/
-	dataL=init_ddr();
-	if(dataL==ddr_phyvalid) {
-		failcount =0;
-	}
-	else {
-		failcount =1;
-	}
-
-	NOTICE("..%d\n",failcount);
-
-	foreach_vch(ch)
-		mmio_write_32(DBSC_DBPDLK(ch), 0x00000000);
-	if(((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11))
-	 ||((Prr_Product==PRR_PRODUCT_M3)&&(Prr_Cut<=PRR_PRODUCT_20))){
-		/* non : H3 Ver.1.x/M3-W Ver.1.x not support */
-	} else {
-		mmio_write_32(DBSC_DBSYSCNT0, 0x00000000);
-	}
-
-	if(failcount==0) {
-		return INITDRAM_OK;
-	} else {
-		return INITDRAM_NG;
-	}
-}
-
-void pvtcode_update(void)
-{
-	uint32_t	ch;
-	uint32_t	pvtp[4],pvtn[4],pvtp_init,pvtn_init;
-	int32_t		pvtp_tmp,pvtn_tmp;
-
-	foreach_vch(ch){
-		pvtn_init = (tcal.tcomp_cal[ch] & 0xFC0)>>6;
-		pvtp_init = (tcal.tcomp_cal[ch] & 0x03F)>>0;
-
-		if(8912*pvtp_init > 44230){
-			pvtp_tmp=   (5000 + 8912*pvtp_init - 44230) /10000;
-		} else {
-			pvtp_tmp= -((-(5000 + 8912*pvtp_init - 44230)) /10000);
-		}
-		pvtn_tmp=  (5000 +  5776 * pvtn_init + 30280 )	/10000;
-
-		pvtn[ch]= pvtn_tmp + pvtn_init;
-		pvtp[ch]= pvtp_tmp + pvtp_init;
-
-		if(pvtn[ch] >63) {
-			pvtn[ch]=63;
-			pvtp[ch]=(pvtp_tmp)*(63-6*pvtn_tmp -pvtn_init)/(pvtn_tmp) +6*pvtp_tmp + pvtp_init;
-		}
-		if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_FDBK_TERM),pvtp[ch]| (pvtn[ch]<<6)|(tcal.tcomp_cal[ch]&0xfffff000));
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DATA_TERM),pvtp[ch]| (pvtn[ch]<<6)|(tcal.tcomp_cal[ch]&0xfffff000));
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DQS_TERM ),pvtp[ch]| (pvtn[ch]<<6)|(tcal.tcomp_cal[ch]&0xfffff000));
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_ADDR_TERM),pvtp[ch]| (pvtn[ch]<<6)|(tcal.tcomp_cal[ch]&0xfffff000));
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_CS_TERM  ),pvtp[ch]| (pvtn[ch]<<6)|(tcal.tcomp_cal[ch]&0xfffff000));
-		} else {
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_FDBK_TERM),pvtp[ch]| (pvtn[ch]<<6)|0x00035000);
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DATA_TERM),pvtp[ch]| (pvtn[ch]<<6)|0x00015000);
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DQS_TERM ),pvtp[ch]| (pvtn[ch]<<6)|0x00015000);
-
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_ADDR_TERM),pvtp[ch]| (pvtn[ch]<<6)|0x00015000);
-			reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_CS_TERM  ),pvtp[ch]| (pvtn[ch]<<6)|0x00015000);
-		}
-	}
-}
-
-void pvtcode_update2(void){
-	uint32_t	ch;
-	foreach_vch(ch){
-		reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_FDBK_TERM),tcal.init_cal[ch]|0x00020000);
-		reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DATA_TERM),tcal.init_cal[ch]);
-		reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_DQS_TERM ),tcal.init_cal[ch]);
-		reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_ADDR_TERM),tcal.init_cal[ch]);
-		reg_ddrphy_write(ch, ddr_regdef_adr(_reg_PHY_PAD_CS_TERM  ),tcal.init_cal[ch]);
-	}
-}
-
-void ddr_padcal_tcompensate_getinit(uint32_t override)
-{
-	uint32_t ch;
-	uint32_t dataL;
-	uint32_t pvtp,pvtn;
-
-	tcal.init_temp = 0;
-	for(ch=0;ch<4;ch++){
-		tcal.init_cal[ch] =0;
-		tcal.tcomp_cal[ch] =0;
-	}
-
-	foreach_vch(ch) {
-		tcal.init_cal[ch]  = ddr_getval(ch, _reg_PHY_PAD_TERM_X[1]);
-		tcal.tcomp_cal[ch] = ddr_getval(ch, _reg_PHY_PAD_TERM_X[1]);
-	}
-
-	if(!override){
-		dataL = *((volatile uint32_t*)THS1_TEMP);
-		if(dataL < 2800){	tcal.init_temp = (143 * (int32_t)dataL - 359000)/1000;}
-			else	{	tcal.init_temp = (121 * (int32_t)dataL - 296300)/1000;}
-
-		foreach_vch(ch){
-			pvtp = (tcal.init_cal[ch] >> 0) & 0x000003F;
-			pvtn = (tcal.init_cal[ch] >> 6) & 0x000003F;
-			if((int32_t)pvtp > ((tcal.init_temp * 29 -3625)/1000))
-				pvtp = (int32_t)pvtp +((3625 - tcal.init_temp * 29 )/1000);
-			else
-				pvtp = 0;
-
-			if((int32_t)pvtn > ((tcal.init_temp * 54 -6750)/1000))
-				pvtn = (int32_t)pvtn +((6750 - tcal.init_temp * 54)/1000);
-			else
-				pvtn = 0;
-
-			if((Prr_Product==PRR_PRODUCT_H3)&&(Prr_Cut<=PRR_PRODUCT_11)) {
-				tcal.init_cal[ch] = (tcal.init_cal[ch] & 0xfffff000) | (pvtn << 6) |(pvtp);
-			} else {
-				tcal.init_cal[ch]   = 0x00015000 | (pvtn    << 6) |(pvtp);
-			}
-		}
-		tcal.init_temp =125;
-	}
-}
-
-#ifndef ddr_qos_init_setting
-// for QoS init
-uint8_t get_boardcnf_phyvalid(void)
-{
-//	return Boardcnf->phyvalid;
-	return ddr_phyvalid;
-}
-#endif//ddr_qos_init_setting
-
-/*******************************************************************************
- *	END
- ******************************************************************************/
diff --git a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
index 9d2eaa73..8a9df00f 100644
--- a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
+++ b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
@@ -861,7 +861,7 @@ uint32_t rcar_bl31_get_cpu_num(uint32_t cluster_type)
 	uint32_t num = 0U;
 	uint32_t loop;
 	uint32_t prr_data;
-
+return 1; // FIXME
 	prr_data = mmio_read_32((uintptr_t)RCAR_PRR);
 
 	/* CA53 CPU */
diff --git a/plat/renesas/rcar/drivers/rom/rom_api.c b/plat/renesas/rcar/drivers/rom/rom_api.c
index 876e7cd6..93a49859 100644
--- a/plat/renesas/rcar/drivers/rom/rom_api.c
+++ b/plat/renesas/rcar/drivers/rom/rom_api.c
@@ -5,6 +5,7 @@
  */
 
 #include <stdint.h>
+#include <debug.h>
 #include <mmio.h>
 #include "rcar_def.h"
 #include "rom_api.h"
@@ -75,6 +76,7 @@ static uint32_t get_table_index(void)
 	uint32_t index;
 
 	product = mmio_read_32(RCAR_PRR) & RCAR_PRODUCT_MASK;
+
 	cut_ver = mmio_read_32(RCAR_PRR) & RCAR_CUT_MASK;
 
 	switch (product) {
@@ -97,9 +99,10 @@ static uint32_t get_table_index(void)
 		}
 		break;
 	default:
-		index = NEW_API_TABLE;		/* M3N and E3 */
+		index = NEW_API_TABLE;		/* M3N, E3, D3 */
 		break;
 	}
+	INFO("BL2: get_table_index index=%d\n", index);
 
 	return index;
 }
diff --git a/plat/renesas/rcar/drivers/scif/scif.S b/plat/renesas/rcar/drivers/scif/scif.S
index 0bfb728b..8e78675e 100644
--- a/plat/renesas/rcar/drivers/scif/scif.S
+++ b/plat/renesas/rcar/drivers/scif/scif.S
@@ -14,6 +14,7 @@
 #define PRR_CUT_MASK		(0x000000FF)
 #define	PRR_PRODUCT_H3_VER_10	(0x00004F00)	/* R-Car H3 Ver.1.0 */
 #define	PRR_PRODUCT_E3		(0x00005700)	/* R-Car E3 */
+#define	PRR_PRODUCT_D3			(0x00005800)	/* R-Car D3 */
 
 /* module stop */
 #define	CPG_BASE		(0xE6150000)
@@ -58,6 +59,7 @@
 
 #define	SCBRR_115200BPS		(17)		/* 115200bps@66MHz */
 #define	SCBRR_115200BPS_E3_SSCG	(15)		/* 115200bps@60MHz SSCG */
+#define	SCBRR_115200BPSON	(16)		/* 115200bps@62.5MHz MD12=ON */
 #define	SCBRR_230400BPS		(8)		/* 230400bps@66MHz */
 
 #define	SCSCR_TE_MASK		(1 << 5)
@@ -186,6 +188,10 @@ func console_core_init
 	cmp	w1, w2
 	beq	3f
 	and	w1, w1, #PRR_PRODUCT_MASK
+	mov	w2, #PRR_PRODUCT_D3
+	cmp	w1, w2
+	beq	5f
+	and	w1, w1, #PRR_PRODUCT_MASK
 	mov	w2, #PRR_PRODUCT_E3
 	cmp	w1, w2
 	bne	4f
@@ -199,6 +205,9 @@ func console_core_init
 
 	mov	w1, #SCBRR_115200BPS_E3_SSCG	/* 115200bps@60MHz SSCG */
 	b	2f
+5:
+	mov	w1, #SCBRR_115200BPSON	/* 115200bps@62.5MHz MD12=ON */
+	b	2f
 4:
 	mov	w1, #SCBRR_115200BPS	/* 115200bps */
 	b	2f
diff --git a/plat/renesas/rcar/drivers/timer/bl2_swdt.c b/plat/renesas/rcar/drivers/timer/bl2_swdt.c
index 7e8d80a6..c6988d4a 100644
--- a/plat/renesas/rcar/drivers/timer/bl2_swdt.c
+++ b/plat/renesas/rcar/drivers/timer/bl2_swdt.c
@@ -47,7 +47,11 @@
 #define WTCSRA_INIT_DATA	(WTCSRA_UPPER_BYTE + 0x0FU)
 #define WTCSRB_INIT_DATA	(WTCSRB_UPPER_BYTE + 0x21U)
 
+#if RCAR_LSI == RCAR_D3
+#define WTCNT_COUNT_8p13k		(0x10000U - 40760U)
+#else
 #define WTCNT_COUNT_8p13k		(0x10000U - 40687U)
+#endif
 #define WTCNT_COUNT_8p13k_H3VER10	(0x10000U - 20343U)
 #define WTCNT_COUNT_8p22k		(0x10000U - 41115U)
 #define WTCNT_COUNT_7p81k		(0x10000U - 39062U)
diff --git a/plat/renesas/rcar/include/platform_def.h b/plat/renesas/rcar/include/platform_def.h
index 45a3414e..0cc97473 100644
--- a/plat/renesas/rcar/include/platform_def.h
+++ b/plat/renesas/rcar/include/platform_def.h
@@ -111,7 +111,7 @@
 #endif /* RCAR_LSI == RCAR_E3 */
 
 #define BL2_BASE			U(0xE6304000)
-#if RCAR_LSI == RCAR_E3
+#if (RCAR_LSI == RCAR_D3) || (RCAR_LSI == RCAR_E3)
 #define BL2_LIMIT			U(0xE6318000)
 #else  /* RCAR_LSI == RCAR_E3 */
 #define BL2_LIMIT			U(0xE632E800)
diff --git a/plat/renesas/rcar/pfc/D3/pfc_init_d3.c b/plat/renesas/rcar/pfc/D3/pfc_init_d3.c
new file mode 100644
index 00000000..d234b9a8
--- /dev/null
+++ b/plat/renesas/rcar/pfc/D3/pfc_init_d3.c
@@ -0,0 +1,969 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>		/* for uint32_t */
+#include <mmio.h>
+#include "bl2_cpg_init.h"
+#include "pfc_init_d3.h"
+#include "rcar_def.h"
+
+
+/* GPIO base address */
+#define	GPIO_BASE		(0xE6050000U)
+
+/* GPIO registers */
+#define	GPIO_IOINTSEL0		(GPIO_BASE + 0x0000U)
+#define	GPIO_INOUTSEL0		(GPIO_BASE + 0x0004U)
+#define	GPIO_OUTDT0		(GPIO_BASE + 0x0008U)
+#define	GPIO_INDT0		(GPIO_BASE + 0x000CU)
+#define	GPIO_INTDT0		(GPIO_BASE + 0x0010U)
+#define	GPIO_INTCLR0		(GPIO_BASE + 0x0014U)
+#define	GPIO_INTMSK0		(GPIO_BASE + 0x0018U)
+#define	GPIO_MSKCLR0		(GPIO_BASE + 0x001CU)
+#define	GPIO_POSNEG0		(GPIO_BASE + 0x0020U)
+#define	GPIO_EDGLEVEL0		(GPIO_BASE + 0x0024U)
+#define	GPIO_FILONOFF0		(GPIO_BASE + 0x0028U)
+#define	GPIO_INTMSKS0		(GPIO_BASE + 0x0038U)
+#define	GPIO_MSKCLRS0		(GPIO_BASE + 0x003CU)
+#define	GPIO_OUTDTSEL0		(GPIO_BASE + 0x0040U)
+#define	GPIO_OUTDTH0		(GPIO_BASE + 0x0044U)
+#define	GPIO_OUTDTL0		(GPIO_BASE + 0x0048U)
+#define	GPIO_BOTHEDGE0		(GPIO_BASE + 0x004CU)
+#define	GPIO_IOINTSEL1		(GPIO_BASE + 0x1000U)
+#define	GPIO_INOUTSEL1		(GPIO_BASE + 0x1004U)
+#define	GPIO_OUTDT1		(GPIO_BASE + 0x1008U)
+#define	GPIO_INDT1		(GPIO_BASE + 0x100CU)
+#define	GPIO_INTDT1		(GPIO_BASE + 0x1010U)
+#define	GPIO_INTCLR1		(GPIO_BASE + 0x1014U)
+#define	GPIO_INTMSK1		(GPIO_BASE + 0x1018U)
+#define	GPIO_MSKCLR1		(GPIO_BASE + 0x101CU)
+#define	GPIO_POSNEG1		(GPIO_BASE + 0x1020U)
+#define	GPIO_EDGLEVEL1		(GPIO_BASE + 0x1024U)
+#define	GPIO_FILONOFF1		(GPIO_BASE + 0x1028U)
+#define	GPIO_INTMSKS1		(GPIO_BASE + 0x1038U)
+#define	GPIO_MSKCLRS1		(GPIO_BASE + 0x103CU)
+#define	GPIO_OUTDTSEL1		(GPIO_BASE + 0x1040U)
+#define	GPIO_OUTDTH1		(GPIO_BASE + 0x1044U)
+#define	GPIO_OUTDTL1		(GPIO_BASE + 0x1048U)
+#define	GPIO_BOTHEDGE1		(GPIO_BASE + 0x104CU)
+#define	GPIO_IOINTSEL2		(GPIO_BASE + 0x2000U)
+#define	GPIO_INOUTSEL2		(GPIO_BASE + 0x2004U)
+#define	GPIO_OUTDT2		(GPIO_BASE + 0x2008U)
+#define	GPIO_INDT2		(GPIO_BASE + 0x200CU)
+#define	GPIO_INTDT2		(GPIO_BASE + 0x2010U)
+#define	GPIO_INTCLR2		(GPIO_BASE + 0x2014U)
+#define	GPIO_INTMSK2		(GPIO_BASE + 0x2018U)
+#define	GPIO_MSKCLR2		(GPIO_BASE + 0x201CU)
+#define	GPIO_POSNEG2		(GPIO_BASE + 0x2020U)
+#define	GPIO_EDGLEVEL2		(GPIO_BASE + 0x2024U)
+#define	GPIO_FILONOFF2		(GPIO_BASE + 0x2028U)
+#define	GPIO_INTMSKS2		(GPIO_BASE + 0x2038U)
+#define	GPIO_MSKCLRS2		(GPIO_BASE + 0x203CU)
+#define	GPIO_OUTDTSEL2		(GPIO_BASE + 0x2040U)
+#define	GPIO_OUTDTH2		(GPIO_BASE + 0x2044U)
+#define	GPIO_OUTDTL2		(GPIO_BASE + 0x2048U)
+#define	GPIO_BOTHEDGE2		(GPIO_BASE + 0x204CU)
+#define	GPIO_IOINTSEL3		(GPIO_BASE + 0x3000U)
+#define	GPIO_INOUTSEL3		(GPIO_BASE + 0x3004U)
+#define	GPIO_OUTDT3		(GPIO_BASE + 0x3008U)
+#define	GPIO_INDT3		(GPIO_BASE + 0x300CU)
+#define	GPIO_INTDT3		(GPIO_BASE + 0x3010U)
+#define	GPIO_INTCLR3		(GPIO_BASE + 0x3014U)
+#define	GPIO_INTMSK3		(GPIO_BASE + 0x3018U)
+#define	GPIO_MSKCLR3		(GPIO_BASE + 0x301CU)
+#define	GPIO_POSNEG3		(GPIO_BASE + 0x3020U)
+#define	GPIO_EDGLEVEL3		(GPIO_BASE + 0x3024U)
+#define	GPIO_FILONOFF3		(GPIO_BASE + 0x3028U)
+#define	GPIO_INTMSKS3		(GPIO_BASE + 0x3038U)
+#define	GPIO_MSKCLRS3		(GPIO_BASE + 0x303CU)
+#define	GPIO_OUTDTSEL3		(GPIO_BASE + 0x3040U)
+#define	GPIO_OUTDTH3		(GPIO_BASE + 0x3044U)
+#define	GPIO_OUTDTL3		(GPIO_BASE + 0x3048U)
+#define	GPIO_BOTHEDGE3		(GPIO_BASE + 0x304CU)
+#define	GPIO_IOINTSEL4		(GPIO_BASE + 0x4000U)
+#define	GPIO_INOUTSEL4		(GPIO_BASE + 0x4004U)
+#define	GPIO_OUTDT4		(GPIO_BASE + 0x4008U)
+#define	GPIO_INDT4		(GPIO_BASE + 0x400CU)
+#define	GPIO_INTDT4		(GPIO_BASE + 0x4010U)
+#define	GPIO_INTCLR4		(GPIO_BASE + 0x4014U)
+#define	GPIO_INTMSK4		(GPIO_BASE + 0x4018U)
+#define	GPIO_MSKCLR4		(GPIO_BASE + 0x401CU)
+#define	GPIO_POSNEG4		(GPIO_BASE + 0x4020U)
+#define	GPIO_EDGLEVEL4		(GPIO_BASE + 0x4024U)
+#define	GPIO_FILONOFF4		(GPIO_BASE + 0x4028U)
+#define	GPIO_INTMSKS4		(GPIO_BASE + 0x4038U)
+#define	GPIO_MSKCLRS4		(GPIO_BASE + 0x403CU)
+#define	GPIO_OUTDTSEL4		(GPIO_BASE + 0x4040U)
+#define	GPIO_OUTDTH4		(GPIO_BASE + 0x4044U)
+#define	GPIO_OUTDTL4		(GPIO_BASE + 0x4048U)
+#define	GPIO_BOTHEDGE4		(GPIO_BASE + 0x404CU)
+#define	GPIO_IOINTSEL5		(GPIO_BASE + 0x5000U)
+#define	GPIO_INOUTSEL5		(GPIO_BASE + 0x5004U)
+#define	GPIO_OUTDT5		(GPIO_BASE + 0x5008U)
+#define	GPIO_INDT5		(GPIO_BASE + 0x500CU)
+#define	GPIO_INTDT5		(GPIO_BASE + 0x5010U)
+#define	GPIO_INTCLR5		(GPIO_BASE + 0x5014U)
+#define	GPIO_INTMSK5		(GPIO_BASE + 0x5018U)
+#define	GPIO_MSKCLR5		(GPIO_BASE + 0x501CU)
+#define	GPIO_POSNEG5		(GPIO_BASE + 0x5020U)
+#define	GPIO_EDGLEVEL5		(GPIO_BASE + 0x5024U)
+#define	GPIO_FILONOFF5		(GPIO_BASE + 0x5028U)
+#define	GPIO_INTMSKS5		(GPIO_BASE + 0x5038U)
+#define	GPIO_MSKCLRS5		(GPIO_BASE + 0x503CU)
+#define	GPIO_OUTDTSEL5		(GPIO_BASE + 0x5040U)
+#define	GPIO_OUTDTH5		(GPIO_BASE + 0x5044U)
+#define	GPIO_OUTDTL5		(GPIO_BASE + 0x5048U)
+#define	GPIO_BOTHEDGE5		(GPIO_BASE + 0x504CU)
+#define	GPIO_IOINTSEL6		(GPIO_BASE + 0x5400U)
+#define	GPIO_INOUTSEL6		(GPIO_BASE + 0x5404U)
+#define	GPIO_OUTDT6		(GPIO_BASE + 0x5408U)
+#define	GPIO_INDT6		(GPIO_BASE + 0x540CU)
+#define	GPIO_INTDT6		(GPIO_BASE + 0x5410U)
+#define	GPIO_INTCLR6		(GPIO_BASE + 0x5414U)
+#define	GPIO_INTMSK6		(GPIO_BASE + 0x5418U)
+#define	GPIO_MSKCLR6		(GPIO_BASE + 0x541CU)
+#define	GPIO_POSNEG6		(GPIO_BASE + 0x5420U)
+#define	GPIO_EDGLEVEL6		(GPIO_BASE + 0x5424U)
+#define	GPIO_FILONOFF6		(GPIO_BASE + 0x5428U)
+#define	GPIO_INTMSKS6		(GPIO_BASE + 0x5438U)
+#define	GPIO_MSKCLRS6		(GPIO_BASE + 0x543CU)
+#define	GPIO_OUTDTSEL6		(GPIO_BASE + 0x5440U)
+#define	GPIO_OUTDTH6		(GPIO_BASE + 0x5444U)
+#define	GPIO_OUTDTL6		(GPIO_BASE + 0x5448U)
+#define	GPIO_BOTHEDGE6		(GPIO_BASE + 0x544CU)
+#define	GPIO_IOINTSEL7		(GPIO_BASE + 0x5800U)
+#define	GPIO_INOUTSEL7		(GPIO_BASE + 0x5804U)
+#define	GPIO_OUTDT7		(GPIO_BASE + 0x5808U)
+#define	GPIO_INDT7		(GPIO_BASE + 0x580CU)
+#define	GPIO_INTDT7		(GPIO_BASE + 0x5810U)
+#define	GPIO_INTCLR7		(GPIO_BASE + 0x5814U)
+#define	GPIO_INTMSK7		(GPIO_BASE + 0x5818U)
+#define	GPIO_MSKCLR7		(GPIO_BASE + 0x581CU)
+#define	GPIO_POSNEG7		(GPIO_BASE + 0x5820U)
+#define	GPIO_EDGLEVEL7		(GPIO_BASE + 0x5824U)
+#define	GPIO_FILONOFF7		(GPIO_BASE + 0x5828U)
+#define	GPIO_INTMSKS7		(GPIO_BASE + 0x5838U)
+#define	GPIO_MSKCLRS7		(GPIO_BASE + 0x583CU)
+#define	GPIO_OUTDTSEL7		(GPIO_BASE + 0x5840U)
+#define	GPIO_OUTDTH7		(GPIO_BASE + 0x5844U)
+#define	GPIO_OUTDTL7		(GPIO_BASE + 0x5848U)
+#define	GPIO_BOTHEDGE7		(GPIO_BASE + 0x584CU)
+
+
+/* Pin functon base address */
+#define	PFC_BASE		(0xE6060000U)
+
+/* Pin functon registers */
+#define	PFC_PMMR		(PFC_BASE + 0x0000U)
+#define PFC_GPSR0		(PFC_BASE + 0x0100U)
+#define PFC_GPSR1		(PFC_BASE + 0x0104U)
+#define PFC_GPSR2		(PFC_BASE + 0x0108U)
+#define PFC_GPSR3		(PFC_BASE + 0x010CU)
+#define PFC_GPSR4		(PFC_BASE + 0x0110U)
+#define	PFC_GPSR5		(PFC_BASE + 0x0114U)
+#define	PFC_GPSR6		(PFC_BASE + 0x0118U)
+#define	PFC_GPSR7		(PFC_BASE + 0x011CU)
+#define	PFC_IPSR0		(PFC_BASE + 0x0200U)
+#define	PFC_IPSR1		(PFC_BASE + 0x0204U)
+#define	PFC_IPSR2		(PFC_BASE + 0x0208U)
+#define	PFC_IPSR3		(PFC_BASE + 0x020CU)
+#define	PFC_IPSR4		(PFC_BASE + 0x0210U)
+#define	PFC_IPSR5		(PFC_BASE + 0x0214U)
+#define	PFC_IPSR6		(PFC_BASE + 0x0218U)
+#define	PFC_IPSR7		(PFC_BASE + 0x021CU)
+#define	PFC_IPSR8		(PFC_BASE + 0x0220U)
+#define	PFC_IPSR9		(PFC_BASE + 0x0224U)
+#define	PFC_IPSR10		(PFC_BASE + 0x0228U)
+#define	PFC_IPSR11		(PFC_BASE + 0x022CU)
+#define	PFC_IPSR12		(PFC_BASE + 0x0230U)
+#define	PFC_IPSR13		(PFC_BASE + 0x0234U)
+#define	PFC_IPSR14		(PFC_BASE + 0x0238U)
+#define	PFC_IPSR15		(PFC_BASE + 0x023CU)
+#define	PFC_IPSR16		(PFC_BASE + 0x0240U)
+#define	PFC_IPSR17		(PFC_BASE + 0x0244U)
+#define	PFC_IPSR18		(PFC_BASE + 0x0248U)
+#define PFC_DRVCTRL0		(PFC_BASE + 0x0300U)
+#define PFC_DRVCTRL1		(PFC_BASE + 0x0304U)
+#define PFC_DRVCTRL2		(PFC_BASE + 0x0308U)
+#define PFC_DRVCTRL3		(PFC_BASE + 0x030CU)
+#define PFC_DRVCTRL4		(PFC_BASE + 0x0310U)
+#define PFC_DRVCTRL5		(PFC_BASE + 0x0314U)
+#define PFC_DRVCTRL6		(PFC_BASE + 0x0318U)
+#define PFC_DRVCTRL7		(PFC_BASE + 0x031CU)
+#define PFC_DRVCTRL8		(PFC_BASE + 0x0320U)
+#define PFC_DRVCTRL9		(PFC_BASE + 0x0324U)
+#define PFC_DRVCTRL10		(PFC_BASE + 0x0328U)
+#define PFC_DRVCTRL11		(PFC_BASE + 0x032CU)
+#define PFC_DRVCTRL12		(PFC_BASE + 0x0330U)
+#define PFC_DRVCTRL13		(PFC_BASE + 0x0334U)
+#define PFC_DRVCTRL14		(PFC_BASE + 0x0338U)
+#define PFC_DRVCTRL15		(PFC_BASE + 0x033CU)
+#define PFC_DRVCTRL16		(PFC_BASE + 0x0340U)
+#define PFC_DRVCTRL17		(PFC_BASE + 0x0344U)
+#define PFC_DRVCTRL18		(PFC_BASE + 0x0348U)
+#define PFC_DRVCTRL19		(PFC_BASE + 0x034CU)
+#define PFC_DRVCTRL20		(PFC_BASE + 0x0350U)
+#define PFC_DRVCTRL21		(PFC_BASE + 0x0354U)
+#define PFC_DRVCTRL22		(PFC_BASE + 0x0358U)
+#define PFC_DRVCTRL23		(PFC_BASE + 0x035CU)
+#define PFC_DRVCTRL24		(PFC_BASE + 0x0360U)
+#define PFC_POCCTRL0		(PFC_BASE + 0x0380U)
+#define PFC_POCCTRL1		(PFC_BASE + 0x0388U)
+#define	PFC_TDSELCTRL0		(PFC_BASE + 0x03C0U)
+#define	PFC_IOCTRL		(PFC_BASE + 0x03E0U)
+#define	PFC_TSREG		(PFC_BASE + 0x03E4U)
+#define	PFC_PUEN0		(PFC_BASE + 0x0400U)
+#define	PFC_PUEN1		(PFC_BASE + 0x0404U)
+#define	PFC_PUEN2		(PFC_BASE + 0x0408U)
+#define	PFC_PUEN3		(PFC_BASE + 0x040CU)
+#define	PFC_PUEN4		(PFC_BASE + 0x0410U)
+#define	PFC_PUEN5		(PFC_BASE + 0x0414U)
+#define	PFC_PUEN6		(PFC_BASE + 0x0418U)
+#define	PFC_PUD0		(PFC_BASE + 0x0440U)
+#define	PFC_PUD1		(PFC_BASE + 0x0444U)
+#define	PFC_PUD2		(PFC_BASE + 0x0448U)
+#define	PFC_PUD3		(PFC_BASE + 0x044CU)
+#define	PFC_PUD4		(PFC_BASE + 0x0450U)
+#define	PFC_PUD5		(PFC_BASE + 0x0454U)
+#define	PFC_PUD6		(PFC_BASE + 0x0458U)
+#define	PFC_MOD_SEL0		(PFC_BASE + 0x0500U)
+#define	PFC_MOD_SEL1		(PFC_BASE + 0x0504U)
+#define	PFC_MOD_SEL2		(PFC_BASE + 0x0508U)
+
+#define	GPSR0_D15		((uint32_t)1U << 15U)
+#define	GPSR0_D14		((uint32_t)1U << 14U)
+#define	GPSR0_D13		((uint32_t)1U << 13U)
+#define	GPSR0_D12		((uint32_t)1U << 12U)
+#define	GPSR0_D11		((uint32_t)1U << 11U)
+#define	GPSR0_D10		((uint32_t)1U << 10U)
+#define	GPSR0_D9		((uint32_t)1U << 9U)
+#define	GPSR0_D8		((uint32_t)1U << 8U)
+#define	GPSR0_D7		((uint32_t)1U << 7U)
+#define	GPSR0_D6		((uint32_t)1U << 6U)
+#define	GPSR0_D5		((uint32_t)1U << 5U)
+#define	GPSR0_D4		((uint32_t)1U << 4U)
+#define	GPSR0_D3		((uint32_t)1U << 3U)
+#define	GPSR0_D2		((uint32_t)1U << 2U)
+#define	GPSR0_D1		((uint32_t)1U << 1U)
+#define	GPSR0_D0		((uint32_t)1U << 0U)
+#define	GPSR1_CLKOUT		((uint32_t)1U << 28U)
+#define	GPSR1_EX_WAIT0_A	((uint32_t)1U << 27U)
+#define	GPSR1_WE1		((uint32_t)1U << 26U)
+#define	GPSR1_WE0		((uint32_t)1U << 25U)
+#define	GPSR1_RD_WR		((uint32_t)1U << 24U)
+#define	GPSR1_RD		((uint32_t)1U << 23U)
+#define	GPSR1_BS		((uint32_t)1U << 22U)
+#define	GPSR1_CS1_A26		((uint32_t)1U << 21U)
+#define	GPSR1_CS0		((uint32_t)1U << 20U)
+#define	GPSR1_A19		((uint32_t)1U << 19U)
+#define	GPSR1_A18		((uint32_t)1U << 18U)
+#define	GPSR1_A17		((uint32_t)1U << 17U)
+#define	GPSR1_A16		((uint32_t)1U << 16U)
+#define	GPSR1_A15		((uint32_t)1U << 15U)
+#define	GPSR1_A14		((uint32_t)1U << 14U)
+#define	GPSR1_A13		((uint32_t)1U << 13U)
+#define	GPSR1_A12		((uint32_t)1U << 12U)
+#define	GPSR1_A11		((uint32_t)1U << 11U)
+#define	GPSR1_A10		((uint32_t)1U << 10U)
+#define	GPSR1_A9		((uint32_t)1U << 9U)
+#define	GPSR1_A8		((uint32_t)1U << 8U)
+#define	GPSR1_A7		((uint32_t)1U << 7U)
+#define	GPSR1_A6		((uint32_t)1U << 6U)
+#define	GPSR1_A5		((uint32_t)1U << 5U)
+#define	GPSR1_A4		((uint32_t)1U << 4U)
+#define	GPSR1_A3		((uint32_t)1U << 3U)
+#define	GPSR1_A2		((uint32_t)1U << 2U)
+#define	GPSR1_A1		((uint32_t)1U << 1U)
+#define	GPSR1_A0		((uint32_t)1U << 0U)
+#define	GPSR2_AVB_AVTP_CAPTURE_A	((uint32_t)1U << 14U)
+#define	GPSR2_AVB_AVTP_MATCH_A	((uint32_t)1U << 13U)
+#define	GPSR2_AVB_LINK		((uint32_t)1U << 12U)
+#define	GPSR2_AVB_PHY_INT	((uint32_t)1U << 11U)
+#define	GPSR2_AVB_MAGIC		((uint32_t)1U << 10U)
+#define	GPSR2_AVB_MDC		((uint32_t)1U << 9U)
+#define	GPSR2_PWM2_A		((uint32_t)1U << 8U)
+#define	GPSR2_PWM1_A		((uint32_t)1U << 7U)
+#define	GPSR2_PWM0		((uint32_t)1U << 6U)
+#define	GPSR2_IRQ5		((uint32_t)1U << 5U)
+#define	GPSR2_IRQ4		((uint32_t)1U << 4U)
+#define	GPSR2_IRQ3		((uint32_t)1U << 3U)
+#define	GPSR2_IRQ2		((uint32_t)1U << 2U)
+#define	GPSR2_IRQ1		((uint32_t)1U << 1U)
+#define	GPSR2_IRQ0		((uint32_t)1U << 0U)
+#define	GPSR3_SD1_WP		((uint32_t)1U << 15U)
+#define	GPSR3_SD1_CD		((uint32_t)1U << 14U)
+#define	GPSR3_SD0_WP		((uint32_t)1U << 13U)
+#define	GPSR3_SD0_CD		((uint32_t)1U << 12U)
+#define	GPSR3_SD1_DAT3		((uint32_t)1U << 11U)
+#define	GPSR3_SD1_DAT2		((uint32_t)1U << 10U)
+#define	GPSR3_SD1_DAT1		((uint32_t)1U << 9U)
+#define	GPSR3_SD1_DAT0		((uint32_t)1U << 8U)
+#define	GPSR3_SD1_CMD		((uint32_t)1U << 7U)
+#define	GPSR3_SD1_CLK		((uint32_t)1U << 6U)
+#define	GPSR3_SD0_DAT3		((uint32_t)1U << 5U)
+#define	GPSR3_SD0_DAT2		((uint32_t)1U << 4U)
+#define	GPSR3_SD0_DAT1		((uint32_t)1U << 3U)
+#define	GPSR3_SD0_DAT0		((uint32_t)1U << 2U)
+#define	GPSR3_SD0_CMD		((uint32_t)1U << 1U)
+#define	GPSR3_SD0_CLK		((uint32_t)1U << 0U)
+#define	GPSR4_SD3_DS		((uint32_t)1U << 17U)
+#define	GPSR4_SD3_DAT7		((uint32_t)1U << 16U)
+#define	GPSR4_SD3_DAT6		((uint32_t)1U << 15U)
+#define	GPSR4_SD3_DAT5		((uint32_t)1U << 14U)
+#define	GPSR4_SD3_DAT4		((uint32_t)1U << 13U)
+#define	GPSR4_SD3_DAT3		((uint32_t)1U << 12U)
+#define	GPSR4_SD3_DAT2		((uint32_t)1U << 11U)
+#define	GPSR4_SD3_DAT1		((uint32_t)1U << 10U)
+#define	GPSR4_SD3_DAT0		((uint32_t)1U << 9U)
+#define	GPSR4_SD3_CMD		((uint32_t)1U << 8U)
+#define	GPSR4_SD3_CLK		((uint32_t)1U << 7U)
+#define	GPSR4_SD2_DS		((uint32_t)1U << 6U)
+#define	GPSR4_SD2_DAT3		((uint32_t)1U << 5U)
+#define	GPSR4_SD2_DAT2		((uint32_t)1U << 4U)
+#define	GPSR4_SD2_DAT1		((uint32_t)1U << 3U)
+#define	GPSR4_SD2_DAT0		((uint32_t)1U << 2U)
+#define	GPSR4_SD2_CMD		((uint32_t)1U << 1U)
+#define	GPSR4_SD2_CLK		((uint32_t)1U << 0U)
+#define	GPSR5_MLB_DAT		((uint32_t)1U << 25U)
+#define	GPSR5_MLB_SIG		((uint32_t)1U << 24U)
+#define	GPSR5_MLB_CLK		((uint32_t)1U << 23U)
+#define	GPSR5_MSIOF0_RXD	((uint32_t)1U << 22U)
+#define	GPSR5_MSIOF0_SS2	((uint32_t)1U << 21U)
+#define	GPSR5_MSIOF0_TXD	((uint32_t)1U << 20U)
+#define	GPSR5_MSIOF0_SS1	((uint32_t)1U << 19U)
+#define	GPSR5_MSIOF0_SYNC	((uint32_t)1U << 18U)
+#define	GPSR5_MSIOF0_SCK	((uint32_t)1U << 17U)
+#define	GPSR5_HRTS0		((uint32_t)1U << 16U)
+#define	GPSR5_HCTS0		((uint32_t)1U << 15U)
+#define	GPSR5_HTX0		((uint32_t)1U << 14U)
+#define	GPSR5_HRX0		((uint32_t)1U << 13U)
+#define	GPSR5_HSCK0		((uint32_t)1U << 12U)
+#define	GPSR5_RX2_A		((uint32_t)1U << 11U)
+#define	GPSR5_TX2_A		((uint32_t)1U << 10U)
+#define	GPSR5_SCK2		((uint32_t)1U << 9U)
+#define	GPSR5_RTS1_TANS		((uint32_t)1U << 8U)
+#define	GPSR5_CTS1		((uint32_t)1U << 7U)
+#define	GPSR5_TX1_A		((uint32_t)1U << 6U)
+#define	GPSR5_RX1_A		((uint32_t)1U << 5U)
+#define	GPSR5_RTS0_TANS		((uint32_t)1U << 4U)
+#define	GPSR5_CTS0		((uint32_t)1U << 3U)
+#define	GPSR5_TX0		((uint32_t)1U << 2U)
+#define	GPSR5_RX0		((uint32_t)1U << 1U)
+#define	GPSR5_SCK0		((uint32_t)1U << 0U)
+#define	GPSR6_USB31_OVC		((uint32_t)1U << 31U)
+#define	GPSR6_USB31_PWEN	((uint32_t)1U << 30U)
+#define	GPSR6_USB30_OVC		((uint32_t)1U << 29U)
+#define	GPSR6_USB30_PWEN	((uint32_t)1U << 28U)
+#define	GPSR6_USB1_OVC		((uint32_t)1U << 27U)
+#define	GPSR6_USB1_PWEN		((uint32_t)1U << 26U)
+#define	GPSR6_USB0_OVC		((uint32_t)1U << 25U)
+#define	GPSR6_USB0_PWEN		((uint32_t)1U << 24U)
+#define	GPSR6_AUDIO_CLKB_B	((uint32_t)1U << 23U)
+#define	GPSR6_AUDIO_CLKA_A	((uint32_t)1U << 22U)
+#define	GPSR6_SSI_SDATA9_A	((uint32_t)1U << 21U)
+#define	GPSR6_SSI_SDATA8	((uint32_t)1U << 20U)
+#define	GPSR6_SSI_SDATA7	((uint32_t)1U << 19U)
+#define	GPSR6_SSI_WS78		((uint32_t)1U << 18U)
+#define	GPSR6_SSI_SCK78		((uint32_t)1U << 17U)
+#define	GPSR6_SSI_SDATA6	((uint32_t)1U << 16U)
+#define	GPSR6_SSI_WS6		((uint32_t)1U << 15U)
+#define	GPSR6_SSI_SCK6		((uint32_t)1U << 14U)
+#define	GPSR6_SSI_SDATA5	((uint32_t)1U << 13U)
+#define	GPSR6_SSI_WS5		((uint32_t)1U << 12U)
+#define	GPSR6_SSI_SCK5		((uint32_t)1U << 11U)
+#define	GPSR6_SSI_SDATA4	((uint32_t)1U << 10U)
+#define	GPSR6_SSI_WS4		((uint32_t)1U << 9U)
+#define	GPSR6_SSI_SCK4		((uint32_t)1U << 8U)
+#define	GPSR6_SSI_SDATA3	((uint32_t)1U << 7U)
+#define	GPSR6_SSI_WS34		((uint32_t)1U << 6U)
+#define	GPSR6_SSI_SCK34		((uint32_t)1U << 5U)
+#define	GPSR6_SSI_SDATA2_A	((uint32_t)1U << 4U)
+#define	GPSR6_SSI_SDATA1_A	((uint32_t)1U << 3U)
+#define	GPSR6_SSI_SDATA0	((uint32_t)1U << 2U)
+#define	GPSR6_SSI_WS0129	((uint32_t)1U << 1U)
+#define	GPSR6_SSI_SCK0129	((uint32_t)1U << 0U)
+#define	GPSR7_HDMI1_CEC		((uint32_t)1U << 3U)
+#define	GPSR7_HDMI0_CEC		((uint32_t)1U << 2U)
+#define	GPSR7_AVS2		((uint32_t)1U << 1U)
+#define	GPSR7_AVS1		((uint32_t)1U << 0U)
+
+#define	IPSR_28_FUNC(x)		((uint32_t)(x) << 28U)
+#define	IPSR_24_FUNC(x)		((uint32_t)(x) << 24U)
+#define	IPSR_20_FUNC(x)		((uint32_t)(x) << 20U)
+#define	IPSR_16_FUNC(x)		((uint32_t)(x) << 16U)
+#define	IPSR_12_FUNC(x)		((uint32_t)(x) << 12U)
+#define	IPSR_8_FUNC(x)		((uint32_t)(x) << 8U)
+#define	IPSR_4_FUNC(x)		((uint32_t)(x) << 4U)
+#define	IPSR_0_FUNC(x)		((uint32_t)(x) << 0U)
+
+#define	POC_SD3_DS_33V		((uint32_t)1U << 29U)
+#define	POC_SD3_DAT7_33V	((uint32_t)1U << 28U)
+#define	POC_SD3_DAT6_33V	((uint32_t)1U << 27U)
+#define	POC_SD3_DAT5_33V	((uint32_t)1U << 26U)
+#define	POC_SD3_DAT4_33V	((uint32_t)1U << 25U)
+#define	POC_SD3_DAT3_33V	((uint32_t)1U << 24U)
+#define	POC_SD3_DAT2_33V	((uint32_t)1U << 23U)
+#define	POC_SD3_DAT1_33V	((uint32_t)1U << 22U)
+#define	POC_SD3_DAT0_33V	((uint32_t)1U << 21U)
+#define	POC_SD3_CMD_33V		((uint32_t)1U << 20U)
+#define	POC_SD3_CLK_33V		((uint32_t)1U << 19U)
+#define	POC_SD2_DS_33V		((uint32_t)1U << 18U)
+#define	POC_SD2_DAT3_33V	((uint32_t)1U << 17U)
+#define	POC_SD2_DAT2_33V	((uint32_t)1U << 16U)
+#define	POC_SD2_DAT1_33V	((uint32_t)1U << 15U)
+#define	POC_SD2_DAT0_33V	((uint32_t)1U << 14U)
+#define	POC_SD2_CMD_33V		((uint32_t)1U << 13U)
+#define	POC_SD2_CLK_33V		((uint32_t)1U << 12U)
+#define	POC_SD1_DAT3_33V	((uint32_t)1U << 11U)
+#define	POC_SD1_DAT2_33V	((uint32_t)1U << 10U)
+#define	POC_SD1_DAT1_33V	((uint32_t)1U << 9U)
+#define	POC_SD1_DAT0_33V	((uint32_t)1U << 8U)
+#define	POC_SD1_CMD_33V		((uint32_t)1U << 7U)
+#define	POC_SD1_CLK_33V		((uint32_t)1U << 6U)
+#define	POC_SD0_DAT3_33V	((uint32_t)1U << 5U)
+#define	POC_SD0_DAT2_33V	((uint32_t)1U << 4U)
+#define	POC_SD0_DAT1_33V	((uint32_t)1U << 3U)
+#define	POC_SD0_DAT0_33V	((uint32_t)1U << 2U)
+#define	POC_SD0_CMD_33V		((uint32_t)1U << 1U)
+#define	POC_SD0_CLK_33V		((uint32_t)1U << 0U)
+
+#define	DRVCTRL0_MASK		(0xCCCCCCCCU)
+#define	DRVCTRL1_MASK		(0xCCCCCCC8U)
+#define	DRVCTRL2_MASK		(0x88888888U)
+#define	DRVCTRL3_MASK		(0x88888888U)
+#define	DRVCTRL4_MASK		(0x88888888U)
+#define	DRVCTRL5_MASK		(0x88888888U)
+#define	DRVCTRL6_MASK		(0x88888888U)
+#define	DRVCTRL7_MASK		(0x88888888U)
+#define	DRVCTRL8_MASK		(0x88888888U)
+#define	DRVCTRL9_MASK		(0x88888888U)
+#define	DRVCTRL10_MASK		(0x88888888U)
+#define	DRVCTRL11_MASK		(0x888888CCU)
+#define	DRVCTRL12_MASK		(0xCCCFFFCFU)
+#define	DRVCTRL13_MASK		(0xCC888888U)
+#define	DRVCTRL14_MASK		(0x88888888U)
+#define	DRVCTRL15_MASK		(0x88888888U)
+#define	DRVCTRL16_MASK		(0x88888888U)
+#define	DRVCTRL17_MASK		(0x88888888U)
+#define	DRVCTRL18_MASK		(0x88888888U)
+#define	DRVCTRL19_MASK		(0x88888888U)
+#define	DRVCTRL20_MASK		(0x88888888U)
+#define	DRVCTRL21_MASK		(0x88888888U)
+#define	DRVCTRL22_MASK		(0x88888888U)
+#define	DRVCTRL23_MASK		(0x88888888U)
+#define	DRVCTRL24_MASK		(0x8888888FU)
+
+#define	DRVCTRL0_QSPI0_SPCLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL0_QSPI0_MOSI_IO0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL0_QSPI0_MISO_IO1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL0_QSPI0_IO2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL0_QSPI0_IO3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL0_QSPI0_SSL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL0_QSPI1_SPCLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL0_QSPI1_MOSI_IO0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL1_QSPI1_MISO_IO1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL1_QSPI1_IO2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL1_QSPI1_IO3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL1_QSPI1_SS(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL1_RPC_INT(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL1_RPC_WP(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL1_RPC_RESET(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL1_AVB_RX_CTL(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL2_AVB_RXC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL2_AVB_RD0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL2_AVB_RD1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL2_AVB_RD2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL2_AVB_RD3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL2_AVB_TX_CTL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL2_AVB_TXC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL2_AVB_TD0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL3_AVB_TD1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL3_AVB_TD2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL3_AVB_TD3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL3_AVB_TXCREFCLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL3_AVB_MDIO(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL3_AVB_MDC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL3_AVB_MAGIC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL3_AVB_PHY_INT(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL4_AVB_LINK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL4_AVB_AVTP_MATCH(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL4_AVB_AVTP_CAPTURE(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL4_IRQ0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL4_IRQ1(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL4_IRQ2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL4_IRQ3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL4_IRQ4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL5_IRQ5(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL5_PWM0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL5_PWM1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL5_PWM2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL5_A0(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL5_A1(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL5_A2(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL5_A3(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL6_A4(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL6_A5(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL6_A6(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL6_A7(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL6_A8(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL6_A9(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL6_A10(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL6_A11(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL7_A12(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL7_A13(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL7_A14(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL7_A15(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL7_A16(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL7_A17(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL7_A18(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL7_A19(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL8_CLKOUT(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL8_CS0(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL8_CS1_A2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL8_BS(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL8_RD(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL8_RD_W(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL8_WE0(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL8_WE1(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL9_EX_WAIT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL9_PRESETOU(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL9_D0(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL9_D1(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL9_D2(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL9_D3(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL9_D4(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL9_D5(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL10_D6(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL10_D7(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL10_D8(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL10_D9(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL10_D10(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL10_D11(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL10_D12(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL10_D13(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL11_D14(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL11_D15(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL11_AVS1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL11_AVS2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL11_HDMI0_CEC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL11_HDMI1_CEC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL11_DU_DOTCLKIN0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL11_DU_DOTCLKIN1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL12_DU_DOTCLKIN2(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL12_DU_DOTCLKIN3(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL12_DU_FSCLKST(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL12_DU_TMS(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_TDO(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL13_ASEBRK(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL13_SD0_CLK(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL13_SD0_CMD(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL13_SD0_DAT0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL13_SD0_DAT1(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL13_SD0_DAT2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_SD0_DAT3(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL14_SD1_CLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL14_SD1_CMD(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL14_SD1_DAT0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL14_SD1_DAT1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL14_SD1_DAT2(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL14_SD1_DAT3(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL14_SD2_CLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL14_SD2_CMD(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL15_SD2_DAT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL15_SD2_DAT1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL15_SD2_DAT2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL15_SD2_DAT3(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL15_SD2_DS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL15_SD3_CLK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL15_SD3_CMD(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL15_SD3_DAT0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL16_SD3_DAT1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL16_SD3_DAT2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL16_SD3_DAT3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL16_SD3_DAT4(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL16_SD3_DAT5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL16_SD3_DAT6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL16_SD3_DAT7(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL16_SD3_DS(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL17_SD0_CD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL17_SD0_WP(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL17_SD1_CD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL17_SD1_WP(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL17_SCK0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL17_RX0(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL17_TX0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL17_CTS0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL18_RTS0_TANS(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL18_RX1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL18_TX1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL18_CTS1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL18_RTS1_TANS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL18_SCK2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL18_TX2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL18_RX2(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL19_HSCK0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL19_HRX0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL19_HTX0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL19_HCTS0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL19_HRTS0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL19_MSIOF0_SCK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL19_MSIOF0_SYNC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL19_MSIOF0_SS1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL20_MSIOF0_TXD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL20_MSIOF0_SS2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL20_MSIOF0_RXD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL20_MLB_CLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL20_MLB_SIG(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL20_MLB_DAT(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL20_MLB_REF(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL20_SSI_SCK0129(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL21_SSI_WS0129(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL21_SSI_SDATA0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL21_SSI_SDATA1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL21_SSI_SDATA2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL21_SSI_SCK34(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL21_SSI_WS34(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL21_SSI_SDATA3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL21_SSI_SCK4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL22_SSI_WS4(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL22_SSI_SDATA4(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL22_SSI_SCK5(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL22_SSI_WS5(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL22_SSI_SDATA5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL22_SSI_SCK6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL22_SSI_WS6(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL22_SSI_SDATA6(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL23_SSI_SCK78(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL23_SSI_WS78(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL23_SSI_SDATA7(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL23_SSI_SDATA8(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL23_SSI_SDATA9(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL23_AUDIO_CLKA(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL23_AUDIO_CLKB(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL23_USB0_PWEN(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL24_USB0_OVC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL24_USB1_PWEN(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL24_USB1_OVC(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL24_USB30_PWEN(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL24_USB30_OVC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL24_USB31_PWEN(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL24_USB31_OVC(x)	((uint32_t)(x) << 4U)
+
+#define	MOD_SEL0_MSIOF3_A	((uint32_t)0U << 29U)
+#define	MOD_SEL0_MSIOF3_B	((uint32_t)1U << 29U)
+#define	MOD_SEL0_MSIOF3_C	((uint32_t)2U << 29U)
+#define	MOD_SEL0_MSIOF3_D	((uint32_t)3U << 29U)
+#define	MOD_SEL0_MSIOF3_E	((uint32_t)4U << 29U)
+#define	MOD_SEL0_MSIOF2_A	((uint32_t)0U << 27U)
+#define	MOD_SEL0_MSIOF2_B	((uint32_t)1U << 27U)
+#define	MOD_SEL0_MSIOF2_C	((uint32_t)2U << 27U)
+#define	MOD_SEL0_MSIOF2_D	((uint32_t)3U << 27U)
+#define	MOD_SEL0_MSIOF1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL0_MSIOF1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL0_MSIOF1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL0_MSIOF1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL0_MSIOF1_E	((uint32_t)4U << 24U)
+#define	MOD_SEL0_MSIOF1_F	((uint32_t)5U << 24U)
+#define	MOD_SEL0_MSIOF1_G	((uint32_t)6U << 24U)
+#define	MOD_SEL0_LBSC_A		((uint32_t)0U << 23U)
+#define	MOD_SEL0_LBSC_B		((uint32_t)1U << 23U)
+#define	MOD_SEL0_IEBUS_A	((uint32_t)0U << 22U)
+#define	MOD_SEL0_IEBUS_B	((uint32_t)1U << 22U)
+#define	MOD_SEL0_I2C2_A		((uint32_t)0U << 21U)
+#define	MOD_SEL0_I2C2_B		((uint32_t)1U << 21U)
+#define	MOD_SEL0_I2C1_A		((uint32_t)0U << 20U)
+#define	MOD_SEL0_I2C1_B		((uint32_t)1U << 20U)
+#define	MOD_SEL0_HSCIF4_A	((uint32_t)0U << 19U)
+#define	MOD_SEL0_HSCIF4_B	((uint32_t)1U << 19U)
+#define	MOD_SEL0_HSCIF3_A	((uint32_t)0U << 17U)
+#define	MOD_SEL0_HSCIF3_B	((uint32_t)1U << 17U)
+#define	MOD_SEL0_HSCIF3_C	((uint32_t)2U << 17U)
+#define	MOD_SEL0_HSCIF3_D	((uint32_t)3U << 17U)
+#define	MOD_SEL0_HSCIF1_A	((uint32_t)0U << 16U)
+#define	MOD_SEL0_HSCIF1_B	((uint32_t)1U << 16U)
+#define	MOD_SEL0_FSO_A		((uint32_t)0U << 15U)
+#define	MOD_SEL0_FSO_B		((uint32_t)1U << 15U)
+#define	MOD_SEL0_HSCIF2_A	((uint32_t)0U << 13U)
+#define	MOD_SEL0_HSCIF2_B	((uint32_t)1U << 13U)
+#define	MOD_SEL0_HSCIF2_C	((uint32_t)2U << 13U)
+#define	MOD_SEL0_ETHERAVB_A	((uint32_t)0U << 12U)
+#define	MOD_SEL0_ETHERAVB_B	((uint32_t)1U << 12U)
+#define	MOD_SEL0_DRIF3_A	((uint32_t)0U << 11U)
+#define	MOD_SEL0_DRIF3_B	((uint32_t)1U << 11U)
+#define	MOD_SEL0_DRIF2_A	((uint32_t)0U << 10U)
+#define	MOD_SEL0_DRIF2_B	((uint32_t)1U << 10U)
+#define	MOD_SEL0_DRIF1_A	((uint32_t)0U << 8U)
+#define	MOD_SEL0_DRIF1_B	((uint32_t)1U << 8U)
+#define	MOD_SEL0_DRIF1_C	((uint32_t)2U << 8U)
+#define	MOD_SEL0_DRIF0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL0_DRIF0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL0_DRIF0_C	((uint32_t)2U << 6U)
+#define	MOD_SEL0_CANFD0_A	((uint32_t)0U << 5U)
+#define	MOD_SEL0_CANFD0_B	((uint32_t)1U << 5U)
+#define	MOD_SEL0_ADG_A_A	((uint32_t)0U << 3U)
+#define	MOD_SEL0_ADG_A_B	((uint32_t)1U << 3U)
+#define	MOD_SEL0_ADG_A_C	((uint32_t)2U << 3U)
+#define	MOD_SEL1_TSIF1_A	((uint32_t)0U << 30U)
+#define	MOD_SEL1_TSIF1_B	((uint32_t)1U << 30U)
+#define	MOD_SEL1_TSIF1_C	((uint32_t)2U << 30U)
+#define	MOD_SEL1_TSIF1_D	((uint32_t)3U << 30U)
+#define	MOD_SEL1_TSIF0_A	((uint32_t)0U << 27U)
+#define	MOD_SEL1_TSIF0_B	((uint32_t)1U << 27U)
+#define	MOD_SEL1_TSIF0_C	((uint32_t)2U << 27U)
+#define	MOD_SEL1_TSIF0_D	((uint32_t)3U << 27U)
+#define	MOD_SEL1_TSIF0_E	((uint32_t)4U << 27U)
+#define	MOD_SEL1_TIMER_TMU_A	((uint32_t)0U << 26U)
+#define	MOD_SEL1_TIMER_TMU_B	((uint32_t)1U << 26U)
+#define	MOD_SEL1_SSP1_1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL1_SSP1_1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL1_SSP1_1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL1_SSP1_1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL1_SSP1_0_A	((uint32_t)0U << 21U)
+#define	MOD_SEL1_SSP1_0_B	((uint32_t)1U << 21U)
+#define	MOD_SEL1_SSP1_0_C	((uint32_t)2U << 21U)
+#define	MOD_SEL1_SSP1_0_D	((uint32_t)3U << 21U)
+#define	MOD_SEL1_SSP1_0_E	((uint32_t)4U << 21U)
+#define	MOD_SEL1_SSI_A		((uint32_t)0U << 20U)
+#define	MOD_SEL1_SSI_B		((uint32_t)1U << 20U)
+#define	MOD_SEL1_SPEED_PULSE_IF_A	((uint32_t)0U << 19U)
+#define	MOD_SEL1_SPEED_PULSE_IF_B	((uint32_t)1U << 19U)
+#define	MOD_SEL1_SIMCARD_A	((uint32_t)0U << 17U)
+#define	MOD_SEL1_SIMCARD_B	((uint32_t)1U << 17U)
+#define	MOD_SEL1_SIMCARD_C	((uint32_t)2U << 17U)
+#define	MOD_SEL1_SIMCARD_D	((uint32_t)3U << 17U)
+#define	MOD_SEL1_SDHI2_A	((uint32_t)0U << 16U)
+#define	MOD_SEL1_SDHI2_B	((uint32_t)1U << 16U)
+#define	MOD_SEL1_SCIF4_A	((uint32_t)0U << 14U)
+#define	MOD_SEL1_SCIF4_B	((uint32_t)1U << 14U)
+#define	MOD_SEL1_SCIF4_C	((uint32_t)2U << 14U)
+#define	MOD_SEL1_SCIF3_A	((uint32_t)0U << 13U)
+#define	MOD_SEL1_SCIF3_B	((uint32_t)1U << 13U)
+#define	MOD_SEL1_SCIF2_A	((uint32_t)0U << 12U)
+#define	MOD_SEL1_SCIF2_B	((uint32_t)1U << 12U)
+#define	MOD_SEL1_SCIF1_A	((uint32_t)0U << 11U)
+#define	MOD_SEL1_SCIF1_B	((uint32_t)1U << 11U)
+#define	MOD_SEL1_SCIF_A		((uint32_t)0U << 10U)
+#define	MOD_SEL1_SCIF_B		((uint32_t)1U << 10U)
+#define	MOD_SEL1_REMOCON_A	((uint32_t)0U << 9U)
+#define	MOD_SEL1_REMOCON_B	((uint32_t)1U << 9U)
+#define	MOD_SEL1_RCAN0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL1_RCAN0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL1_PWM6_A		((uint32_t)0U << 5U)
+#define	MOD_SEL1_PWM6_B		((uint32_t)1U << 5U)
+#define	MOD_SEL1_PWM5_A		((uint32_t)0U << 4U)
+#define	MOD_SEL1_PWM5_B		((uint32_t)1U << 4U)
+#define	MOD_SEL1_PWM4_A		((uint32_t)0U << 3U)
+#define	MOD_SEL1_PWM4_B		((uint32_t)1U << 3U)
+#define	MOD_SEL1_PWM3_A		((uint32_t)0U << 2U)
+#define	MOD_SEL1_PWM3_B		((uint32_t)1U << 2U)
+#define	MOD_SEL1_PWM2_A		((uint32_t)0U << 1U)
+#define	MOD_SEL1_PWM2_B		((uint32_t)1U << 1U)
+#define	MOD_SEL1_PWM1_A		((uint32_t)0U << 0U)
+#define	MOD_SEL1_PWM1_B		((uint32_t)1U << 0U)
+#define	MOD_SEL2_I2C_5_A	((uint32_t)0U << 31U)
+#define	MOD_SEL2_I2C_5_B	((uint32_t)1U << 31U)
+#define	MOD_SEL2_I2C_3_A	((uint32_t)0U << 30U)
+#define	MOD_SEL2_I2C_3_B	((uint32_t)1U << 30U)
+#define	MOD_SEL2_I2C_0_A	((uint32_t)0U << 29U)
+#define	MOD_SEL2_I2C_0_B	((uint32_t)1U << 29U)
+#define	MOD_SEL2_FM_A		((uint32_t)0U << 27U)
+#define	MOD_SEL2_FM_B		((uint32_t)1U << 27U)
+#define	MOD_SEL2_FM_C		((uint32_t)2U << 27U)
+#define	MOD_SEL2_FM_D		((uint32_t)3U << 27U)
+#define	MOD_SEL2_SCIF5_A	((uint32_t)0U << 26U)
+#define	MOD_SEL2_SCIF5_B	((uint32_t)1U << 26U)
+#define	MOD_SEL2_I2C6_A		((uint32_t)0U << 23U)
+#define	MOD_SEL2_I2C6_B		((uint32_t)1U << 23U)
+#define	MOD_SEL2_I2C6_C		((uint32_t)2U << 23U)
+#define	MOD_SEL2_NDF_A		((uint32_t)0U << 22U)
+#define	MOD_SEL2_NDF_B		((uint32_t)1U << 22U)
+#define	MOD_SEL2_SSI2_A		((uint32_t)0U << 21U)
+#define	MOD_SEL2_SSI2_B		((uint32_t)1U << 21U)
+#define	MOD_SEL2_SSI9_A		((uint32_t)0U << 20U)
+#define	MOD_SEL2_SSI9_B		((uint32_t)1U << 20U)
+#define	MOD_SEL2_TIMER_TMU2_A	((uint32_t)0U << 19U)
+#define	MOD_SEL2_TIMER_TMU2_B	((uint32_t)1U << 19U)
+#define	MOD_SEL2_ADG_B_A	((uint32_t)0U << 18U)
+#define	MOD_SEL2_ADG_B_B	((uint32_t)1U << 18U)
+#define	MOD_SEL2_ADG_C_A	((uint32_t)0U << 17U)
+#define	MOD_SEL2_ADG_C_B	((uint32_t)1U << 17U)
+#define	MOD_SEL2_VIN4_A		((uint32_t)0U << 0U)
+#define	MOD_SEL2_VIN4_B		((uint32_t)1U << 0U)
+
+
+/* SCIF3 Registers for Dummy write */
+#define SCIF3_BASE		(0xE6C50000U)
+#define SCIF3_SCFCR		(SCIF3_BASE + 0x0018U)
+#define SCIF3_SCFDR		(SCIF3_BASE + 0x001CU)
+#define SCFCR_DATA		(0x0000U)
+
+/* Realtime module stop control */
+#define	CPG_BASE		(0xE6150000U)
+#define CPG_MSTPSR0		(CPG_BASE + 0x0030U)
+#define CPG_RMSTPCR0		(CPG_BASE + 0x0110U)
+#define RMSTPCR0_RTDMAC		(0x00200000U)
+
+/* RT-DMAC Registers */
+#define RTDMAC_CH		(0U)		/* choose 0 to 15 */
+
+#define RTDMAC_BASE		(0xFFC10000U)
+#define RTDMAC_RDMOR		(RTDMAC_BASE + 0x0060U)
+#define RTDMAC_RDMCHCLR		(RTDMAC_BASE + 0x0080U)
+#define RTDMAC_RDMSAR(x)	(RTDMAC_BASE + 0x8000U + (0x80U * (x)))
+#define RTDMAC_RDMDAR(x)	(RTDMAC_BASE + 0x8004U + (0x80U * (x)))
+#define RTDMAC_RDMTCR(x)	(RTDMAC_BASE + 0x8008U + (0x80U * (x)))
+#define RTDMAC_RDMCHCR(x)	(RTDMAC_BASE + 0x800CU + (0x80U * (x)))
+#define RTDMAC_RDMCHCRB(x)	(RTDMAC_BASE + 0x801CU + (0x80U * (x)))
+#define RTDMAC_RDMDPBASE(x)	(RTDMAC_BASE + 0x8050U + (0x80U * (x)))
+#define RTDMAC_DESC_BASE	(RTDMAC_BASE + 0xA000U)
+#define RTDMAC_DESC_RDMSAR	(RTDMAC_DESC_BASE + 0x0000U)
+#define RTDMAC_DESC_RDMDAR	(RTDMAC_DESC_BASE + 0x0004U)
+#define RTDMAC_DESC_RDMTCR	(RTDMAC_DESC_BASE + 0x0008U)
+
+#define RDMOR_DME		(0x0001U)	/* DMA Master Enable */
+#define RDMCHCR_DPM_INFINITE	(0x30000000U)	/* Infinite repeat mode */
+#define RDMCHCR_RPT_TCR		(0x02000000U)	/* enable to update TCR */
+#define RDMCHCR_TS_2		(0x00000008U)	/* Word(2byte) units transfer */
+#define RDMCHCR_RS_AUTO		(0x00000400U)	/* Auto request */
+#define RDMCHCR_DE		(0x00000001U)	/* DMA Enable */
+#define RDMCHCRB_DRST		(0x00008000U)	/* Descriptor reset */
+#define RDMCHCRB_SLM_256	(0x00000080U)	/* once in 256 clock cycle */
+#define RDMDPBASE_SEL_EXT	(0x00000001U)	/* External memory use */
+
+
+static void pfc_reg_write(uint32_t addr, uint32_t data);
+
+static void pfc_reg_write(uint32_t addr, uint32_t data)
+{
+	uint32_t prr;
+
+	prr = mmio_read_32(RCAR_PRR);
+	prr &= (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+
+	mmio_write_32(PFC_PMMR, ~data);
+	if (prr == (RCAR_PRODUCT_M3_CUT10)) {
+		mmio_write_16(SCIF3_SCFCR, SCFCR_DATA);	/* Dummy write */
+	}
+	mmio_write_32((uintptr_t)addr, data);
+	if (prr == (RCAR_PRODUCT_M3_CUT10)) {
+		mmio_write_16(SCIF3_SCFCR, SCFCR_DATA);	/* Dummy write */
+	}
+}
+
+
+void pfc_init_d3(void)
+{
+	/* initialize module select */
+	pfc_reg_write(PFC_MOD_SEL0, 0x00000000U);
+	pfc_reg_write(PFC_MOD_SEL1, 0x00000000U);
+
+	/* initialize peripheral function select */
+	pfc_reg_write(PFC_IPSR0,  0x00000001U);
+	pfc_reg_write(PFC_IPSR1,  0x00000000U);
+	pfc_reg_write(PFC_IPSR2,  0x00000000U);
+	pfc_reg_write(PFC_IPSR3,  0x00000000U);
+	pfc_reg_write(PFC_IPSR4,  0x00002000U);
+	pfc_reg_write(PFC_IPSR5,  0x00000000U);
+	pfc_reg_write(PFC_IPSR6,  0x00000000U);
+	pfc_reg_write(PFC_IPSR7,  0x00000000U);
+	pfc_reg_write(PFC_IPSR8,  0x11003301U);
+	pfc_reg_write(PFC_IPSR9,  0x11111111U);
+	pfc_reg_write(PFC_IPSR10, 0x00020000U);
+	pfc_reg_write(PFC_IPSR11, 0x40001110U);
+	pfc_reg_write(PFC_IPSR12, 0x00000000U);
+	pfc_reg_write(PFC_IPSR13, 0x00000000U);
+
+	/* initialize GPIO/perihperal function select */
+	pfc_reg_write(PFC_GPSR0, 0x0000001FU);
+	pfc_reg_write(PFC_GPSR1, 0x3FFFFFFFU);
+	pfc_reg_write(PFC_GPSR2, 0xFFFFFFFFU);
+	pfc_reg_write(PFC_GPSR3, 0x000003FFU);
+	pfc_reg_write(PFC_GPSR4, 0xFC7F0F7EU);
+	pfc_reg_write(PFC_GPSR5, 0x001BFFFBU);
+	pfc_reg_write(PFC_GPSR6, 0x00003FFFU);
+
+	/* initialize POC control register */
+	pfc_reg_write(PFC_POCCTRL0,   0xC00FFFFFU);
+	pfc_reg_write(PFC_POCCTRL1,   0XFFFFFFFEU);
+	pfc_reg_write(PFC_TDSELCTRL0, 0x00000000U);
+
+	/* initialize LSI pin pull-up/down control */
+	pfc_reg_write(PFC_PUD0, 0x0047C1A2U);
+	pfc_reg_write(PFC_PUD1, 0x4E13ABFFU);
+	pfc_reg_write(PFC_PUD2, 0xFFFFFFFFU);
+	pfc_reg_write(PFC_PUD3, 0xFF0FFFFFU);
+	pfc_reg_write(PFC_PUD4, 0xE0000000U);
+	pfc_reg_write(PFC_PUD5, 0x60000000U);
+                            
+	/* initialize LSI pin pull-enable register */
+	pfc_reg_write(PFC_PUEN0, 0x00000000U);
+	pfc_reg_write(PFC_PUEN1, 0x00000000U);
+	pfc_reg_write(PFC_PUEN2, 0x00000000U);
+	pfc_reg_write(PFC_PUEN3, 0x000F008CU);
+	pfc_reg_write(PFC_PUEN4, 0x00000000U);
+	pfc_reg_write(PFC_PUEN5, 0x00000000U);
+                             
+	/* initialize positive/negative logic select */
+	mmio_write_32(GPIO_POSNEG0, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG1, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG2, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG3, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG4, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG5, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG6, 0x00000000U);
+
+	/* initialize general IO/interrupt switching */
+	mmio_write_32(GPIO_IOINTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL1, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL2, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL3, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL5, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL6, 0x00000000U);
+
+	/* initialize general output register */
+	mmio_write_32(GPIO_OUTDT0, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT1, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT2, 0x00000400U);
+	mmio_write_32(GPIO_OUTDT3, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT4, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT5, 0x00000006U);
+	mmio_write_32(GPIO_OUTDT6, 0x00003880U);
+
+	/* initialize general input/output switching */
+	mmio_write_32(GPIO_INOUTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL1, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL2, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL3, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL4, 0x00802000U);
+	mmio_write_32(GPIO_INOUTSEL5, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL6, 0x00000000U);
+}
diff --git a/plat/renesas/rcar/pfc/D3/pfc_init_d3.h b/plat/renesas/rcar/pfc/D3/pfc_init_d3.h
new file mode 100644
index 00000000..c8e0de13
--- /dev/null
+++ b/plat/renesas/rcar/pfc/D3/pfc_init_d3.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PFC_INIT_D3_H__
+#define PFC_INIT_D3_H__
+
+void pfc_init_d3(void);
+
+#endif	/* PFC_INIT_D3_H__ */
diff --git a/plat/renesas/rcar/pfc/pfc.mk b/plat/renesas/rcar/pfc/pfc.mk
index 27af9283..ef90d890 100644
--- a/plat/renesas/rcar/pfc/pfc.mk
+++ b/plat/renesas/rcar/pfc/pfc.mk
@@ -51,6 +51,9 @@ else
   ifeq (${RCAR_LSI},${RCAR_E3})
     BL2_SOURCES += plat/renesas/rcar/pfc/E3/pfc_init_e3.c
   endif
+  ifeq (${RCAR_LSI},${RCAR_D3})
+    BL2_SOURCES += plat/renesas/rcar/pfc/D3/pfc_init_d3.c
+  endif
 endif
 
 BL2_SOURCES += plat/renesas/rcar/pfc/pfc_init.c
diff --git a/plat/renesas/rcar/pfc/pfc_init.c b/plat/renesas/rcar/pfc/pfc_init.c
index 4e784eb6..b71d1169 100644
--- a/plat/renesas/rcar/pfc/pfc_init.c
+++ b/plat/renesas/rcar/pfc/pfc_init.c
@@ -28,6 +28,9 @@
 #if RCAR_LSI == RCAR_E3	/* E3 */
   #include "E3/pfc_init_e3.h"
 #endif
+#if RCAR_LSI == RCAR_D3	/* D3 */
+  #include "D3/pfc_init_d3.h"
+#endif
 
  /* Product Register */
 #define PRR			(0xFFF00044U)
@@ -37,6 +40,7 @@
 #define PRR_PRODUCT_M3		(0x00005200U)           /* R-Car M3 */
 #define PRR_PRODUCT_M3N		(0x00005500U)           /* R-Car M3N */
 #define PRR_PRODUCT_E3		(0x00005700U)		/* R-Car E3 */
+#define PRR_PRODUCT_D3		(0x00005800U)           /* R-Car D3 */
 #define PRR_PRODUCT_10		(0x00U)
 #define PRR_PRODUCT_11		(0x01U)
 #define PRR_PRODUCT_20		(0x10U)
@@ -167,6 +171,12 @@ void pfc_init(void)
 		PRR_PRODUCT_ERR(reg);
 	}
 	pfc_init_e3();
+ #elif RCAR_LSI == RCAR_D3	/* D3 */
+	if ((PRR_PRODUCT_D3 | PRR_PRODUCT_10)
+			!= (reg & (PRR_PRODUCT_MASK | PRR_CUT_MASK))) {
+		PRR_PRODUCT_ERR(reg);
+	}
+	pfc_init_d3();
  #else
   #error "Don't have PFC initialize routine(unknown)."
  #endif
diff --git a/plat/renesas/rcar/platform.mk b/plat/renesas/rcar/platform.mk
index 01e85641..7e7e5d5a 100644
--- a/plat/renesas/rcar/platform.mk
+++ b/plat/renesas/rcar/platform.mk
@@ -92,12 +92,14 @@ RCAR_M3:=1
 RCAR_M3N:=2
 RCAR_E3:=3
 RCAR_H3N:=4
+RCAR_D3:=5
 RCAR_AUTO:=99
 $(eval $(call add_define,RCAR_H3))
 $(eval $(call add_define,RCAR_M3))
 $(eval $(call add_define,RCAR_M3N))
 $(eval $(call add_define,RCAR_E3))
 $(eval $(call add_define,RCAR_H3N))
+$(eval $(call add_define,RCAR_D3))
 $(eval $(call add_define,RCAR_AUTO))
 RCAR_CUT_10:=0
 RCAR_CUT_11:=1
@@ -198,6 +200,8 @@ else
       endif
       $(eval $(call add_define,RCAR_LSI_CUT))
     endif
+  else ifeq (${LSI},D3)
+    RCAR_LSI:=${RCAR_D3}
   else
     $(error "Error: ${LSI} is not supported.")
   endif
@@ -206,7 +210,7 @@ endif
 
 # Process RCAR_SECURE_BOOT flag
 ifndef RCAR_SECURE_BOOT
-RCAR_SECURE_BOOT := 1
+RCAR_SECURE_BOOT := 0
 endif
 $(eval $(call add_define,RCAR_SECURE_BOOT))
 
@@ -229,28 +233,30 @@ endif
 $(eval $(call add_define,RCAR_BL33_EXECUTION_EL))
 
 # Process RCAR_AVS_SETTING_ENABLE flag
-ifeq (${RCAR_AVS_SETTING_ENABLE},0)
+#ifeq (${RCAR_AVS_SETTING_ENABLE},0)
+#AVS_SETTING_ENABLE := 0
+#else
+#AVS_SETTING_ENABLE := 1
+#endif
 AVS_SETTING_ENABLE := 0
-else
-AVS_SETTING_ENABLE := 1
-endif
 $(eval $(call add_define,AVS_SETTING_ENABLE))
 
 # Process RCAR_LOSSY_ENABLE flag
-ifndef RCAR_LOSSY_ENABLE
+#ifndef RCAR_LOSSY_ENABLE
+#RCAR_LOSSY_ENABLE := 0
+#endif
 RCAR_LOSSY_ENABLE := 0
-endif
 $(eval $(call add_define,RCAR_LOSSY_ENABLE))
 
 # Process LIFEC_DBSC_PROTECT_ENABLE flag
 ifndef LIFEC_DBSC_PROTECT_ENABLE
-LIFEC_DBSC_PROTECT_ENABLE := 1
+LIFEC_DBSC_PROTECT_ENABLE := 0
 endif
 $(eval $(call add_define,LIFEC_DBSC_PROTECT_ENABLE))
 
 # Process PMIC_ROHM_BD9571 flag
 ifndef PMIC_ROHM_BD9571
-PMIC_ROHM_BD9571 := 1
+PMIC_ROHM_BD9571 := 0
 endif
 $(eval $(call add_define,PMIC_ROHM_BD9571))
 
@@ -284,7 +290,7 @@ $(eval $(call add_define,RCAR_REWT_TRAINING))
 
 # Process RCAR_SYSTEM_SUSPEND flag
 ifndef RCAR_SYSTEM_SUSPEND
-RCAR_SYSTEM_SUSPEND := 1
+RCAR_SYSTEM_SUSPEND := 0
 endif
 $(eval $(call add_define,RCAR_SYSTEM_SUSPEND))
 
diff --git a/plat/renesas/rcar/qos/D3/qos_init_d3.c b/plat/renesas/rcar/qos/D3/qos_init_d3.c
new file mode 100644
index 00000000..09382b33
--- /dev/null
+++ b/plat/renesas/rcar/qos/D3/qos_init_d3.c
@@ -0,0 +1,606 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <debug.h>
+#include "qos_init_d3.h"
+
+
+#define	RCAR_QOS_VERSION		"rev.0.05"
+
+#define	RCAR_QOS_NONE			(3U)
+#define	RCAR_QOS_TYPE_DEFAULT		(0U)
+
+#define	RCAR_DRAM_SPLIT_LINEAR		(0U)
+#define	RCAR_DRAM_SPLIT_4CH		(1U)
+#define	RCAR_DRAM_SPLIT_2CH		(2U)
+#define	RCAR_DRAM_SPLIT_AUTO		(3U)
+
+#define	RST_BASE			(0xE6160000U)
+#define	RST_MODEMR			(RST_BASE + 0x0060U)
+
+#define	DBSC_BASE			(0xE6790000U)
+#define	DBSC_DBSYSCNT0			(DBSC_BASE + 0x0100U)
+#define	DBSC_AXARB			(DBSC_BASE + 0x0800U)
+#define DBSC_DBCAM0CNF0			(DBSC_BASE + 0x0900U)
+#define DBSC_DBCAM0CNF1			(DBSC_BASE + 0x0904U)
+#define DBSC_DBCAM0CNF2			(DBSC_BASE + 0x0908U)
+#define DBSC_DBCAM0CNF3			(DBSC_BASE + 0x090CU)
+#define DBSC_DBCAMDIS			(DBSC_BASE + 0x09fCU)
+#define DBSC_DBSCHCNT0			(DBSC_BASE + 0x1000U)
+#define DBSC_DBSCHCNT1			(DBSC_BASE + 0x1004U)
+#define DBSC_DBSCHSZ0			(DBSC_BASE + 0x1010U)
+#define DBSC_DBSCHRW0			(DBSC_BASE + 0x1020U)
+#define DBSC_DBSCHRW1			(DBSC_BASE + 0x1024U)
+#define DBSC_DBSCHQOS_0_0		(DBSC_BASE + 0x1030U)
+#define DBSC_DBSCHQOS_0_1		(DBSC_BASE + 0x1034U)
+#define DBSC_DBSCHQOS_0_2		(DBSC_BASE + 0x1038U)
+#define DBSC_DBSCHQOS_0_3		(DBSC_BASE + 0x103CU)
+#define DBSC_DBSCHQOS_1_0		(DBSC_BASE + 0x1040U)
+#define DBSC_DBSCHQOS_1_1		(DBSC_BASE + 0x1044U)
+#define DBSC_DBSCHQOS_1_2		(DBSC_BASE + 0x1048U)
+#define DBSC_DBSCHQOS_1_3		(DBSC_BASE + 0x104CU)
+#define DBSC_DBSCHQOS_2_0		(DBSC_BASE + 0x1050U)
+#define DBSC_DBSCHQOS_2_1		(DBSC_BASE + 0x1054U)
+#define DBSC_DBSCHQOS_2_2		(DBSC_BASE + 0x1058U)
+#define DBSC_DBSCHQOS_2_3		(DBSC_BASE + 0x105CU)
+#define DBSC_DBSCHQOS_3_0		(DBSC_BASE + 0x1060U)
+#define DBSC_DBSCHQOS_3_1		(DBSC_BASE + 0x1064U)
+#define DBSC_DBSCHQOS_3_2		(DBSC_BASE + 0x1068U)
+#define DBSC_DBSCHQOS_3_3		(DBSC_BASE + 0x106CU)
+#define DBSC_DBSCHQOS_4_0		(DBSC_BASE + 0x1070U)
+#define DBSC_DBSCHQOS_4_1		(DBSC_BASE + 0x1074U)
+#define DBSC_DBSCHQOS_4_2		(DBSC_BASE + 0x1078U)
+#define DBSC_DBSCHQOS_4_3		(DBSC_BASE + 0x107CU)
+#define DBSC_DBSCHQOS_5_0		(DBSC_BASE + 0x1080U)
+#define DBSC_DBSCHQOS_5_1		(DBSC_BASE + 0x1084U)
+#define DBSC_DBSCHQOS_5_2		(DBSC_BASE + 0x1088U)
+#define DBSC_DBSCHQOS_5_3		(DBSC_BASE + 0x108CU)
+#define DBSC_DBSCHQOS_6_0		(DBSC_BASE + 0x1090U)
+#define DBSC_DBSCHQOS_6_1		(DBSC_BASE + 0x1094U)
+#define DBSC_DBSCHQOS_6_2		(DBSC_BASE + 0x1098U)
+#define DBSC_DBSCHQOS_6_3		(DBSC_BASE + 0x109CU)
+#define DBSC_DBSCHQOS_7_0		(DBSC_BASE + 0x10A0U)
+#define DBSC_DBSCHQOS_7_1		(DBSC_BASE + 0x10A4U)
+#define DBSC_DBSCHQOS_7_2		(DBSC_BASE + 0x10A8U)
+#define DBSC_DBSCHQOS_7_3		(DBSC_BASE + 0x10ACU)
+#define DBSC_DBSCHQOS_8_0		(DBSC_BASE + 0x10B0U)
+#define DBSC_DBSCHQOS_8_1		(DBSC_BASE + 0x10B4U)
+#define DBSC_DBSCHQOS_8_2		(DBSC_BASE + 0x10B8U)
+#define DBSC_DBSCHQOS_8_3		(DBSC_BASE + 0x10BCU)
+#define DBSC_DBSCHQOS_9_0		(DBSC_BASE + 0x10C0U)
+#define DBSC_DBSCHQOS_9_1		(DBSC_BASE + 0x10C4U)
+#define DBSC_DBSCHQOS_9_2		(DBSC_BASE + 0x10C8U)
+#define DBSC_DBSCHQOS_9_3		(DBSC_BASE + 0x10CCU)
+#define DBSC_DBSCHQOS_10_0		(DBSC_BASE + 0x10D0U)
+#define DBSC_DBSCHQOS_10_1		(DBSC_BASE + 0x10D4U)
+#define DBSC_DBSCHQOS_10_2		(DBSC_BASE + 0x10D8U)
+#define DBSC_DBSCHQOS_10_3		(DBSC_BASE + 0x10DCU)
+#define DBSC_DBSCHQOS_11_0		(DBSC_BASE + 0x10E0U)
+#define DBSC_DBSCHQOS_11_1		(DBSC_BASE + 0x10E4U)
+#define DBSC_DBSCHQOS_11_2		(DBSC_BASE + 0x10E8U)
+#define DBSC_DBSCHQOS_11_3		(DBSC_BASE + 0x10ECU)
+#define DBSC_DBSCHQOS_12_0		(DBSC_BASE + 0x10F0U)
+#define DBSC_DBSCHQOS_12_1		(DBSC_BASE + 0x10F4U)
+#define DBSC_DBSCHQOS_12_2		(DBSC_BASE + 0x10F8U)
+#define DBSC_DBSCHQOS_12_3		(DBSC_BASE + 0x10FCU)
+#define DBSC_DBSCHQOS_13_0		(DBSC_BASE + 0x1100U)
+#define DBSC_DBSCHQOS_13_1		(DBSC_BASE + 0x1104U)
+#define DBSC_DBSCHQOS_13_2		(DBSC_BASE + 0x1108U)
+#define DBSC_DBSCHQOS_13_3		(DBSC_BASE + 0x110CU)
+#define DBSC_DBSCHQOS_14_0		(DBSC_BASE + 0x1110U)
+#define DBSC_DBSCHQOS_14_1		(DBSC_BASE + 0x1114U)
+#define DBSC_DBSCHQOS_14_2		(DBSC_BASE + 0x1118U)
+#define DBSC_DBSCHQOS_14_3		(DBSC_BASE + 0x111CU)
+#define DBSC_DBSCHQOS_15_0		(DBSC_BASE + 0x1120U)
+#define DBSC_DBSCHQOS_15_1		(DBSC_BASE + 0x1124U)
+#define DBSC_DBSCHQOS_15_2		(DBSC_BASE + 0x1128U)
+#define DBSC_DBSCHQOS_15_3		(DBSC_BASE + 0x112CU)
+#define DBSC_SCFCTST2			(DBSC_BASE + 0x170CU)
+
+#define	AXI_BASE			(0xE6784000U)
+#define	AXI_ADSPLCR0			(AXI_BASE + 0x0008U)
+#define	AXI_ADSPLCR3			(AXI_BASE + 0x0014U)
+
+#define	MSTAT_BASE			(0xE67E0000U)
+#define	MSTAT_FIX_QOS_BANK0		(MSTAT_BASE + 0x0000U)
+#define	MSTAT_FIX_QOS_BANK1		(MSTAT_BASE + 0x1000U)
+#define	MSTAT_BE_QOS_BANK0		(MSTAT_BASE + 0x2000U)
+#define	MSTAT_BE_QOS_BANK1		(MSTAT_BASE + 0x3000U)
+#define	MSTAT_SL_INIT			(MSTAT_BASE + 0x8000U)
+#define	MSTAT_REF_ARS			(MSTAT_BASE + 0x8004U)
+#define	MSTAT_STATQC			(MSTAT_BASE + 0x8008U)
+
+#define	RALLOC_BASE			(0xE67F0000U)
+#define	RALLOC_RAS			(RALLOC_BASE + 0x0000U)
+#define	RALLOC_FIXTH			(RALLOC_BASE + 0x0004U)
+#define	RALLOC_RAEN			(RALLOC_BASE + 0x0018U)
+#define	RALLOC_REGGD			(RALLOC_BASE + 0x0020U)
+#define	RALLOC_DANN			(RALLOC_BASE + 0x0030U)
+#define	RALLOC_DANT			(RALLOC_BASE + 0x0038U)
+#define	RALLOC_EC			(RALLOC_BASE + 0x003CU)
+#define	RALLOC_EMS			(RALLOC_BASE + 0x0040U)
+#define	RALLOC_FSS			(RALLOC_BASE + 0x0048U)
+#define	RALLOC_INSFC			(RALLOC_BASE + 0x0050U)
+#define	RALLOC_BERR			(RALLOC_BASE + 0x0054U)
+#define	RALLOC_EARLYR			(RALLOC_BASE + 0x0060U)
+#define	RALLOC_RACNT0			(RALLOC_BASE + 0x0080U)
+#define	RALLOC_TICKDUPL			(RALLOC_BASE + 0x0088U)
+
+#define ARRAY_SIZE(a)	(sizeof(a) / sizeof((a)[0]))
+
+static inline void io_write_32(uintptr_t addr, uint32_t value)
+{
+	*(volatile uint32_t*)addr = value;
+}
+
+static inline void io_write_64(uintptr_t addr, uint64_t value)
+{
+	*(volatile uint64_t*)addr = value;
+}
+
+typedef struct {
+	uintptr_t addr;
+	uint64_t value;
+} mstat_slot_t;
+
+
+#if RCAR_QOS_TYPE  == RCAR_QOS_TYPE_DEFAULT
+static const mstat_slot_t mstat_fix[] = {
+	{0x0000U, 0x0000000000000000U},
+	{0x0008U, 0x0000000000000000U},
+	{0x0010U, 0x0000000000000000U},
+	{0x0018U, 0x0000000000000000U},
+	{0x0020U, 0x0000000000000000U},
+	{0x0028U, 0x0000000000000000U},
+	{0x0030U, 0x001004340000FFFFU},
+	{0x0038U, 0x001004140000FFFFU},
+	{0x0040U, 0x0000000000000000U},
+	{0x0048U, 0x0000000000000000U},
+	{0x0050U, 0x0000000000000000U},
+	{0x0058U, 0x00140B030000FFFFU},
+	{0x0060U, 0x001408610000FFFFU},
+	{0x0068U, 0x0000000000000000U},
+	{0x0070U, 0x0000000000000000U},
+	{0x0078U, 0x0000000000000000U},
+	{0x0080U, 0x0000000000000000U},
+	{0x0088U, 0x001410620000FFFFU},
+	{0x0090U, 0x0000000000000000U},
+	{0x0098U, 0x0000000000000000U},
+	{0x00A0U, 0x000C041C0000FFFFU},
+	{0x00A8U, 0x000C04090000FFFFU},
+	{0x00B0U, 0x000C04110000FFFFU},
+	{0x00B8U, 0x0000000000000000U},
+	{0x00C0U, 0x000C041C0000FFFFU},
+	{0x00C8U, 0x000C04090000FFFFU},
+	{0x00D0U, 0x000C04110000FFFFU},
+	{0x00D8U, 0x0000000000000000U},
+	{0x00E0U, 0x0000000000000000U},
+	{0x00E8U, 0x0000000000000000U},
+	{0x00F0U, 0x001018570000FFFFU},
+	{0x00F8U, 0x0000000000000000U},
+	{0x0100U, 0x0000000000000000U},
+	{0x0108U, 0x0000000000000000U},
+	{0x0110U, 0x001008570000FFFFU},
+	{0x0118U, 0x0000000000000000U},
+	{0x0120U, 0x0000000000000000U},
+	{0x0128U, 0x0000000000000000U},
+	{0x0130U, 0x0000000000000000U},
+	{0x0138U, 0x0000000000000000U},
+	{0x0140U, 0x0000000000000000U},
+	{0x0148U, 0x0000000000000000U},
+	{0x0150U, 0x001008520000FFFFU},
+	{0x0158U, 0x0000000000000000U},
+	{0x0160U, 0x0000000000000000U},
+	{0x0168U, 0x0000000000000000U},
+	{0x0170U, 0x0000000000000000U},
+	{0x0178U, 0x0000000000000000U},
+	{0x0180U, 0x0000000000000000U},
+	{0x0188U, 0x0000000000000000U},
+	{0x0190U, 0x00100CA30000FFFFU},
+	{0x0198U, 0x0000000000000000U},
+	{0x01A0U, 0x0000000000000000U},
+	{0x01A8U, 0x0000000000000000U},
+	{0x01B0U, 0x0000000000000000U},
+	{0x01B8U, 0x0000000000000000U},
+	{0x01C0U, 0x0000000000000000U},
+	{0x01C8U, 0x0000000000000000U},
+	{0x01D0U, 0x0000000000000000U},
+	{0x01D8U, 0x0000000000000000U},
+	{0x01E0U, 0x0000000000000000U},
+	{0x01E8U, 0x000C04020000FFFFU},
+	{0x01F0U, 0x0000000000000000U},
+	{0x01F8U, 0x0000000000000000U},
+	{0x0200U, 0x0000000000000000U},
+	{0x0208U, 0x000C04090000FFFFU},
+	{0x0210U, 0x0000000000000000U},
+	{0x0218U, 0x0000000000000000U},
+	{0x0220U, 0x0000000000000000U},
+	{0x0228U, 0x0000000000000000U},
+	{0x0230U, 0x0000000000000000U},
+	{0x0238U, 0x0000000000000000U},
+	{0x0240U, 0x0000000000000000U},
+	{0x0248U, 0x0000000000000000U},
+	{0x0250U, 0x0000000000000000U},
+	{0x0258U, 0x0000000000000000U},
+	{0x0260U, 0x0000000000000000U},
+	{0x0268U, 0x001410040000FFFFU},
+	{0x0270U, 0x001404020000FFFFU},
+	{0x0278U, 0x0000000000000000U},
+	{0x0280U, 0x0000000000000000U},
+	{0x0288U, 0x0000000000000000U},
+	{0x0290U, 0x001410040000FFFFU},
+	{0x0298U, 0x001404020000FFFFU},
+	{0x02A0U, 0x000C04050000FFFFU},
+	{0x02A8U, 0x000C04050000FFFFU},
+	{0x02B0U, 0x0000000000000000U},
+	{0x02B8U, 0x0000000000000000U},
+	{0x02C0U, 0x0000000000000000U},
+	{0x02C8U, 0x0000000000000000U},
+	{0x02D0U, 0x000C04050000FFFFU},
+	{0x02D8U, 0x000C04050000FFFFU},
+	{0x02E0U, 0x0000000000000000U},
+	{0x02E8U, 0x0000000000000000U},
+	{0x02F0U, 0x0000000000000000U},
+	{0x02F8U, 0x0000000000000000U},
+	{0x0300U, 0x0000000000000000U},
+	{0x0308U, 0x0000000000000000U},
+	{0x0310U, 0x0000000000000000U},
+	{0x0318U, 0x0000000000000000U},
+	{0x0320U, 0x0000000000000000U},
+	{0x0328U, 0x0000000000000000U},
+	{0x0330U, 0x0000000000000000U},
+	{0x0338U, 0x0000000000000000U},
+	{0x0340U, 0x0000000000000000U},
+	{0x0348U, 0x0000000000000000U},
+	{0x0350U, 0x0000000000000000U},
+	{0x0358U, 0x0000000000000000U},
+	{0x0360U, 0x0000000000000000U},
+	{0x0368U, 0x0000000000000000U},
+	{0x0370U, 0x000C04020000FFFFU},
+	{0x0378U, 0x000C04020000FFFFU},
+	{0x0380U, 0x000C04090000FFFFU},
+	{0x0388U, 0x000C04090000FFFFU},
+	{0x0390U, 0x0000000000000000U},
+};
+
+static const mstat_slot_t mstat_be[] = {
+	{0x0000U, 0x0000000000000000U},
+	{0x0008U, 0x0000000000000000U},
+	{0x0010U, 0x0000000000000000U},
+	{0x0018U, 0x0000000000000000U},
+	{0x0020U, 0x0000000000000000U},
+	{0x0028U, 0x0000000000000000U},
+	{0x0030U, 0x0000000000000000U},
+	{0x0038U, 0x0000000000000000U},
+	{0x0040U, 0x0000000000000000U},
+	{0x0048U, 0x0000000000000000U},
+	{0x0050U, 0x0000000000000000U},
+	{0x0058U, 0x0000000000000000U},
+	{0x0060U, 0x0000000000000000U},
+	{0x0068U, 0x0000000000000000U},
+	{0x0070U, 0x0000000000000000U},
+	{0x0078U, 0x0000000000000000U},
+	{0x0080U, 0x0000000000000000U},
+	{0x0088U, 0x0000000000000000U},
+	{0x0090U, 0x0000000000000000U},
+	{0x0098U, 0x0000000000000000U},
+	{0x00A0U, 0x0000000000000000U},
+	{0x00A8U, 0x0000000000000000U},
+	{0x00B0U, 0x0000000000000000U},
+	{0x00B8U, 0x0000000000000000U},
+	{0x00C0U, 0x0000000000000000U},
+	{0x00C8U, 0x0000000000000000U},
+	{0x00D0U, 0x0000000000000000U},
+	{0x00D8U, 0x0000000000000000U},
+	{0x00E0U, 0x0000000000000000U},
+	{0x00E8U, 0x0000000000000000U},
+	{0x00F0U, 0x0000000000000000U},
+	{0x00F8U, 0x0000000000000000U},
+	{0x0100U, 0x0000000000000000U},
+	{0x0108U, 0x0000000000000000U},
+	{0x0110U, 0x0000000000000000U},
+	{0x0118U, 0x0000000000000000U},
+	{0x0120U, 0x0000000000000000U},
+	{0x0128U, 0x0000000000000000U},
+	{0x0130U, 0x0000000000000000U},
+	{0x0138U, 0x0000000000000000U},
+	{0x0140U, 0x0000000000000000U},
+	{0x0148U, 0x0000000000000000U},
+	{0x0150U, 0x0000000000000000U},
+	{0x0158U, 0x0000000000000000U},
+	{0x0160U, 0x0000000000000000U},
+	{0x0168U, 0x0000000000000000U},
+	{0x0170U, 0x0000000000000000U},
+	{0x0178U, 0x0000000000000000U},
+	{0x0180U, 0x0000000000000000U},
+	{0x0188U, 0x0000000000000000U},
+	{0x0190U, 0x0000000000000000U},
+	{0x0198U, 0x0000000000000000U},
+	{0x01A0U, 0x0000000000000000U},
+	{0x01A8U, 0x0000000000000000U},
+	{0x01B0U, 0x0000000000000000U},
+	{0x01B8U, 0x0000000000000000U},
+	{0x01C0U, 0x00110090060FA001U},
+	{0x01C8U, 0x00110090060FA001U},
+	{0x01D0U, 0x0000000000000000U},
+	{0x01D8U, 0x0000000000000000U},
+	{0x01E0U, 0x0000000000000000U},
+	{0x01E8U, 0x0000000000000000U},
+	{0x01F0U, 0x0011001006004401U},
+	{0x01F8U, 0x0000000000000000U},
+	{0x0200U, 0x0000000000000000U},
+	{0x0208U, 0x0000000000000000U},
+	{0x0210U, 0x0011001006004401U},
+	{0x0218U, 0x0011001006009801U},
+	{0x0220U, 0x0011001006009801U},
+	{0x0228U, 0x0000000000000000U},
+	{0x0230U, 0x0011001006009801U},
+	{0x0238U, 0x0011001006009801U},
+	{0x0240U, 0x0000000000000000U},
+	{0x0248U, 0x0000000000000000U},
+	{0x0250U, 0x0000000000000000U},
+	{0x0258U, 0x0000000000000000U},
+	{0x0260U, 0x0000000000000000U},
+	{0x0268U, 0x0000000000000000U},
+	{0x0270U, 0x0000000000000000U},
+	{0x0278U, 0x0000000000000000U},
+	{0x0280U, 0x0000000000000000U},
+	{0x0288U, 0x0000000000000000U},
+	{0x0290U, 0x0000000000000000U},
+	{0x0298U, 0x0000000000000000U},
+	{0x02A0U, 0x0000000000000000U},
+	{0x02A8U, 0x0000000000000000U},
+	{0x02B0U, 0x0000000000000000U},
+	{0x02B8U, 0x0011001006003401U},
+	{0x02C0U, 0x0000000000000000U},
+	{0x02C8U, 0x0000000000000000U},
+	{0x02D0U, 0x0000000000000000U},
+	{0x02D8U, 0x0000000000000000U},
+	{0x02E0U, 0x0000000000000000U},
+	{0x02E8U, 0x0011001006003401U},
+	{0x02F0U, 0x00110090060FA001U},
+	{0x02F8U, 0x00110090060FA001U},
+	{0x0300U, 0x0000000000000000U},
+	{0x0308U, 0x0000000000000000U},
+	{0x0310U, 0x0000000000000000U},
+	{0x0318U, 0x0012001006003401U},
+	{0x0320U, 0x0000000000000000U},
+	{0x0328U, 0x0000000000000000U},
+	{0x0330U, 0x0000000000000000U},
+	{0x0338U, 0x0000000000000000U},
+	{0x0340U, 0x0000000000000000U},
+	{0x0348U, 0x0000000000000000U},
+	{0x0350U, 0x0000000000000000U},
+	{0x0358U, 0x00120090060FA001U},
+	{0x0360U, 0x00120090060FA001U},
+	{0x0368U, 0x0012001006003401U},
+	{0x0370U, 0x0000000000000000U},
+	{0x0378U, 0x0000000000000000U},
+	{0x0380U, 0x0000000000000000U},
+	{0x0388U, 0x0000000000000000U},
+	{0x0390U, 0x0012001006003401U},
+};
+#endif
+
+static void dbsc_setting(void)
+{
+	uint32_t md=0;
+
+	/* BUFCAM settings */
+	//DBSC_DBCAM0CNF0 not set
+	io_write_32(DBSC_DBCAM0CNF1, 0x00043218);	//dbcam0cnf1
+	io_write_32(DBSC_DBCAM0CNF2, 0x000000F4);	//dbcam0cnf2
+	io_write_32(DBSC_DBSCHCNT0,  0x000F0037);	//dbschcnt0
+	//DBSC_DBSCHCNT1 not set
+	io_write_32(DBSC_DBSCHSZ0,   0x00000001);	//dbschsz0
+	io_write_32(DBSC_DBSCHRW0,   0x22421111);	//dbschrw0
+
+	md = (*((volatile uint32_t*)RST_MODEMR) & 0x00080000) >> 19;
+
+	switch (md) {
+	case 0x0:	//MD19=0 : DDR3L-1600, 4GByte(1GByte x4)
+		/* DDR1600 */
+		io_write_32(DBSC_SCFCTST2, 0x012F1123);
+		break;
+	default:	//MD19=1 : DDR3L-1856, 4GByte(1GByte x4)
+		/* DDR1856 */
+		io_write_32(DBSC_SCFCTST2, 0x012F1123);
+		break;
+	}
+
+	/* QoS Settings */
+	io_write_32(DBSC_DBSCHQOS_0_0,  0x00000F00);
+	io_write_32(DBSC_DBSCHQOS_0_1,  0x00000B00);
+	io_write_32(DBSC_DBSCHQOS_0_2,  0x00000000);
+	io_write_32(DBSC_DBSCHQOS_0_3,  0x00000000);
+	//DBSC_DBSCHQOS_1_0 not set
+	//DBSC_DBSCHQOS_1_1 not set
+	//DBSC_DBSCHQOS_1_2 not set
+	//DBSC_DBSCHQOS_1_3 not set
+	//DBSC_DBSCHQOS_2_0 not set
+	//DBSC_DBSCHQOS_2_1 not set
+	//DBSC_DBSCHQOS_2_2 not set
+	//DBSC_DBSCHQOS_2_3 not set
+	//DBSC_DBSCHQOS_3_0 not set
+	//DBSC_DBSCHQOS_3_1 not set
+	//DBSC_DBSCHQOS_3_2 not set
+	//DBSC_DBSCHQOS_3_3 not set
+	io_write_32(DBSC_DBSCHQOS_4_0,  0x00000300);
+	io_write_32(DBSC_DBSCHQOS_4_1,  0x000002F0);
+	io_write_32(DBSC_DBSCHQOS_4_2,  0x00000200);
+	io_write_32(DBSC_DBSCHQOS_4_3,  0x00000100);
+	//DBSC_DBSCHQOS_5_0 not set
+	//DBSC_DBSCHQOS_5_1 not set
+	//DBSC_DBSCHQOS_5_2 not set
+	//DBSC_DBSCHQOS_5_3 not set
+	//DBSC_DBSCHQOS_6_0 not set
+	//DBSC_DBSCHQOS_6_1 not set
+	//DBSC_DBSCHQOS_6_2 not set
+	//DBSC_DBSCHQOS_6_3 not set
+	//DBSC_DBSCHQOS_7_0 not set
+	//DBSC_DBSCHQOS_7_1 not set
+	//DBSC_DBSCHQOS_7_2 not set
+	//DBSC_DBSCHQOS_7_3 not set
+	//DBSC_DBSCHQOS_8_0 not set
+	//DBSC_DBSCHQOS_8_1 not set
+	//DBSC_DBSCHQOS_8_2 not set
+	//DBSC_DBSCHQOS_8_3 not set
+	io_write_32(DBSC_DBSCHQOS_9_0,  0x00000300);
+	io_write_32(DBSC_DBSCHQOS_9_1,  0x000002F0);
+	io_write_32(DBSC_DBSCHQOS_9_2,  0x00000200);
+	io_write_32(DBSC_DBSCHQOS_9_3,  0x00000100);
+	//DBSC_DBSCHQOS_10_0 not set
+	//DBSC_DBSCHQOS_10_1 not set
+	//DBSC_DBSCHQOS_10_2 not set
+	//DBSC_DBSCHQOS_10_3 not set
+	//DBSC_DBSCHQOS_11_0 not set
+	//DBSC_DBSCHQOS_11_1 not set
+	//DBSC_DBSCHQOS_11_2 not set
+	//DBSC_DBSCHQOS_11_3 not set
+	//DBSC_DBSCHQOS_12_0 not set
+	//DBSC_DBSCHQOS_12_1 not set
+	//DBSC_DBSCHQOS_12_2 not set
+	//DBSC_DBSCHQOS_12_3 not set
+	io_write_32(DBSC_DBSCHQOS_13_0, 0x00000100);
+	io_write_32(DBSC_DBSCHQOS_13_1, 0x000000F0);
+	io_write_32(DBSC_DBSCHQOS_13_2, 0x000000A0);
+	io_write_32(DBSC_DBSCHQOS_13_3, 0x00000040);
+	io_write_32(DBSC_DBSCHQOS_14_0, 0x000000C0);
+	io_write_32(DBSC_DBSCHQOS_14_1, 0x000000B0);
+	io_write_32(DBSC_DBSCHQOS_14_2, 0x00000080);
+	io_write_32(DBSC_DBSCHQOS_14_3, 0x00000040);
+	io_write_32(DBSC_DBSCHQOS_15_0, 0x00000040);
+	io_write_32(DBSC_DBSCHQOS_15_1, 0x00000030);
+	io_write_32(DBSC_DBSCHQOS_15_2, 0x00000020);
+	io_write_32(DBSC_DBSCHQOS_15_3, 0x00000010);
+}
+
+void qos_init_d3(void)
+{
+	io_write_32(DBSC_DBSYSCNT0, 0x00001234);
+
+	dbsc_setting();
+
+	/* DRAM Split Address mapping */
+#if RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_4CH
+	ERROR("DRAM Split 4ch not supported.(D3)");
+	panic();
+#elif RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_2CH
+	ERROR("DRAM Split 2ch not supported.(D3)");
+	panic();
+#elif RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_AUTO
+	ERROR("DRAM Split Auto not supported.(D3)");
+	panic();
+#elif RCAR_DRAM_SPLIT == RCAR_DRAM_SPLIT_LINEAR
+/*	NOTICE("BL2: DRAM Split is OFF\n"); */
+	/* Split setting(DDR 1ch) */
+	io_write_32(AXI_ADSPLCR0, 0x00000000U);
+	io_write_32(AXI_ADSPLCR3, 0x00000000U);
+#else
+	ERROR("DRAM split is an invalid value.(D3)");
+	panic();
+#endif
+
+#if !(RCAR_QOS_TYPE == RCAR_QOS_NONE)
+#if RCAR_QOS_TYPE  == RCAR_QOS_TYPE_DEFAULT
+	NOTICE("BL2: QoS is default setting(%s)\n", RCAR_QOS_VERSION);
+#endif
+
+	/* Resource Alloc setting */
+	io_write_32(RALLOC_RAS,   0x00000020U);
+	io_write_32(RALLOC_FIXTH, 0x000F0005U);
+	io_write_32(RALLOC_RAEN,  0x00000001U);
+	io_write_32(RALLOC_REGGD, 0x00000000U);
+	io_write_64(RALLOC_DANN,  0x0404020002020201U);
+	io_write_32(RALLOC_DANT,  0x00100804U);
+	io_write_32(RALLOC_EC,    0x00000000U);
+	io_write_64(RALLOC_EMS,   0x0000000000000000U);
+	io_write_32(RALLOC_FSS,   0x0000000AU);
+	io_write_32(RALLOC_INSFC, 0xC7840001U);
+	io_write_32(RALLOC_BERR,  0x00000000U);
+	io_write_32(RALLOC_EARLYR,  0x00000000U);
+	io_write_32(RALLOC_RACNT0,  0x00010003U);
+	io_write_32(RALLOC_TICKDUPL, 0x00000000U);
+
+	/* GPU setting */
+	io_write_32(0xFD812030U, 0x00000000U);
+
+	/* MSTAT setting */
+	io_write_32(MSTAT_SL_INIT, 0x030500ACU);
+	io_write_32(MSTAT_REF_ARS, 0x00780000U);
+
+	/* MSTAT SRAM setting */
+	{
+	uint32_t i;
+
+	for (i = 0U; i < ARRAY_SIZE(mstat_fix); i++) {
+		io_write_64(MSTAT_FIX_QOS_BANK0 + mstat_fix[i].addr,
+				mstat_fix[i].value);
+		io_write_64(MSTAT_FIX_QOS_BANK1 + mstat_fix[i].addr,
+				mstat_fix[i].value);
+	}
+	for (i = 0U; i < ARRAY_SIZE(mstat_be); i++) {
+		io_write_64(MSTAT_BE_QOS_BANK0 + mstat_be[i].addr,
+				mstat_be[i].value);
+		io_write_64(MSTAT_BE_QOS_BANK1 + mstat_be[i].addr,
+				mstat_be[i].value);
+	}
+	}
+
+	/* 3DG bus Leaf setting */
+	io_write_32(0xFD820808U, 0x00001234U);
+	io_write_32(0xFD820800U, 0x00000000U);
+	io_write_32(0xFD821800U, 0x00000000U);
+	io_write_32(0xFD822800U, 0x00000000U);
+	io_write_32(0xFD823800U, 0x00000000U);
+
+	/* RT bus Leaf setting */
+	io_write_32(0xF1300800U, 0x00000003U);
+	io_write_32(0xF1340800U, 0x00000003U);
+	io_write_32(0xFFC50800U, 0x00000000U);
+	io_write_32(0xFFC51800U, 0x00000000U);
+
+	/* Resource Alloc start */
+	io_write_32(RALLOC_RAEN,  0x00000001U);
+
+	/* MSTAT start */
+	io_write_32(MSTAT_STATQC, 0x00000001U);
+#else
+	NOTICE("BL2: QoS is None\n");
+
+	/* Resource Alloc setting */
+	io_write_32(RALLOC_EC,    0x00000000U);
+	/* Resource Alloc start */
+	io_write_32(RALLOC_RAEN,  0x00000001U);
+#endif /* !(RCAR_QOS_TYPE == RCAR_QOS_NONE) */
+	io_write_32(DBSC_DBSYSCNT0, 0x00000000);
+}
diff --git a/plat/renesas/rcar/qos/D3/qos_init_d3.h b/plat/renesas/rcar/qos/D3/qos_init_d3.h
new file mode 100644
index 00000000..d9beb81b
--- /dev/null
+++ b/plat/renesas/rcar/qos/D3/qos_init_d3.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2017, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef QOS_INIT_H_D3__
+#define QOS_INIT_H_D3__
+
+void qos_init_d3(void);
+
+#endif	/* QOS_INIT_H_D3__ */
diff --git a/plat/renesas/rcar/qos/qos.mk b/plat/renesas/rcar/qos/qos.mk
index b738de6c..7b3d42f8 100644
--- a/plat/renesas/rcar/qos/qos.mk
+++ b/plat/renesas/rcar/qos/qos.mk
@@ -82,6 +82,9 @@ else
      BL2_SOURCES += plat/renesas/rcar/qos/E3/qos_init_e3_v10.c
     endif
   endif
+  ifeq (${RCAR_LSI},${RCAR_D3})
+    BL2_SOURCES += plat/renesas/rcar/qos/D3/qos_init_d3.c
+  endif
 endif
 
 BL2_SOURCES += plat/renesas/rcar/qos/qos_init.c
diff --git a/plat/renesas/rcar/qos/qos_init.c b/plat/renesas/rcar/qos/qos_init.c
index 47c156c6..62e6418d 100644
--- a/plat/renesas/rcar/qos/qos_init.c
+++ b/plat/renesas/rcar/qos/qos_init.c
@@ -37,6 +37,9 @@
 #if RCAR_LSI == RCAR_E3	/* E3 */
   #include "E3/qos_init_e3_v10.h"
 #endif
+#if RCAR_LSI == RCAR_D3	/* D3 */
+  #include "D3/qos_init_d3.h"
+#endif
 
  /* Product Register */
 #define PRR			(0xFFF00044U)
@@ -46,12 +49,13 @@
 #define PRR_PRODUCT_M3		(0x00005200U)           /* R-Car M3 */
 #define PRR_PRODUCT_M3N		(0x00005500U)           /* R-Car M3N */
 #define PRR_PRODUCT_E3		(0x00005700U)           /* R-Car E3 */
+#define PRR_PRODUCT_D3		(0x00005800U)           /* R-Car D3 */
 #define PRR_PRODUCT_10		(0x00U)
 #define PRR_PRODUCT_11		(0x01U)
 #define PRR_PRODUCT_20		(0x10U)
 #define PRR_PRODUCT_30		(0x20U)
 
-#if !(RCAR_LSI == RCAR_E3)
+#if ((RCAR_LSI != RCAR_D3) && (RCAR_LSI != RCAR_E3))
 
 #define DRAM_CH_CNT			0x04
 uint32_t qos_init_ddr_ch;
@@ -73,7 +77,7 @@ uint8_t  qos_init_ddr_phyvalid;
 void qos_init(void)
 {
 	uint32_t reg;
-#if !(RCAR_LSI == RCAR_E3)
+#if ((RCAR_LSI != RCAR_D3) && (RCAR_LSI != RCAR_E3))
 	uint32_t i;
 
 	qos_init_ddr_ch = 0;
@@ -227,6 +231,11 @@ void qos_init(void)
 		PRR_PRODUCT_ERR(reg);
 	}
 	qos_init_e3_v10();
+ #elif RCAR_LSI == RCAR_D3	/* D3 */
+	if (PRR_PRODUCT_D3 != (reg & (PRR_PRODUCT_MASK | PRR_CUT_MASK))) {
+		PRR_PRODUCT_ERR(reg);
+	}
+	qos_init_d3();
  #else
   #error "Don't have QoS initialize routine(Unknown chip)."
  #endif
diff --git a/plat/renesas/rcar/rcar_def.h b/plat/renesas/rcar/rcar_def.h
index 0cffb871..7cefb0eb 100644
--- a/plat/renesas/rcar/rcar_def.h
+++ b/plat/renesas/rcar/rcar_def.h
@@ -208,6 +208,7 @@
 #define RCAR_PRODUCT_M3			U(0x00005200)
 #define RCAR_PRODUCT_M3N		U(0x00005500)
 #define RCAR_PRODUCT_E3			U(0x00005700)
+#define RCAR_PRODUCT_D3			U(0x00005800)
 #define RCAR_CUT_VER10			U(0x00000000)
 #define RCAR_CUT_VER11			U(0x00000001)	/* H3/M3N Ver.1.1 */
 #define RCAR_M3_CUT_VER11		U(0x00000010)	/* M3 Ver.1.1/Ver.1.2 */
@@ -285,6 +286,7 @@
 #define	EXTAL_MD14_MD13_TYPE_3	U(16666600)	/* When MD14=1 MD13=1 */
 #define	EXTAL_SALVATOR_XS	U(8320000)	/* When board is Salvator-XS */
 #define EXTAL_EBISU		U(24000000)	/* When board is Ebisu */
+#define EXTAL_DRAAK		U(24000000)	/* When board is Draak */
 
 /*******************************************************************************
  * CPU Auxiliary Control Register specific definitions.
diff --git a/plat/renesas/rcar/rcar_pm.c b/plat/renesas/rcar/rcar_pm.c
index fce86929..b8959696 100644
--- a/plat/renesas/rcar/rcar_pm.c
+++ b/plat/renesas/rcar/rcar_pm.c
@@ -75,14 +75,18 @@ static void rcar_cpu_pwrdwn_common(void)
  ******************************************************************************/
 static void rcar_cluster_pwrdwn_common(void)
 {
+#if RCAR_LSI != RCAR_D3
 	uint32_t cluster_type;
+#endif
 	uint64_t mpidr = read_mpidr_el1();
 
+#if RCAR_LSI != RCAR_D3
 	cluster_type = rcar_bl31_get_cluster();
 	if (RCAR_CLUSTER_A53A57 == cluster_type) {
 		/* Disable coherency if this cluster is to be turned off */
 		rcar_cci_disable();
 	}
+#endif
 
 	/* Program the power controller to turn the cluster off */
 	rcar_pwrc_clusteroff(mpidr);
diff --git a/tools/dummy_create/makefile b/tools/dummy_create/makefile
index 90931114..6b8534f8 100644
--- a/tools/dummy_create/makefile
+++ b/tools/dummy_create/makefile
@@ -88,8 +88,8 @@ $(OUTPUT_FILE_SA0) : $(MEMORY_DEF_SA0) $(OBJ_FILE_SA0)
 	-o $(OUTPUT_FILE_SA0)			\
 	-Map $(FILE_NAME_SA0).map 		\
 
-	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).srec
-	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).bin
+	$(objcopy) -O srec --adjust-vma=0xE6312000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).srec
+	$(objcopy) -O binary --adjust-vma=0xE6312000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).bin
 
 $(OUTPUT_FILE_SA6) : $(MEMORY_DEF_SA6) $(OBJ_FILE_SA6)
 	$(LD) $(OBJ_FILE_SA6)		 	\
@@ -97,8 +97,8 @@ $(OUTPUT_FILE_SA6) : $(MEMORY_DEF_SA6) $(OBJ_FILE_SA6)
 	-o $(OUTPUT_FILE_SA6)			\
 	-Map $(FILE_NAME_SA6).map 		\
 
-	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).srec
-	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).bin
+	$(objcopy) -O srec --adjust-vma=0xE6312000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).srec
+	$(objcopy) -O binary --adjust-vma=0xE6312000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).bin
 
 ###################################################
 # Compile
diff --git a/tools/dummy_create/sa0.c b/tools/dummy_create/sa0.c
index bfaffeb9..a4db9533 100644
--- a/tools/dummy_create/sa0.c
+++ b/tools/dummy_create/sa0.c
@@ -22,10 +22,10 @@ const unsigned int __attribute__ ((section (".sa0_bootrom"))) bootrom_paramA = 0
 /* 0x000001D4 */
 const unsigned int __attribute__ ((section (".sa0_bl2dst_addr3"))) bl2dst_addr3 = BL2_ADDRESS;
 /* 0x000002E4 */
-const unsigned int __attribute__ ((section (".sa0_bl2dst_size3"))) bl2dst_size3 = BL2_SIZE;
-/* 0x00000C00 (Map Type 1 for HyperFlash/QSPI Flash Boot)*/
+const unsigned int __attribute__ ((section (".sa0_bl2cert_size0a"))) bl2cert_size2a = 0x00005000;
+/* 0x00000C00 (Old Map)*/
 /* 0x00000D54 */
 const unsigned int __attribute__ ((section (".sa0_bl2dst_addr1"))) bl2dst_addr1 = BL2_ADDRESS;
 /* 0x00000E64 */
-const unsigned int __attribute__ ((section (".sa0_bl2dst_size1"))) bl2dst_size1 = BL2_SIZE;
+const unsigned int __attribute__ ((section (".sa0_bl2cert_size1a"))) bl2cert_size = 0x00005000;
 
-- 
2.17.1

